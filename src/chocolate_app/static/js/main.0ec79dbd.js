/*! For license information please see main.0ec79dbd.js.LICENSE.txt */
(() => { var e = { 3874: (e, t, n) => { "use strict"; var i = n(9851); e.exports = function (e, t) { return void 0 === t && (t = !1), function (n, r, s) { if (n) e(n); else if (r.statusCode >= 400 && r.statusCode <= 599) { var a = s; if (t) if (i.TextDecoder) { var o = function (e) { void 0 === e && (e = ""); return e.toLowerCase().split(";").reduce((function (e, t) { var n = t.split("="), i = n[0], r = n[1]; return "charset" === i.trim() ? r.trim() : e }), "utf-8") }(r.headers && r.headers["content-type"]); try { a = new TextDecoder(o).decode(s) } catch (l) { } } else a = String.fromCharCode.apply(null, new Uint8Array(s)); e({ cause: a }) } else e(null, s) } } }, 6656: (e, t, n) => { "use strict"; var i = n(9851), r = n(434), s = n(8112); l.httpHandler = n(3874); var a = function (e) { var t = {}; return e ? (e.trim().split("\n").forEach((function (e) { var n = e.indexOf(":"), i = e.slice(0, n).trim().toLowerCase(), r = e.slice(n + 1).trim(); "undefined" === typeof t[i] ? t[i] = r : Array.isArray(t[i]) ? t[i].push(r) : t[i] = [t[i], r] })), t) : t }; function o(e, t, n) { var i = e; return s(t) ? (n = t, "string" === typeof e && (i = { uri: e })) : i = r({}, t, { uri: e }), i.callback = n, i } function l(e, t, n) { return c(t = o(e, t, n)) } function c(e) { if ("undefined" === typeof e.callback) throw new Error("callback argument missing"); var t = !1, n = function (n, i, r) { t || (t = !0, e.callback(n, i, r)) }; function i() { var e = void 0; if (e = u.response ? u.response : u.responseText || function (e) { try { if ("document" === e.responseType) return e.responseXML; var t = e.responseXML && "parsererror" === e.responseXML.documentElement.nodeName; if ("" === e.responseType && !t) return e.responseXML } catch (n) { } return null }(u), y) try { e = JSON.parse(e) } catch (t) { } return e } function r(e) { return clearTimeout(d), e instanceof Error || (e = new Error("" + (e || "Unknown XMLHttpRequest Error"))), e.statusCode = 0, n(e, v) } function s() { if (!c) { var t; clearTimeout(d), t = e.useXDR && void 0 === u.status ? 200 : 1223 === u.status ? 204 : u.status; var r = v, s = null; return 0 !== t ? (r = { body: i(), statusCode: t, method: p, headers: {}, url: h, rawRequest: u }, u.getAllResponseHeaders && (r.headers = a(u.getAllResponseHeaders()))) : s = new Error("Internal XMLHttpRequest Error"), n(s, r, r.body) } } var o, c, u = e.xhr || null; u || (u = e.cors || e.useXDR ? new l.XDomainRequest : new l.XMLHttpRequest); var d, h = u.url = e.uri || e.url, p = u.method = e.method || "GET", f = e.body || e.data, m = u.headers = e.headers || {}, g = !!e.sync, y = !1, v = { body: void 0, headers: {}, statusCode: 0, method: p, url: h, rawRequest: u }; if ("json" in e && !1 !== e.json && (y = !0, m.accept || m.Accept || (m.Accept = "application/json"), "GET" !== p && "HEAD" !== p && (m["content-type"] || m["Content-Type"] || (m["Content-Type"] = "application/json"), f = JSON.stringify(!0 === e.json ? f : e.json))), u.onreadystatechange = function () { 4 === u.readyState && setTimeout(s, 0) }, u.onload = s, u.onerror = r, u.onprogress = function () { }, u.onabort = function () { c = !0 }, u.ontimeout = r, u.open(p, h, !g, e.username, e.password), g || (u.withCredentials = !!e.withCredentials), !g && e.timeout > 0 && (d = setTimeout((function () { if (!c) { c = !0, u.abort("timeout"); var e = new Error("XMLHttpRequest timeout"); e.code = "ETIMEDOUT", r(e) } }), e.timeout)), u.setRequestHeader) for (o in m) m.hasOwnProperty(o) && u.setRequestHeader(o, m[o]); else if (e.headers && !function (e) { for (var t in e) if (e.hasOwnProperty(t)) return !1; return !0 }(e.headers)) throw new Error("Headers cannot be set on an XDomainRequest object"); return "responseType" in e && (u.responseType = e.responseType), "beforeSend" in e && "function" === typeof e.beforeSend && e.beforeSend(u), u.send(f || null), u } e.exports = l, e.exports.default = l, l.XMLHttpRequest = i.XMLHttpRequest || function () { }, l.XDomainRequest = "withCredentials" in new l.XMLHttpRequest ? l.XMLHttpRequest : i.XDomainRequest, function (e, t) { for (var n = 0; n < e.length; n++)t(e[n]) }(["get", "put", "post", "patch", "head", "delete"], (function (e) { l["delete" === e ? "del" : e] = function (t, n, i) { return (n = o(t, n, i)).method = e.toUpperCase(), c(n) } })) }, 9145: (e, t) => { "use strict"; function n(e, t) { return void 0 === t && (t = Object), t && "function" === typeof t.freeze ? t.freeze(e) : e } var i = n({ HTML: "text/html", isHTML: function (e) { return e === i.HTML }, XML_APPLICATION: "application/xml", XML_TEXT: "text/xml", XML_XHTML_APPLICATION: "application/xhtml+xml", XML_SVG_IMAGE: "image/svg+xml" }), r = n({ HTML: "http://www.w3.org/1999/xhtml", isHTML: function (e) { return e === r.HTML }, SVG: "http://www.w3.org/2000/svg", XML: "http://www.w3.org/XML/1998/namespace", XMLNS: "http://www.w3.org/2000/xmlns/" }); t.assign = function (e, t) { if (null === e || "object" !== typeof e) throw new TypeError("target is not an object"); for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e }, t.find = function (e, t, n) { if (void 0 === n && (n = Array.prototype), e && "function" === typeof n.find) return n.find.call(e, t); for (var i = 0; i < e.length; i++)if (Object.prototype.hasOwnProperty.call(e, i)) { var r = e[i]; if (t.call(void 0, r, i, e)) return r } }, t.freeze = n, t.MIME_TYPE = i, t.NAMESPACE = r }, 4708: (e, t, n) => { var i = n(9145), r = n(9668), s = n(1775), a = n(9660), o = r.DOMImplementation, l = i.NAMESPACE, c = a.ParseError, u = a.XMLReader; function d(e) { return e.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n") } function h(e) { this.options = e || { locator: {} } } function p() { this.cdata = !1 } function f(e, t) { t.lineNumber = e.lineNumber, t.columnNumber = e.columnNumber } function m(e) { if (e) return "\n@" + (e.systemId || "") + "#[line:" + e.lineNumber + ",col:" + e.columnNumber + "]" } function g(e, t, n) { return "string" == typeof e ? e.substr(t, n) : e.length >= t + n || t ? new java.lang.String(e, t, n) + "" : e } function y(e, t) { e.currentElement ? e.currentElement.appendChild(t) : e.doc.appendChild(t) } h.prototype.parseFromString = function (e, t) { var n = this.options, i = new u, r = n.domBuilder || new p, a = n.errorHandler, o = n.locator, c = n.xmlns || {}, h = /\/x?html?$/.test(t), f = h ? s.HTML_ENTITIES : s.XML_ENTITIES; o && r.setDocumentLocator(o), i.errorHandler = function (e, t, n) { if (!e) { if (t instanceof p) return t; e = t } var i = {}, r = e instanceof Function; function s(t) { var s = e[t]; !s && r && (s = 2 == e.length ? function (n) { e(t, n) } : e), i[t] = s && function (e) { s("[xmldom " + t + "]\t" + e + m(n)) } || function () { } } return n = n || {}, s("warning"), s("error"), s("fatalError"), i }(a, r, o), i.domBuilder = n.domBuilder || r, h && (c[""] = l.HTML), c.xml = c.xml || l.XML; var g = n.normalizeLineEndings || d; return e && "string" === typeof e ? i.parse(g(e), c, f) : i.errorHandler.error("invalid doc source"), r.doc }, p.prototype = { startDocument: function () { this.doc = (new o).createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId) }, startElement: function (e, t, n, i) { var r = this.doc, s = r.createElementNS(e, n || t), a = i.length; y(this, s), this.currentElement = s, this.locator && f(this.locator, s); for (var o = 0; o < a; o++) { e = i.getURI(o); var l = i.getValue(o), c = (n = i.getQName(o), r.createAttributeNS(e, n)); this.locator && f(i.getLocator(o), c), c.value = c.nodeValue = l, s.setAttributeNode(c) } }, endElement: function (e, t, n) { var i = this.currentElement; i.tagName; this.currentElement = i.parentNode }, startPrefixMapping: function (e, t) { }, endPrefixMapping: function (e) { }, processingInstruction: function (e, t) { var n = this.doc.createProcessingInstruction(e, t); this.locator && f(this.locator, n), y(this, n) }, ignorableWhitespace: function (e, t, n) { }, characters: function (e, t, n) { if (e = g.apply(this, arguments)) { if (this.cdata) var i = this.doc.createCDATASection(e); else i = this.doc.createTextNode(e); this.currentElement ? this.currentElement.appendChild(i) : /^\s*$/.test(e) && this.doc.appendChild(i), this.locator && f(this.locator, i) } }, skippedEntity: function (e) { }, endDocument: function () { this.doc.normalize() }, setDocumentLocator: function (e) { (this.locator = e) && (e.lineNumber = 0) }, comment: function (e, t, n) { e = g.apply(this, arguments); var i = this.doc.createComment(e); this.locator && f(this.locator, i), y(this, i) }, startCDATA: function () { this.cdata = !0 }, endCDATA: function () { this.cdata = !1 }, startDTD: function (e, t, n) { var i = this.doc.implementation; if (i && i.createDocumentType) { var r = i.createDocumentType(e, t, n); this.locator && f(this.locator, r), y(this, r), this.doc.doctype = r } }, warning: function (e) { console.warn("[xmldom warning]\t" + e, m(this.locator)) }, error: function (e) { console.error("[xmldom error]\t" + e, m(this.locator)) }, fatalError: function (e) { throw new c(e, this.locator) } }, "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, (function (e) { p.prototype[e] = function () { return null } })), t.DOMParser = h }, 9668: (e, t, n) => { var i = n(9145), r = i.find, s = i.NAMESPACE; function a(e) { return "" !== e } function o(e, t) { return e.hasOwnProperty(t) || (e[t] = !0), e } function l(e) { if (!e) return []; var t = function (e) { return e ? e.split(/[\t\n\f\r ]+/).filter(a) : [] }(e); return Object.keys(t.reduce(o, {})) } function c(e, t) { for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]) } function u(e, t) { var n = e.prototype; if (!(n instanceof t)) { function i() { } i.prototype = t.prototype, c(n, i = new i), e.prototype = n = i } n.constructor != e && ("function" != typeof e && console.error("unknown Class:" + e), n.constructor = e) } var d = {}, h = d.ELEMENT_NODE = 1, p = d.ATTRIBUTE_NODE = 2, f = d.TEXT_NODE = 3, m = d.CDATA_SECTION_NODE = 4, g = d.ENTITY_REFERENCE_NODE = 5, y = d.ENTITY_NODE = 6, v = d.PROCESSING_INSTRUCTION_NODE = 7, b = d.COMMENT_NODE = 8, _ = d.DOCUMENT_NODE = 9, T = d.DOCUMENT_TYPE_NODE = 10, S = d.DOCUMENT_FRAGMENT_NODE = 11, w = d.NOTATION_NODE = 12, x = {}, k = {}, E = (x.INDEX_SIZE_ERR = (k[1] = "Index size error", 1), x.DOMSTRING_SIZE_ERR = (k[2] = "DOMString size error", 2), x.HIERARCHY_REQUEST_ERR = (k[3] = "Hierarchy request error", 3)), C = (x.WRONG_DOCUMENT_ERR = (k[4] = "Wrong document", 4), x.INVALID_CHARACTER_ERR = (k[5] = "Invalid character", 5), x.NO_DATA_ALLOWED_ERR = (k[6] = "No data allowed", 6), x.NO_MODIFICATION_ALLOWED_ERR = (k[7] = "No modification allowed", 7), x.NOT_FOUND_ERR = (k[8] = "Not found", 8)), P = (x.NOT_SUPPORTED_ERR = (k[9] = "Not supported", 9), x.INUSE_ATTRIBUTE_ERR = (k[10] = "Attribute in use", 10)); x.INVALID_STATE_ERR = (k[11] = "Invalid state", 11), x.SYNTAX_ERR = (k[12] = "Syntax error", 12), x.INVALID_MODIFICATION_ERR = (k[13] = "Invalid modification", 13), x.NAMESPACE_ERR = (k[14] = "Invalid namespace", 14), x.INVALID_ACCESS_ERR = (k[15] = "Invalid access", 15); function I(e, t) { if (t instanceof Error) var n = t; else n = this, Error.call(this, k[e]), this.message = k[e], Error.captureStackTrace && Error.captureStackTrace(this, I); return n.code = e, t && (this.message = this.message + ": " + t), n } function L() { } function O(e, t) { this._node = e, this._refresh = t, A(this) } function A(e) { var t = e._node._inc || e._node.ownerDocument._inc; if (e._inc != t) { var n = e._refresh(e._node); be(e, "length", n.length), c(n, e), e._inc = t } } function N() { } function j(e, t) { for (var n = e.length; n--;)if (e[n] === t) return n } function D(e, t, n, i) { if (i ? t[j(t, i)] = n : t[t.length++] = n, e) { n.ownerElement = e; var r = e.ownerDocument; r && (i && H(r, e, i), function (e, t, n) { e && e._inc++; var i = n.namespaceURI; i === s.XMLNS && (t._nsMap[n.prefix ? n.localName : ""] = n.value) }(r, e, n)) } } function M(e, t, n) { var i = j(t, n); if (!(i >= 0)) throw new I(C, new Error(e.tagName + "@" + n)); for (var r = t.length - 1; i < r;)t[i] = t[++i]; if (t.length = r, e) { var s = e.ownerDocument; s && (H(s, e, n), n.ownerElement = null) } } function R() { } function U() { } function B(e) { return ("<" == e ? "&lt;" : ">" == e && "&gt;") || "&" == e && "&amp;" || '"' == e && "&quot;" || "&#" + e.charCodeAt() + ";" } function F(e, t) { if (t(e)) return !0; if (e = e.firstChild) do { if (F(e, t)) return !0 } while (e = e.nextSibling) } function z() { this.ownerDocument = this } function H(e, t, n, i) { e && e._inc++, n.namespaceURI === s.XMLNS && delete t._nsMap[n.prefix ? n.localName : ""] } function V(e, t, n) { if (e && e._inc) { e._inc++; var i = t.childNodes; if (n) i[i.length++] = n; else { for (var r = t.firstChild, s = 0; r;)i[s++] = r, r = r.nextSibling; i.length = s, delete i[i.length] } } } function W(e, t) { var n = t.previousSibling, i = t.nextSibling; return n ? n.nextSibling = i : e.firstChild = i, i ? i.previousSibling = n : e.lastChild = n, t.parentNode = null, t.previousSibling = null, t.nextSibling = null, V(e.ownerDocument, e), t } function q(e) { return e && e.nodeType === U.DOCUMENT_TYPE_NODE } function G(e) { return e && e.nodeType === U.ELEMENT_NODE } function X(e) { return e && e.nodeType === U.TEXT_NODE } function K(e, t) { var n = e.childNodes || []; if (r(n, G) || q(t)) return !1; var i = r(n, q); return !(t && i && n.indexOf(i) > n.indexOf(t)) } function $(e, t) { var n = e.childNodes || []; if (r(n, (function (e) { return G(e) && e !== t }))) return !1; var i = r(n, q); return !(t && i && n.indexOf(i) > n.indexOf(t)) } function Y(e, t, n) { if (!function (e) { return e && (e.nodeType === U.DOCUMENT_NODE || e.nodeType === U.DOCUMENT_FRAGMENT_NODE || e.nodeType === U.ELEMENT_NODE) }(e)) throw new I(E, "Unexpected parent node type " + e.nodeType); if (n && n.parentNode !== e) throw new I(C, "child not in parent"); if (!function (e) { return e && (G(e) || X(e) || q(e) || e.nodeType === U.DOCUMENT_FRAGMENT_NODE || e.nodeType === U.COMMENT_NODE || e.nodeType === U.PROCESSING_INSTRUCTION_NODE) }(t) || q(t) && e.nodeType !== U.DOCUMENT_NODE) throw new I(E, "Unexpected node type " + t.nodeType + " for parent node type " + e.nodeType) } function Q(e, t, n) { var i = e.childNodes || [], s = t.childNodes || []; if (t.nodeType === U.DOCUMENT_FRAGMENT_NODE) { var a = s.filter(G); if (a.length > 1 || r(s, X)) throw new I(E, "More than one element or text in fragment"); if (1 === a.length && !K(e, n)) throw new I(E, "Element in fragment can not be inserted before doctype") } if (G(t) && !K(e, n)) throw new I(E, "Only one element can be added and only after doctype"); if (q(t)) { if (r(i, q)) throw new I(E, "Only one doctype is allowed"); var o = r(i, G); if (n && i.indexOf(o) < i.indexOf(n)) throw new I(E, "Doctype can only be inserted before an element"); if (!n && o) throw new I(E, "Doctype can not be appended since element is present") } } function J(e, t, n) { var i = e.childNodes || [], s = t.childNodes || []; if (t.nodeType === U.DOCUMENT_FRAGMENT_NODE) { var a = s.filter(G); if (a.length > 1 || r(s, X)) throw new I(E, "More than one element or text in fragment"); if (1 === a.length && !$(e, n)) throw new I(E, "Element in fragment can not be inserted before doctype") } if (G(t) && !$(e, n)) throw new I(E, "Only one element can be added and only after doctype"); if (q(t)) { if (r(i, (function (e) { return q(e) && e !== n }))) throw new I(E, "Only one doctype is allowed"); var o = r(i, G); if (n && i.indexOf(o) < i.indexOf(n)) throw new I(E, "Doctype can only be inserted before an element") } } function Z(e, t, n, i) { Y(e, t, n), e.nodeType === U.DOCUMENT_NODE && (i || Q)(e, t, n); var r = t.parentNode; if (r && r.removeChild(t), t.nodeType === S) { var s = t.firstChild; if (null == s) return t; var a = t.lastChild } else s = a = t; var o = n ? n.previousSibling : e.lastChild; s.previousSibling = o, a.nextSibling = n, o ? o.nextSibling = s : e.firstChild = s, null == n ? e.lastChild = a : n.previousSibling = a; do { s.parentNode = e } while (s !== a && (s = s.nextSibling)); return V(e.ownerDocument || e, e), t.nodeType == S && (t.firstChild = t.lastChild = null), t } function ee() { this._nsMap = {} } function te() { } function ne() { } function ie() { } function re() { } function se() { } function ae() { } function oe() { } function le() { } function ce() { } function ue() { } function de() { } function he() { } function pe(e, t) { var n = [], i = 9 == this.nodeType && this.documentElement || this, r = i.prefix, s = i.namespaceURI; if (s && null == r && null == (r = i.lookupPrefix(s))) var a = [{ namespace: s, prefix: null }]; return ge(this, n, e, t, a), n.join("") } function fe(e, t, n) { var i = e.prefix || "", r = e.namespaceURI; if (!r) return !1; if ("xml" === i && r === s.XML || r === s.XMLNS) return !1; for (var a = n.length; a--;) { var o = n[a]; if (o.prefix === i) return o.namespace !== r } return !0 } function me(e, t, n) { e.push(" ", t, '="', n.replace(/[<>&"\t\n\r]/g, B), '"') } function ge(e, t, n, i, r) { if (r || (r = []), i) { if (!(e = i(e))) return; if ("string" == typeof e) return void t.push(e) } switch (e.nodeType) { case h: var a = e.attributes, o = a.length, l = e.firstChild, c = e.tagName, u = c; if (!(n = s.isHTML(e.namespaceURI) || n) && !e.prefix && e.namespaceURI) { for (var d, y = 0; y < a.length; y++)if ("xmlns" === a.item(y).name) { d = a.item(y).value; break } if (!d) for (var w = r.length - 1; w >= 0; w--) { if ("" === (x = r[w]).prefix && x.namespace === e.namespaceURI) { d = x.namespace; break } } if (d !== e.namespaceURI) for (w = r.length - 1; w >= 0; w--) { var x; if ((x = r[w]).namespace === e.namespaceURI) { x.prefix && (u = x.prefix + ":" + c); break } } } t.push("<", u); for (var k = 0; k < o; k++) { "xmlns" == (E = a.item(k)).prefix ? r.push({ prefix: E.localName, namespace: E.value }) : "xmlns" == E.nodeName && r.push({ prefix: "", namespace: E.value }) } for (k = 0; k < o; k++) { var E, C, P; if (fe(E = a.item(k), 0, r)) me(t, (C = E.prefix || "") ? "xmlns:" + C : "xmlns", P = E.namespaceURI), r.push({ prefix: C, namespace: P }); ge(E, t, n, i, r) } if (c === u && fe(e, 0, r)) me(t, (C = e.prefix || "") ? "xmlns:" + C : "xmlns", P = e.namespaceURI), r.push({ prefix: C, namespace: P }); if (l || n && !/^(?:meta|link|img|br|hr|input)$/i.test(c)) { if (t.push(">"), n && /^script$/i.test(c)) for (; l;)l.data ? t.push(l.data) : ge(l, t, n, i, r.slice()), l = l.nextSibling; else for (; l;)ge(l, t, n, i, r.slice()), l = l.nextSibling; t.push("</", u, ">") } else t.push("/>"); return; case _: case S: for (l = e.firstChild; l;)ge(l, t, n, i, r.slice()), l = l.nextSibling; return; case p: return me(t, e.name, e.value); case f: return t.push(e.data.replace(/[<&>]/g, B)); case m: return t.push("<![CDATA[", e.data, "]]>"); case b: return t.push("\x3c!--", e.data, "--\x3e"); case T: var I = e.publicId, L = e.systemId; if (t.push("<!DOCTYPE ", e.name), I) t.push(" PUBLIC ", I), L && "." != L && t.push(" ", L), t.push(">"); else if (L && "." != L) t.push(" SYSTEM ", L, ">"); else { var O = e.internalSubset; O && t.push(" [", O, "]"), t.push(">") } return; case v: return t.push("<?", e.target, " ", e.data, "?>"); case g: return t.push("&", e.nodeName, ";"); default: t.push("??", e.nodeName) } } function ye(e, t, n) { var i; switch (t.nodeType) { case h: (i = t.cloneNode(!1)).ownerDocument = e; case S: break; case p: n = !0 }if (i || (i = t.cloneNode(!1)), i.ownerDocument = e, i.parentNode = null, n) for (var r = t.firstChild; r;)i.appendChild(ye(e, r, n)), r = r.nextSibling; return i } function ve(e, t, n) { var i = new t.constructor; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { var s = t[r]; "object" != typeof s && s != i[r] && (i[r] = s) } switch (t.childNodes && (i.childNodes = new L), i.ownerDocument = e, i.nodeType) { case h: var a = t.attributes, o = i.attributes = new N, l = a.length; o._ownerElement = i; for (var c = 0; c < l; c++)i.setAttributeNode(ve(e, a.item(c), !0)); break; case p: n = !0 }if (n) for (var u = t.firstChild; u;)i.appendChild(ve(e, u, n)), u = u.nextSibling; return i } function be(e, t, n) { e[t] = n } I.prototype = Error.prototype, c(x, I), L.prototype = { length: 0, item: function (e) { return this[e] || null }, toString: function (e, t) { for (var n = [], i = 0; i < this.length; i++)ge(this[i], n, e, t); return n.join("") }, filter: function (e) { return Array.prototype.filter.call(this, e) }, indexOf: function (e) { return Array.prototype.indexOf.call(this, e) } }, O.prototype.item = function (e) { return A(this), this[e] }, u(O, L), N.prototype = { length: 0, item: L.prototype.item, getNamedItem: function (e) { for (var t = this.length; t--;) { var n = this[t]; if (n.nodeName == e) return n } }, setNamedItem: function (e) { var t = e.ownerElement; if (t && t != this._ownerElement) throw new I(P); var n = this.getNamedItem(e.nodeName); return D(this._ownerElement, this, e, n), n }, setNamedItemNS: function (e) { var t, n = e.ownerElement; if (n && n != this._ownerElement) throw new I(P); return t = this.getNamedItemNS(e.namespaceURI, e.localName), D(this._ownerElement, this, e, t), t }, removeNamedItem: function (e) { var t = this.getNamedItem(e); return M(this._ownerElement, this, t), t }, removeNamedItemNS: function (e, t) { var n = this.getNamedItemNS(e, t); return M(this._ownerElement, this, n), n }, getNamedItemNS: function (e, t) { for (var n = this.length; n--;) { var i = this[n]; if (i.localName == t && i.namespaceURI == e) return i } return null } }, R.prototype = { hasFeature: function (e, t) { return !0 }, createDocument: function (e, t, n) { var i = new z; if (i.implementation = this, i.childNodes = new L, i.doctype = n || null, n && i.appendChild(n), t) { var r = i.createElementNS(e, t); i.appendChild(r) } return i }, createDocumentType: function (e, t, n) { var i = new ae; return i.name = e, i.nodeName = e, i.publicId = t || "", i.systemId = n || "", i } }, U.prototype = { firstChild: null, lastChild: null, previousSibling: null, nextSibling: null, attributes: null, parentNode: null, childNodes: null, ownerDocument: null, nodeValue: null, namespaceURI: null, prefix: null, localName: null, insertBefore: function (e, t) { return Z(this, e, t) }, replaceChild: function (e, t) { Z(this, e, t, J), t && this.removeChild(t) }, removeChild: function (e) { return W(this, e) }, appendChild: function (e) { return this.insertBefore(e, null) }, hasChildNodes: function () { return null != this.firstChild }, cloneNode: function (e) { return ve(this.ownerDocument || this, this, e) }, normalize: function () { for (var e = this.firstChild; e;) { var t = e.nextSibling; t && t.nodeType == f && e.nodeType == f ? (this.removeChild(t), e.appendData(t.data)) : (e.normalize(), e = t) } }, isSupported: function (e, t) { return this.ownerDocument.implementation.hasFeature(e, t) }, hasAttributes: function () { return this.attributes.length > 0 }, lookupPrefix: function (e) { for (var t = this; t;) { var n = t._nsMap; if (n) for (var i in n) if (Object.prototype.hasOwnProperty.call(n, i) && n[i] === e) return i; t = t.nodeType == p ? t.ownerDocument : t.parentNode } return null }, lookupNamespaceURI: function (e) { for (var t = this; t;) { var n = t._nsMap; if (n && Object.prototype.hasOwnProperty.call(n, e)) return n[e]; t = t.nodeType == p ? t.ownerDocument : t.parentNode } return null }, isDefaultNamespace: function (e) { return null == this.lookupPrefix(e) } }, c(d, U), c(d, U.prototype), z.prototype = { nodeName: "#document", nodeType: _, doctype: null, documentElement: null, _inc: 1, insertBefore: function (e, t) { if (e.nodeType == S) { for (var n = e.firstChild; n;) { var i = n.nextSibling; this.insertBefore(n, t), n = i } return e } return Z(this, e, t), e.ownerDocument = this, null === this.documentElement && e.nodeType === h && (this.documentElement = e), e }, removeChild: function (e) { return this.documentElement == e && (this.documentElement = null), W(this, e) }, replaceChild: function (e, t) { Z(this, e, t, J), e.ownerDocument = this, t && this.removeChild(t), G(e) && (this.documentElement = e) }, importNode: function (e, t) { return ye(this, e, t) }, getElementById: function (e) { var t = null; return F(this.documentElement, (function (n) { if (n.nodeType == h && n.getAttribute("id") == e) return t = n, !0 })), t }, getElementsByClassName: function (e) { var t = l(e); return new O(this, (function (n) { var i = []; return t.length > 0 && F(n.documentElement, (function (r) { if (r !== n && r.nodeType === h) { var s = r.getAttribute("class"); if (s) { var a = e === s; if (!a) { var o = l(s); a = t.every((c = o, function (e) { return c && -1 !== c.indexOf(e) })) } a && i.push(r) } } var c })), i })) }, createElement: function (e) { var t = new ee; return t.ownerDocument = this, t.nodeName = e, t.tagName = e, t.localName = e, t.childNodes = new L, (t.attributes = new N)._ownerElement = t, t }, createDocumentFragment: function () { var e = new ue; return e.ownerDocument = this, e.childNodes = new L, e }, createTextNode: function (e) { var t = new ie; return t.ownerDocument = this, t.appendData(e), t }, createComment: function (e) { var t = new re; return t.ownerDocument = this, t.appendData(e), t }, createCDATASection: function (e) { var t = new se; return t.ownerDocument = this, t.appendData(e), t }, createProcessingInstruction: function (e, t) { var n = new de; return n.ownerDocument = this, n.tagName = n.target = e, n.nodeValue = n.data = t, n }, createAttribute: function (e) { var t = new te; return t.ownerDocument = this, t.name = e, t.nodeName = e, t.localName = e, t.specified = !0, t }, createEntityReference: function (e) { var t = new ce; return t.ownerDocument = this, t.nodeName = e, t }, createElementNS: function (e, t) { var n = new ee, i = t.split(":"), r = n.attributes = new N; return n.childNodes = new L, n.ownerDocument = this, n.nodeName = t, n.tagName = t, n.namespaceURI = e, 2 == i.length ? (n.prefix = i[0], n.localName = i[1]) : n.localName = t, r._ownerElement = n, n }, createAttributeNS: function (e, t) { var n = new te, i = t.split(":"); return n.ownerDocument = this, n.nodeName = t, n.name = t, n.namespaceURI = e, n.specified = !0, 2 == i.length ? (n.prefix = i[0], n.localName = i[1]) : n.localName = t, n } }, u(z, U), ee.prototype = { nodeType: h, hasAttribute: function (e) { return null != this.getAttributeNode(e) }, getAttribute: function (e) { var t = this.getAttributeNode(e); return t && t.value || "" }, getAttributeNode: function (e) { return this.attributes.getNamedItem(e) }, setAttribute: function (e, t) { var n = this.ownerDocument.createAttribute(e); n.value = n.nodeValue = "" + t, this.setAttributeNode(n) }, removeAttribute: function (e) { var t = this.getAttributeNode(e); t && this.removeAttributeNode(t) }, appendChild: function (e) { return e.nodeType === S ? this.insertBefore(e, null) : function (e, t) { return t.parentNode && t.parentNode.removeChild(t), t.parentNode = e, t.previousSibling = e.lastChild, t.nextSibling = null, t.previousSibling ? t.previousSibling.nextSibling = t : e.firstChild = t, e.lastChild = t, V(e.ownerDocument, e, t), t }(this, e) }, setAttributeNode: function (e) { return this.attributes.setNamedItem(e) }, setAttributeNodeNS: function (e) { return this.attributes.setNamedItemNS(e) }, removeAttributeNode: function (e) { return this.attributes.removeNamedItem(e.nodeName) }, removeAttributeNS: function (e, t) { var n = this.getAttributeNodeNS(e, t); n && this.removeAttributeNode(n) }, hasAttributeNS: function (e, t) { return null != this.getAttributeNodeNS(e, t) }, getAttributeNS: function (e, t) { var n = this.getAttributeNodeNS(e, t); return n && n.value || "" }, setAttributeNS: function (e, t, n) { var i = this.ownerDocument.createAttributeNS(e, t); i.value = i.nodeValue = "" + n, this.setAttributeNode(i) }, getAttributeNodeNS: function (e, t) { return this.attributes.getNamedItemNS(e, t) }, getElementsByTagName: function (e) { return new O(this, (function (t) { var n = []; return F(t, (function (i) { i === t || i.nodeType != h || "*" !== e && i.tagName != e || n.push(i) })), n })) }, getElementsByTagNameNS: function (e, t) { return new O(this, (function (n) { var i = []; return F(n, (function (r) { r === n || r.nodeType !== h || "*" !== e && r.namespaceURI !== e || "*" !== t && r.localName != t || i.push(r) })), i })) } }, z.prototype.getElementsByTagName = ee.prototype.getElementsByTagName, z.prototype.getElementsByTagNameNS = ee.prototype.getElementsByTagNameNS, u(ee, U), te.prototype.nodeType = p, u(te, U), ne.prototype = { data: "", substringData: function (e, t) { return this.data.substring(e, e + t) }, appendData: function (e) { e = this.data + e, this.nodeValue = this.data = e, this.length = e.length }, insertData: function (e, t) { this.replaceData(e, 0, t) }, appendChild: function (e) { throw new Error(k[E]) }, deleteData: function (e, t) { this.replaceData(e, t, "") }, replaceData: function (e, t, n) { n = this.data.substring(0, e) + n + this.data.substring(e + t), this.nodeValue = this.data = n, this.length = n.length } }, u(ne, U), ie.prototype = { nodeName: "#text", nodeType: f, splitText: function (e) { var t = this.data, n = t.substring(e); t = t.substring(0, e), this.data = this.nodeValue = t, this.length = t.length; var i = this.ownerDocument.createTextNode(n); return this.parentNode && this.parentNode.insertBefore(i, this.nextSibling), i } }, u(ie, ne), re.prototype = { nodeName: "#comment", nodeType: b }, u(re, ne), se.prototype = { nodeName: "#cdata-section", nodeType: m }, u(se, ne), ae.prototype.nodeType = T, u(ae, U), oe.prototype.nodeType = w, u(oe, U), le.prototype.nodeType = y, u(le, U), ce.prototype.nodeType = g, u(ce, U), ue.prototype.nodeName = "#document-fragment", ue.prototype.nodeType = S, u(ue, U), de.prototype.nodeType = v, u(de, U), he.prototype.serializeToString = function (e, t, n) { return pe.call(e, t, n) }, U.prototype.toString = pe; try { if (Object.defineProperty) { function _e(e) { switch (e.nodeType) { case h: case S: var t = []; for (e = e.firstChild; e;)7 !== e.nodeType && 8 !== e.nodeType && t.push(_e(e)), e = e.nextSibling; return t.join(""); default: return e.nodeValue } } Object.defineProperty(O.prototype, "length", { get: function () { return A(this), this.$$length } }), Object.defineProperty(U.prototype, "textContent", { get: function () { return _e(this) }, set: function (e) { switch (this.nodeType) { case h: case S: for (; this.firstChild;)this.removeChild(this.firstChild); (e || String(e)) && this.appendChild(this.ownerDocument.createTextNode(e)); break; default: this.data = e, this.value = e, this.nodeValue = e } } }), be = function (e, t, n) { e["$$" + t] = n } } } catch (Te) { } t.DocumentType = ae, t.DOMException = I, t.DOMImplementation = R, t.Element = ee, t.Node = U, t.NodeList = L, t.XMLSerializer = he }, 1775: (e, t, n) => { var i = n(9145).freeze; t.XML_ENTITIES = i({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' }), t.HTML_ENTITIES = i({ lt: "<", gt: ">", amp: "&", quot: '"', apos: "'", Agrave: "\xc0", Aacute: "\xc1", Acirc: "\xc2", Atilde: "\xc3", Auml: "\xc4", Aring: "\xc5", AElig: "\xc6", Ccedil: "\xc7", Egrave: "\xc8", Eacute: "\xc9", Ecirc: "\xca", Euml: "\xcb", Igrave: "\xcc", Iacute: "\xcd", Icirc: "\xce", Iuml: "\xcf", ETH: "\xd0", Ntilde: "\xd1", Ograve: "\xd2", Oacute: "\xd3", Ocirc: "\xd4", Otilde: "\xd5", Ouml: "\xd6", Oslash: "\xd8", Ugrave: "\xd9", Uacute: "\xda", Ucirc: "\xdb", Uuml: "\xdc", Yacute: "\xdd", THORN: "\xde", szlig: "\xdf", agrave: "\xe0", aacute: "\xe1", acirc: "\xe2", atilde: "\xe3", auml: "\xe4", aring: "\xe5", aelig: "\xe6", ccedil: "\xe7", egrave: "\xe8", eacute: "\xe9", ecirc: "\xea", euml: "\xeb", igrave: "\xec", iacute: "\xed", icirc: "\xee", iuml: "\xef", eth: "\xf0", ntilde: "\xf1", ograve: "\xf2", oacute: "\xf3", ocirc: "\xf4", otilde: "\xf5", ouml: "\xf6", oslash: "\xf8", ugrave: "\xf9", uacute: "\xfa", ucirc: "\xfb", uuml: "\xfc", yacute: "\xfd", thorn: "\xfe", yuml: "\xff", nbsp: "\xa0", iexcl: "\xa1", cent: "\xa2", pound: "\xa3", curren: "\xa4", yen: "\xa5", brvbar: "\xa6", sect: "\xa7", uml: "\xa8", copy: "\xa9", ordf: "\xaa", laquo: "\xab", not: "\xac", shy: "\xad\xad", reg: "\xae", macr: "\xaf", deg: "\xb0", plusmn: "\xb1", sup2: "\xb2", sup3: "\xb3", acute: "\xb4", micro: "\xb5", para: "\xb6", middot: "\xb7", cedil: "\xb8", sup1: "\xb9", ordm: "\xba", raquo: "\xbb", frac14: "\xbc", frac12: "\xbd", frac34: "\xbe", iquest: "\xbf", times: "\xd7", divide: "\xf7", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220b", prod: "\u220f", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221a", prop: "\u221d", infin: "\u221e", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222a", int: "\u222b", there4: "\u2234", sim: "\u223c", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22a5", sdot: "\u22c5", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039a", Lambda: "\u039b", Mu: "\u039c", Nu: "\u039d", Xi: "\u039e", Omicron: "\u039f", Pi: "\u03a0", Rho: "\u03a1", Sigma: "\u03a3", Tau: "\u03a4", Upsilon: "\u03a5", Phi: "\u03a6", Chi: "\u03a7", Psi: "\u03a8", Omega: "\u03a9", alpha: "\u03b1", beta: "\u03b2", gamma: "\u03b3", delta: "\u03b4", epsilon: "\u03b5", zeta: "\u03b6", eta: "\u03b7", theta: "\u03b8", iota: "\u03b9", kappa: "\u03ba", lambda: "\u03bb", mu: "\u03bc", nu: "\u03bd", xi: "\u03be", omicron: "\u03bf", pi: "\u03c0", rho: "\u03c1", sigmaf: "\u03c2", sigma: "\u03c3", tau: "\u03c4", upsilon: "\u03c5", phi: "\u03c6", chi: "\u03c7", psi: "\u03c8", omega: "\u03c9", thetasym: "\u03d1", upsih: "\u03d2", piv: "\u03d6", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02c6", tilde: "\u02dc", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200c", zwj: "\u200d", lrm: "\u200e", rlm: "\u200f", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201a", ldquo: "\u201c", rdquo: "\u201d", bdquo: "\u201e", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203a", oline: "\u203e", euro: "\u20ac", trade: "\u2122", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21b5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230a", rfloor: "\u230b", loz: "\u25ca", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" }), t.entityMap = t.HTML_ENTITIES }, 7542: (e, t, n) => { var i = n(9668); i.DOMImplementation, i.XMLSerializer, t.DOMParser = n(4708).DOMParser }, 9660: (e, t, n) => { var i = n(9145).NAMESPACE, r = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, s = new RegExp("[\\-\\.0-9" + r.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), a = new RegExp("^" + r.source + s.source + "*(?::" + r.source + s.source + "*)?$"), o = 0, l = 1, c = 2, u = 3, d = 4, h = 5, p = 6, f = 7; function m(e, t) { this.message = e, this.locator = t, Error.captureStackTrace && Error.captureStackTrace(this, m) } function g() { } function y(e, t) { return t.lineNumber = e.lineNumber, t.columnNumber = e.columnNumber, t } function v(e, t, n, r, s, a) { function m(e, t, i) { n.attributeNames.hasOwnProperty(e) && a.fatalError("Attribute " + e + " redefined"), n.addValue(e, t.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, s), i) } for (var g, y = ++t, v = o; ;) { var b = e.charAt(y); switch (b) { case "=": if (v === l) g = e.slice(t, y), v = u; else { if (v !== c) throw new Error("attribute equal must after attrName"); v = u } break; case "'": case '"': if (v === u || v === l) { if (v === l && (a.warning('attribute value must after "="'), g = e.slice(t, y)), t = y + 1, !((y = e.indexOf(b, t)) > 0)) throw new Error("attribute value no end '" + b + "' match"); m(g, _ = e.slice(t, y), t - 1), v = h } else { if (v != d) throw new Error('attribute value must after "="'); m(g, _ = e.slice(t, y), t), a.warning('attribute "' + g + '" missed start quot(' + b + ")!!"), t = y + 1, v = h } break; case "/": switch (v) { case o: n.setTagName(e.slice(t, y)); case h: case p: case f: v = f, n.closed = !0; case d: case l: break; case c: n.closed = !0; break; default: throw new Error("attribute invalid close char('/')") }break; case "": return a.error("unexpected end of input"), v == o && n.setTagName(e.slice(t, y)), y; case ">": switch (v) { case o: n.setTagName(e.slice(t, y)); case h: case p: case f: break; case d: case l: "/" === (_ = e.slice(t, y)).slice(-1) && (n.closed = !0, _ = _.slice(0, -1)); case c: v === c && (_ = g), v == d ? (a.warning('attribute "' + _ + '" missed quot(")!'), m(g, _, t)) : (i.isHTML(r[""]) && _.match(/^(?:disabled|checked|selected)$/i) || a.warning('attribute "' + _ + '" missed value!! "' + _ + '" instead!!'), m(_, _, t)); break; case u: throw new Error("attribute value missed!!") }return y; case "\x80": b = " "; default: if (b <= " ") switch (v) { case o: n.setTagName(e.slice(t, y)), v = p; break; case l: g = e.slice(t, y), v = c; break; case d: var _ = e.slice(t, y); a.warning('attribute "' + _ + '" missed quot(")!!'), m(g, _, t); case h: v = p } else switch (v) { case c: n.tagName; i.isHTML(r[""]) && g.match(/^(?:disabled|checked|selected)$/i) || a.warning('attribute "' + g + '" missed value!! "' + g + '" instead2!!'), m(g, g, t), t = y, v = l; break; case h: a.warning('attribute space is required"' + g + '"!!'); case p: v = l, t = y; break; case u: v = d, t = y; break; case f: throw new Error("elements closed character '/' and '>' must be connected to") } }y++ } } function b(e, t, n) { for (var r = e.tagName, s = null, a = e.length; a--;) { var o = e[a], l = o.qName, c = o.value; if ((p = l.indexOf(":")) > 0) var u = o.prefix = l.slice(0, p), d = l.slice(p + 1), h = "xmlns" === u && d; else d = l, u = null, h = "xmlns" === l && ""; o.localName = d, !1 !== h && (null == s && (s = {}, S(n, n = {})), n[h] = s[h] = c, o.uri = i.XMLNS, t.startPrefixMapping(h, c)) } for (a = e.length; a--;) { (u = (o = e[a]).prefix) && ("xml" === u && (o.uri = i.XML), "xmlns" !== u && (o.uri = n[u || ""])) } var p; (p = r.indexOf(":")) > 0 ? (u = e.prefix = r.slice(0, p), d = e.localName = r.slice(p + 1)) : (u = null, d = e.localName = r); var f = e.uri = n[u || ""]; if (t.startElement(f, d, r, e), !e.closed) return e.currentNSMap = n, e.localNSMap = s, !0; if (t.endElement(f, d, r), s) for (u in s) Object.prototype.hasOwnProperty.call(s, u) && t.endPrefixMapping(u) } function _(e, t, n, i, r) { if (/^(?:script|textarea)$/i.test(n)) { var s = e.indexOf("</" + n + ">", t), a = e.substring(t + 1, s); if (/[&<]/.test(a)) return /^script$/i.test(n) ? (r.characters(a, 0, a.length), s) : (a = a.replace(/&#?\w+;/g, i), r.characters(a, 0, a.length), s) } return t + 1 } function T(e, t, n, i) { var r = i[n]; return null == r && ((r = e.lastIndexOf("</" + n + ">")) < t && (r = e.lastIndexOf("</" + n)), i[n] = r), r < t } function S(e, t) { for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]) } function w(e, t, n, i) { if ("-" === e.charAt(t + 2)) return "-" === e.charAt(t + 3) ? (r = e.indexOf("--\x3e", t + 4)) > t ? (n.comment(e, t + 4, r - t - 4), r + 3) : (i.error("Unclosed comment"), -1) : -1; if ("CDATA[" == e.substr(t + 3, 6)) { var r = e.indexOf("]]>", t + 9); return n.startCDATA(), n.characters(e, t + 9, r - t - 9), n.endCDATA(), r + 3 } var s = function (e, t) { var n, i = [], r = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g; r.lastIndex = t, r.exec(e); for (; n = r.exec(e);)if (i.push(n), n[1]) return i }(e, t), a = s.length; if (a > 1 && /!doctype/i.test(s[0][0])) { var o = s[1][0], l = !1, c = !1; a > 3 && (/^public$/i.test(s[2][0]) ? (l = s[3][0], c = a > 4 && s[4][0]) : /^system$/i.test(s[2][0]) && (c = s[3][0])); var u = s[a - 1]; return n.startDTD(o, l, c), n.endDTD(), u.index + u[0].length } return -1 } function x(e, t, n) { var i = e.indexOf("?>", t); if (i) { var r = e.substring(t, i).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/); if (r) { r[0].length; return n.processingInstruction(r[1], r[2]), i + 2 } return -1 } return -1 } function k() { this.attributeNames = {} } m.prototype = new Error, m.prototype.name = m.name, g.prototype = { parse: function (e, t, n) { var r = this.domBuilder; r.startDocument(), S(t, t = {}), function (e, t, n, r, s) { function a(e) { if (e > 65535) { var t = 55296 + ((e -= 65536) >> 10), n = 56320 + (1023 & e); return String.fromCharCode(t, n) } return String.fromCharCode(e) } function o(e) { var t = e.slice(1, -1); return Object.hasOwnProperty.call(n, t) ? n[t] : "#" === t.charAt(0) ? a(parseInt(t.substr(1).replace("x", "0x"))) : (s.error("entity not found:" + e), e) } function l(t) { if (t > S) { var n = e.substring(S, t).replace(/&#?\w+;/g, o); p && c(S), r.characters(n, 0, t - S), S = t } } function c(t, n) { for (; t >= d && (n = h.exec(e));)u = n.index, d = u + n[0].length, p.lineNumber++; p.columnNumber = t - u + 1 } var u = 0, d = 0, h = /.*(?:\r\n?|\n)|.*$/g, p = r.locator, f = [{ currentNSMap: t }], g = {}, S = 0; for (; ;) { try { var E = e.indexOf("<", S); if (E < 0) { if (!e.substr(S).match(/^\s*$/)) { var C = r.doc, P = C.createTextNode(e.substr(S)); C.appendChild(P), r.currentElement = P } return } switch (E > S && l(E), e.charAt(E + 1)) { case "/": var I = e.indexOf(">", E + 3), L = e.substring(E + 2, I).replace(/[ \t\n\r]+$/g, ""), O = f.pop(); I < 0 ? (L = e.substring(E + 2).replace(/[\s<].*/, ""), s.error("end tag name: " + L + " is not complete:" + O.tagName), I = E + 1 + L.length) : L.match(/\s</) && (L = L.replace(/[\s<].*/, ""), s.error("end tag name: " + L + " maybe not complete"), I = E + 1 + L.length); var A = O.localNSMap, N = O.tagName == L; if (N || O.tagName && O.tagName.toLowerCase() == L.toLowerCase()) { if (r.endElement(O.uri, O.localName, L), A) for (var j in A) Object.prototype.hasOwnProperty.call(A, j) && r.endPrefixMapping(j); N || s.fatalError("end tag name: " + L + " is not match the current start tagName:" + O.tagName) } else f.push(O); I++; break; case "?": p && c(E), I = x(e, E, r); break; case "!": p && c(E), I = w(e, E, r, s); break; default: p && c(E); var D = new k, M = f[f.length - 1].currentNSMap, R = (I = v(e, E, D, M, o, s), D.length); if (!D.closed && T(e, I, D.tagName, g) && (D.closed = !0, n.nbsp || s.warning("unclosed xml attribute")), p && R) { for (var U = y(p, {}), B = 0; B < R; B++) { var F = D[B]; c(F.offset), F.locator = y(p, {}) } r.locator = U, b(D, r, M) && f.push(D), r.locator = p } else b(D, r, M) && f.push(D); i.isHTML(D.uri) && !D.closed ? I = _(e, I, D.tagName, o, r) : I++ } } catch (z) { if (z instanceof m) throw z; s.error("element parse error: " + z), I = -1 } I > S ? S = I : l(Math.max(E, S) + 1) } }(e, t, n, r, this.errorHandler), r.endDocument() } }, k.prototype = { setTagName: function (e) { if (!a.test(e)) throw new Error("invalid tagName:" + e); this.tagName = e }, addValue: function (e, t, n) { if (!a.test(e)) throw new Error("invalid attribute:" + e); this.attributeNames[e] = this.length, this[this.length++] = { qName: e, value: t, offset: n } }, length: 0, getLocalName: function (e) { return this[e].localName }, getLocator: function (e) { return this[e].locator }, getQName: function (e) { return this[e].qName }, getURI: function (e) { return this[e].uri }, getValue: function (e) { return this[e].value } }, t.XMLReader = g, t.ParseError = m }, 7945: function (e) { e.exports = function (e) { function t(i) { if (n[i]) return n[i].exports; var r = n[i] = { exports: {}, id: i, loaded: !1 }; return e[i].call(r.exports, r, r.exports, t), r.loaded = !0, r.exports } var n = {}; return t.m = e, t.c = n, t.p = "dist/", t(0) }([function (e, t, n) { "use strict"; function i(e) { return e && e.__esModule ? e : { default: e } } var r = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, s = (i(n(1)), n(6)), a = i(s), o = i(n(7)), l = i(n(8)), c = i(n(9)), u = i(n(10)), d = i(n(11)), h = i(n(14)), p = [], f = !1, m = { offset: 120, delay: 0, easing: "ease", duration: 400, disable: !1, once: !1, startEvent: "DOMContentLoaded", throttleDelay: 99, debounceDelay: 50, disableMutationObserver: !1 }, g = function () { if (arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && (f = !0), f) return p = (0, d.default)(p, m), (0, u.default)(p, m.once), p }, y = function () { p = (0, h.default)(), g() }, v = function () { p.forEach((function (e, t) { e.node.removeAttribute("data-aos"), e.node.removeAttribute("data-aos-easing"), e.node.removeAttribute("data-aos-duration"), e.node.removeAttribute("data-aos-delay") })) }, b = function (e) { return !0 === e || "mobile" === e && c.default.mobile() || "phone" === e && c.default.phone() || "tablet" === e && c.default.tablet() || "function" == typeof e && !0 === e() }, _ = function (e) { m = r(m, e), p = (0, h.default)(); var t = document.all && !window.atob; return b(m.disable) || t ? v() : (m.disableMutationObserver || l.default.isSupported() || (console.info('\n      aos: MutationObserver is not supported on this browser,\n      code mutations observing has been disabled.\n      You may have to call "refreshHard()" by yourself.\n    '), m.disableMutationObserver = !0), document.querySelector("body").setAttribute("data-aos-easing", m.easing), document.querySelector("body").setAttribute("data-aos-duration", m.duration), document.querySelector("body").setAttribute("data-aos-delay", m.delay), "DOMContentLoaded" === m.startEvent && ["complete", "interactive"].indexOf(document.readyState) > -1 ? g(!0) : "load" === m.startEvent ? window.addEventListener(m.startEvent, (function () { g(!0) })) : document.addEventListener(m.startEvent, (function () { g(!0) })), window.addEventListener("resize", (0, o.default)(g, m.debounceDelay, !0)), window.addEventListener("orientationchange", (0, o.default)(g, m.debounceDelay, !0)), window.addEventListener("scroll", (0, a.default)((function () { (0, u.default)(p, m.once) }), m.throttleDelay)), m.disableMutationObserver || l.default.ready("[data-aos]", y), p) }; e.exports = { init: _, refresh: g, refreshHard: y } }, function (e, t) { }, , , , , function (e, t) { (function (t) { "use strict"; function n(e, t, n) { function i(t) { var n = m, i = g; return m = g = void 0, x = t, v = e.apply(i, n) } function s(e) { return x = e, b = setTimeout(u, t), k ? i(e) : v } function a(e) { var n = t - (e - _); return E ? S(n, y - (e - x)) : n } function l(e) { var n = e - _; return void 0 === _ || n >= t || n < 0 || E && e - x >= y } function u() { var e = w(); return l(e) ? d(e) : void (b = setTimeout(u, a(e))) } function d(e) { return b = void 0, C && m ? i(e) : (m = g = void 0, v) } function h() { void 0 !== b && clearTimeout(b), x = 0, m = _ = g = b = void 0 } function p() { return void 0 === b ? v : d(w()) } function f() { var e = w(), n = l(e); if (m = arguments, g = this, _ = e, n) { if (void 0 === b) return s(_); if (E) return b = setTimeout(u, t), i(_) } return void 0 === b && (b = setTimeout(u, t)), v } var m, g, y, v, b, _, x = 0, k = !1, E = !1, C = !0; if ("function" != typeof e) throw new TypeError(c); return t = o(t) || 0, r(n) && (k = !!n.leading, y = (E = "maxWait" in n) ? T(o(n.maxWait) || 0, t) : y, C = "trailing" in n ? !!n.trailing : C), f.cancel = h, f.flush = p, f } function i(e, t, i) { var s = !0, a = !0; if ("function" != typeof e) throw new TypeError(c); return r(i) && (s = "leading" in i ? !!i.leading : s, a = "trailing" in i ? !!i.trailing : a), n(e, t, { leading: s, maxWait: t, trailing: a }) } function r(e) { var t = "undefined" == typeof e ? "undefined" : l(e); return !!e && ("object" == t || "function" == t) } function s(e) { return !!e && "object" == ("undefined" == typeof e ? "undefined" : l(e)) } function a(e) { return "symbol" == ("undefined" == typeof e ? "undefined" : l(e)) || s(e) && _.call(e) == d } function o(e) { if ("number" == typeof e) return e; if (a(e)) return u; if (r(e)) { var t = "function" == typeof e.valueOf ? e.valueOf() : e; e = r(t) ? t + "" : t } if ("string" != typeof e) return 0 === e ? e : +e; e = e.replace(h, ""); var n = f.test(e); return n || m.test(e) ? g(e.slice(2), n ? 2 : 8) : p.test(e) ? u : +e } var l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, c = "Expected a function", u = NaN, d = "[object Symbol]", h = /^\s+|\s+$/g, p = /^[-+]0x[0-9a-f]+$/i, f = /^0b[01]+$/i, m = /^0o[0-7]+$/i, g = parseInt, y = "object" == ("undefined" == typeof t ? "undefined" : l(t)) && t && t.Object === Object && t, v = "object" == ("undefined" == typeof self ? "undefined" : l(self)) && self && self.Object === Object && self, b = y || v || Function("return this")(), _ = Object.prototype.toString, T = Math.max, S = Math.min, w = function () { return b.Date.now() }; e.exports = i }).call(t, function () { return this }()) }, function (e, t) { (function (t) { "use strict"; function n(e, t, n) { function r(t) { var n = m, i = g; return m = g = void 0, x = t, v = e.apply(i, n) } function s(e) { return x = e, b = setTimeout(u, t), k ? r(e) : v } function o(e) { var n = t - (e - w); return E ? T(n, y - (e - x)) : n } function c(e) { var n = e - w; return void 0 === w || n >= t || n < 0 || E && e - x >= y } function u() { var e = S(); return c(e) ? d(e) : void (b = setTimeout(u, o(e))) } function d(e) { return b = void 0, C && m ? r(e) : (m = g = void 0, v) } function h() { void 0 !== b && clearTimeout(b), x = 0, m = w = g = b = void 0 } function p() { return void 0 === b ? v : d(S()) } function f() { var e = S(), n = c(e); if (m = arguments, g = this, w = e, n) { if (void 0 === b) return s(w); if (E) return b = setTimeout(u, t), r(w) } return void 0 === b && (b = setTimeout(u, t)), v } var m, g, y, v, b, w, x = 0, k = !1, E = !1, C = !0; if ("function" != typeof e) throw new TypeError(l); return t = a(t) || 0, i(n) && (k = !!n.leading, y = (E = "maxWait" in n) ? _(a(n.maxWait) || 0, t) : y, C = "trailing" in n ? !!n.trailing : C), f.cancel = h, f.flush = p, f } function i(e) { var t = "undefined" == typeof e ? "undefined" : o(e); return !!e && ("object" == t || "function" == t) } function r(e) { return !!e && "object" == ("undefined" == typeof e ? "undefined" : o(e)) } function s(e) { return "symbol" == ("undefined" == typeof e ? "undefined" : o(e)) || r(e) && b.call(e) == u } function a(e) { if ("number" == typeof e) return e; if (s(e)) return c; if (i(e)) { var t = "function" == typeof e.valueOf ? e.valueOf() : e; e = i(t) ? t + "" : t } if ("string" != typeof e) return 0 === e ? e : +e; e = e.replace(d, ""); var n = p.test(e); return n || f.test(e) ? m(e.slice(2), n ? 2 : 8) : h.test(e) ? c : +e } var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, l = "Expected a function", c = NaN, u = "[object Symbol]", d = /^\s+|\s+$/g, h = /^[-+]0x[0-9a-f]+$/i, p = /^0b[01]+$/i, f = /^0o[0-7]+$/i, m = parseInt, g = "object" == ("undefined" == typeof t ? "undefined" : o(t)) && t && t.Object === Object && t, y = "object" == ("undefined" == typeof self ? "undefined" : o(self)) && self && self.Object === Object && self, v = g || y || Function("return this")(), b = Object.prototype.toString, _ = Math.max, T = Math.min, S = function () { return v.Date.now() }; e.exports = n }).call(t, function () { return this }()) }, function (e, t) { "use strict"; function n(e) { var t = void 0, i = void 0; for (t = 0; t < e.length; t += 1) { if ((i = e[t]).dataset && i.dataset.aos) return !0; if (i.children && n(i.children)) return !0 } return !1 } function i() { return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver } function r() { return !!i() } function s(e, t) { var n = window.document, r = new (i())(a); o = t, r.observe(n.documentElement, { childList: !0, subtree: !0, removedNodes: !0 }) } function a(e) { e && e.forEach((function (e) { var t = Array.prototype.slice.call(e.addedNodes), i = Array.prototype.slice.call(e.removedNodes); if (n(t.concat(i))) return o() })) } Object.defineProperty(t, "__esModule", { value: !0 }); var o = function () { }; t.default = { isSupported: r, ready: s } }, function (e, t) { "use strict"; function n(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function i() { return navigator.userAgent || navigator.vendor || window.opera || "" } Object.defineProperty(t, "__esModule", { value: !0 }); var r = function () { function e(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } return function (t, n, i) { return n && e(t.prototype, n), i && e(t, i), t } }(), s = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i, a = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, o = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i, l = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, c = function () { function e() { n(this, e) } return r(e, [{ key: "phone", value: function () { var e = i(); return !(!s.test(e) && !a.test(e.substr(0, 4))) } }, { key: "mobile", value: function () { var e = i(); return !(!o.test(e) && !l.test(e.substr(0, 4))) } }, { key: "tablet", value: function () { return this.mobile() && !this.phone() } }]), e }(); t.default = new c }, function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var n = function (e, t, n) { var i = e.node.getAttribute("data-aos-once"); t > e.position ? e.node.classList.add("aos-animate") : "undefined" != typeof i && ("false" === i || !n && "true" !== i) && e.node.classList.remove("aos-animate") }, i = function (e, t) { var i = window.pageYOffset, r = window.innerHeight; e.forEach((function (e, s) { n(e, r + i, t) })) }; t.default = i }, function (e, t, n) { "use strict"; function i(e) { return e && e.__esModule ? e : { default: e } } Object.defineProperty(t, "__esModule", { value: !0 }); var r = i(n(12)), s = function (e, t) { return e.forEach((function (e, n) { e.node.classList.add("aos-init"), e.position = (0, r.default)(e.node, t.offset) })), e }; t.default = s }, function (e, t, n) { "use strict"; function i(e) { return e && e.__esModule ? e : { default: e } } Object.defineProperty(t, "__esModule", { value: !0 }); var r = i(n(13)), s = function (e, t) { var n = 0, i = 0, s = window.innerHeight, a = { offset: e.getAttribute("data-aos-offset"), anchor: e.getAttribute("data-aos-anchor"), anchorPlacement: e.getAttribute("data-aos-anchor-placement") }; switch (a.offset && !isNaN(a.offset) && (i = parseInt(a.offset)), a.anchor && document.querySelectorAll(a.anchor) && (e = document.querySelectorAll(a.anchor)[0]), n = (0, r.default)(e).top, a.anchorPlacement) { case "top-bottom": break; case "center-bottom": n += e.offsetHeight / 2; break; case "bottom-bottom": n += e.offsetHeight; break; case "top-center": n += s / 2; break; case "bottom-center": n += s / 2 + e.offsetHeight; break; case "center-center": n += s / 2 + e.offsetHeight / 2; break; case "top-top": n += s; break; case "bottom-top": n += e.offsetHeight + s; break; case "center-top": n += e.offsetHeight / 2 + s }return a.anchorPlacement || a.offset || isNaN(t) || (i = t), n + i }; t.default = s }, function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var n = function (e) { for (var t = 0, n = 0; e && !isNaN(e.offsetLeft) && !isNaN(e.offsetTop);)t += e.offsetLeft - ("BODY" != e.tagName ? e.scrollLeft : 0), n += e.offsetTop - ("BODY" != e.tagName ? e.scrollTop : 0), e = e.offsetParent; return { top: n, left: t } }; t.default = n }, function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); var n = function (e) { return e = e || document.querySelectorAll("[data-aos]"), Array.prototype.map.call(e, (function (e) { return { node: e } })) }; t.default = n }]) }, 9948: e => { "use strict"; var t = function (e) { return function (e) { return !!e && "object" === typeof e }(e) && !function (e) { var t = Object.prototype.toString.call(e); return "[object RegExp]" === t || "[object Date]" === t || function (e) { return e.$$typeof === n }(e) }(e) }; var n = "function" === typeof Symbol && Symbol.for ? Symbol.for("react.element") : 60103; function i(e, t) { return !1 !== t.clone && t.isMergeableObject(e) ? l((n = e, Array.isArray(n) ? [] : {}), e, t) : e; var n } function r(e, t, n) { return e.concat(t).map((function (e) { return i(e, n) })) } function s(e) { return Object.keys(e).concat(function (e) { return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e).filter((function (t) { return Object.propertyIsEnumerable.call(e, t) })) : [] }(e)) } function a(e, t) { try { return t in e } catch (n) { return !1 } } function o(e, t, n) { var r = {}; return n.isMergeableObject(e) && s(e).forEach((function (t) { r[t] = i(e[t], n) })), s(t).forEach((function (s) { (function (e, t) { return a(e, t) && !(Object.hasOwnProperty.call(e, t) && Object.propertyIsEnumerable.call(e, t)) })(e, s) || (a(e, s) && n.isMergeableObject(t[s]) ? r[s] = function (e, t) { if (!t.customMerge) return l; var n = t.customMerge(e); return "function" === typeof n ? n : l }(s, n)(e[s], t[s], n) : r[s] = i(t[s], n)) })), r } function l(e, n, s) { (s = s || {}).arrayMerge = s.arrayMerge || r, s.isMergeableObject = s.isMergeableObject || t, s.cloneUnlessOtherwiseSpecified = i; var a = Array.isArray(n); return a === Array.isArray(e) ? a ? s.arrayMerge(e, n, s) : o(e, n, s) : i(n, s) } l.all = function (e, t) { if (!Array.isArray(e)) throw new Error("first argument should be an array"); return e.reduce((function (e, n) { return l(e, n, t) }), {}) }; var c = l; e.exports = c }, 7203: (e, t, n) => { var i, r = "undefined" !== typeof n.g ? n.g : "undefined" !== typeof window ? window : {}, s = n(5893); "undefined" !== typeof document ? i = document : (i = r["__GLOBAL_DOCUMENT_CACHE@4"]) || (i = r["__GLOBAL_DOCUMENT_CACHE@4"] = s), e.exports = i }, 9851: (e, t, n) => { var i; i = "undefined" !== typeof window ? window : "undefined" !== typeof n.g ? n.g : "undefined" !== typeof self ? self : {}, e.exports = i }, 8112: e => { e.exports = function (e) { if (!e) return !1; var n = t.call(e); return "[object Function]" === n || "function" === typeof e && "[object RegExp]" !== n || "undefined" !== typeof window && (e === window.setTimeout || e === window.alert || e === window.confirm || e === window.prompt) }; var t = Object.prototype.toString }, 7943: (e, t) => { function n(e) { if (e && "object" === typeof e) { var t = e.which || e.keyCode || e.charCode; t && (e = t) } if ("number" === typeof e) return a[e]; var n, s = String(e); return (n = i[s.toLowerCase()]) ? n : (n = r[s.toLowerCase()]) || (1 === s.length ? s.charCodeAt(0) : void 0) } n.isEventKey = function (e, t) { if (e && "object" === typeof e) { var n = e.which || e.keyCode || e.charCode; if (null === n || void 0 === n) return !1; if ("string" === typeof t) { var s; if (s = i[t.toLowerCase()]) return s === n; if (s = r[t.toLowerCase()]) return s === n } else if ("number" === typeof t) return t === n; return !1 } }; var i = (t = e.exports = n).code = t.codes = { backspace: 8, tab: 9, enter: 13, shift: 16, ctrl: 17, alt: 18, "pause/break": 19, "caps lock": 20, esc: 27, space: 32, "page up": 33, "page down": 34, end: 35, home: 36, left: 37, up: 38, right: 39, down: 40, insert: 45, delete: 46, command: 91, "left command": 91, "right command": 93, "numpad *": 106, "numpad +": 107, "numpad -": 109, "numpad .": 110, "numpad /": 111, "num lock": 144, "scroll lock": 145, "my computer": 182, "my calculator": 183, ";": 186, "=": 187, ",": 188, "-": 189, ".": 190, "/": 191, "`": 192, "[": 219, "\\": 220, "]": 221, "'": 222 }, r = t.aliases = { windows: 91, "\u21e7": 16, "\u2325": 18, "\u2303": 17, "\u2318": 91, ctl: 17, control: 17, option: 18, pause: 19, break: 19, caps: 20, return: 13, escape: 27, spc: 32, spacebar: 32, pgup: 33, pgdn: 34, ins: 45, del: 46, cmd: 91 }; for (s = 97; s < 123; s++)i[String.fromCharCode(s)] = s - 32; for (var s = 48; s < 58; s++)i[s - 48] = s; for (s = 1; s < 13; s++)i["f" + s] = s + 111; for (s = 0; s < 10; s++)i["numpad " + s] = s + 96; var a = t.names = t.title = {}; for (s in i) a[i[s]] = s; for (var o in r) i[o] = r[o] }, 5102: e => { function t(e, t) { e.onload = function () { this.onerror = this.onload = null, t(null, e) }, e.onerror = function () { this.onerror = this.onload = null, t(new Error("Failed to load " + this.src), e) } } function n(e, t) { e.onreadystatechange = function () { "complete" != this.readyState && "loaded" != this.readyState || (this.onreadystatechange = null, t(null, e)) } } e.exports = function (e, i, r) { var s = document.head || document.getElementsByTagName("head")[0], a = document.createElement("script"); "function" === typeof i && (r = i, i = {}), i = i || {}, r = r || function () { }, a.type = i.type || "text/javascript", a.charset = i.charset || "utf8", a.async = !("async" in i) || !!i.async, a.src = e, i.attrs && function (e, t) { for (var n in t) e.setAttribute(n, t[n]) }(a, i.attrs), i.text && (a.text = "" + i.text), ("onload" in a ? t : n)(a, r), a.onload || t(a, r), s.appendChild(a) } }, 5781: (e, t, n) => { "use strict"; n.r(t), n.d(t, { default: () => s }); var i = Number.isNaN || function (e) { return "number" === typeof e && e !== e }; function r(e, t) { if (e.length !== t.length) return !1; for (var n = 0; n < e.length; n++)if (r = e[n], s = t[n], !(r === s || i(r) && i(s))) return !1; var r, s; return !0 } const s = function (e, t) { var n; void 0 === t && (t = r); var i, s = [], a = !1; return function () { for (var r = [], o = 0; o < arguments.length; o++)r[o] = arguments[o]; return a && n === this && t(r, s) || (i = e.apply(this, r), a = !0, n = this, s = r), i } } }, 8857: (e, t, n) => { var i = n(7522).getUint64; e.exports = function (e) { var t = new DataView(e.buffer, e.byteOffset, e.byteLength), n = { version: e[0], flags: new Uint8Array(e.subarray(1, 4)), references: [], referenceId: t.getUint32(4), timescale: t.getUint32(8) }, r = 12; 0 === n.version ? (n.earliestPresentationTime = t.getUint32(r), n.firstOffset = t.getUint32(r + 4), r += 8) : (n.earliestPresentationTime = i(e.subarray(r)), n.firstOffset = i(e.subarray(r + 8)), r += 16), r += 2; var s = t.getUint16(r); for (r += 2; s > 0; r += 12, s--)n.references.push({ referenceType: (128 & e[r]) >>> 7, referencedSize: 2147483647 & t.getUint32(r), subsegmentDuration: t.getUint32(r + 4), startsWithSap: !!(128 & e[r + 8]), sapType: (112 & e[r + 8]) >>> 4, sapDeltaTime: 268435455 & t.getUint32(r + 8) }); return n } }, 3474: e => { var t, n, i, r, s, a, o, l = 9e4; t = function (e) { return e * l }, n = function (e, t) { return e * t }, i = function (e) { return e / l }, r = function (e, t) { return e / t }, s = function (e, n) { return t(r(e, n)) }, a = function (e, t) { return n(i(e), t) }, o = function (e, t, n) { return i(n ? e : e - t) }, e.exports = { ONE_SECOND_IN_TS: l, secondsToVideoTs: t, secondsToAudioTs: n, videoTsToSeconds: i, audioTsToSeconds: r, audioTsToVideoTs: s, videoTsToAudioTs: a, metadataTsToSeconds: o } }, 7522: e => { var t = Math.pow(2, 32); e.exports = { getUint64: function (e) { var n, i = new DataView(e.buffer, e.byteOffset, e.byteLength); return i.getBigUint64 ? (n = i.getBigUint64(0)) < Number.MAX_SAFE_INTEGER ? Number(n) : n : i.getUint32(0) * t + i.getUint32(4) }, MAX_UINT32: t } }, 888: (e, t, n) => { "use strict"; var i = n(9047); function r() { } function s() { } s.resetWarningCache = r, e.exports = function () { function e(e, t, n, r, s, a) { if (a !== i) { var o = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw o.name = "Invariant Violation", o } } function t() { return e } e.isRequired = e; var n = { array: e, bigint: e, bool: e, func: e, number: e, object: e, string: e, symbol: e, any: e, arrayOf: t, element: e, elementType: e, instanceOf: t, node: e, objectOf: t, oneOf: t, oneOfType: t, shape: t, exact: t, checkPropTypes: s, resetWarningCache: r }; return n.PropTypes = n, n } }, 2007: (e, t, n) => { e.exports = n(888)() }, 9047: e => { "use strict"; e.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED" }, 4463: (e, t, n) => { "use strict"; var i = n(2791), r = n(5296); function s(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var a = new Set, o = {}; function l(e, t) { c(e, t), c(e + "Capture", t) } function c(e, t) { for (o[e] = t, e = 0; e < t.length; e++)a.add(t[e]) } var u = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), d = Object.prototype.hasOwnProperty, h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, p = {}, f = {}; function m(e, t, n, i, r, s, a) { this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = i, this.attributeNamespace = r, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = s, this.removeEmptyString = a } var g = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function (e) { g[e] = new m(e, 0, !1, e, null, !1, !1) })), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach((function (e) { var t = e[0]; g[t] = new m(t, 1, !1, e[1], null, !1, !1) })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function (e) { g[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1) })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function (e) { g[e] = new m(e, 2, !1, e, null, !1, !1) })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function (e) { g[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1) })), ["checked", "multiple", "muted", "selected"].forEach((function (e) { g[e] = new m(e, 3, !0, e, null, !1, !1) })), ["capture", "download"].forEach((function (e) { g[e] = new m(e, 4, !1, e, null, !1, !1) })), ["cols", "rows", "size", "span"].forEach((function (e) { g[e] = new m(e, 6, !1, e, null, !1, !1) })), ["rowSpan", "start"].forEach((function (e) { g[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1) })); var y = /[\-:]([a-z])/g; function v(e) { return e[1].toUpperCase() } function b(e, t, n, i) { var r = g.hasOwnProperty(t) ? g[t] : null; (null !== r ? 0 !== r.type : i || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function (e, t, n, i) { if (null === t || "undefined" === typeof t || function (e, t, n, i) { if (null !== n && 0 === n.type) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return !i && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e); default: return !1 } }(e, t, n, i)) return !0; if (i) return !1; if (null !== n) switch (n.type) { case 3: return !t; case 4: return !1 === t; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 }(t, n, r, i) && (n = null), i || null === r ? function (e) { return !!d.call(f, e) || !d.call(p, e) && (h.test(e) ? f[e] = !0 : (p[e] = !0, !1)) }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : r.mustUseProperty ? e[r.propertyName] = null === n ? 3 !== r.type && "" : n : (t = r.attributeName, i = r.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (r = r.type) || 4 === r && !0 === n ? "" : "" + n, i ? e.setAttributeNS(i, t, n) : e.setAttribute(t, n)))) } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function (e) { var t = e.replace(y, v); g[t] = new m(t, 1, !1, e, null, !1, !1) })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function (e) { var t = e.replace(y, v); g[t] = new m(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) })), ["xml:base", "xml:lang", "xml:space"].forEach((function (e) { var t = e.replace(y, v); g[t] = new m(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) })), ["tabIndex", "crossOrigin"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1) })), g.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0) })); var _ = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, T = Symbol.for("react.element"), S = Symbol.for("react.portal"), w = Symbol.for("react.fragment"), x = Symbol.for("react.strict_mode"), k = Symbol.for("react.profiler"), E = Symbol.for("react.provider"), C = Symbol.for("react.context"), P = Symbol.for("react.forward_ref"), I = Symbol.for("react.suspense"), L = Symbol.for("react.suspense_list"), O = Symbol.for("react.memo"), A = Symbol.for("react.lazy"); Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode"); var N = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker"); var j = Symbol.iterator; function D(e) { return null === e || "object" !== typeof e ? null : "function" === typeof (e = j && e[j] || e["@@iterator"]) ? e : null } var M, R = Object.assign; function U(e) { if (void 0 === M) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); M = t && t[1] || "" } return "\n" + M + e } var B = !1; function F(e, t) { if (!e || B) return ""; B = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), "object" === typeof Reflect && Reflect.construct) { try { Reflect.construct(t, []) } catch (c) { var i = c } Reflect.construct(e, [], t) } else { try { t.call() } catch (c) { i = c } e.call(t.prototype) } else { try { throw Error() } catch (c) { i = c } e() } } catch (c) { if (c && i && "string" === typeof c.stack) { for (var r = c.stack.split("\n"), s = i.stack.split("\n"), a = r.length - 1, o = s.length - 1; 1 <= a && 0 <= o && r[a] !== s[o];)o--; for (; 1 <= a && 0 <= o; a--, o--)if (r[a] !== s[o]) { if (1 !== a || 1 !== o) do { if (a--, 0 > --o || r[a] !== s[o]) { var l = "\n" + r[a].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l } } while (1 <= a && 0 <= o); break } } } finally { B = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? U(e) : "" } function z(e) { switch (e.tag) { case 5: return U(e.type); case 16: return U("Lazy"); case 13: return U("Suspense"); case 19: return U("SuspenseList"); case 0: case 2: case 15: return e = F(e.type, !1); case 11: return e = F(e.type.render, !1); case 1: return e = F(e.type, !0); default: return "" } } function H(e) { if (null == e) return null; if ("function" === typeof e) return e.displayName || e.name || null; if ("string" === typeof e) return e; switch (e) { case w: return "Fragment"; case S: return "Portal"; case k: return "Profiler"; case x: return "StrictMode"; case I: return "Suspense"; case L: return "SuspenseList" }if ("object" === typeof e) switch (e.$$typeof) { case C: return (e.displayName || "Context") + ".Consumer"; case E: return (e._context.displayName || "Context") + ".Provider"; case P: var t = e.render; return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case O: return null !== (t = e.displayName || null) ? t : H(e.type) || "Memo"; case A: t = e._payload, e = e._init; try { return H(e(t)) } catch (n) { } }return null } function V(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return H(t); case 8: return t === x ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if ("function" === typeof t) return t.displayName || t.name || null; if ("string" === typeof t) return t }return null } function W(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": case "object": return e; default: return "" } } function q(e) { var t = e.type; return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t) } function G(e) { e._valueTracker || (e._valueTracker = function (e) { var t = q(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), i = "" + e[t]; if (!e.hasOwnProperty(t) && "undefined" !== typeof n && "function" === typeof n.get && "function" === typeof n.set) { var r = n.get, s = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return r.call(this) }, set: function (e) { i = "" + e, s.call(this, e) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return i }, setValue: function (e) { i = "" + e }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } }(e)) } function X(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), i = ""; return e && (i = q(e) ? e.checked ? "true" : "false" : e.value), (e = i) !== n && (t.setValue(e), !0) } function K(e) { if ("undefined" === typeof (e = e || ("undefined" !== typeof document ? document : void 0))) return null; try { return e.activeElement || e.body } catch (t) { return e.body } } function $(e, t) { var n = t.checked; return R({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != n ? n : e._wrapperState.initialChecked }) } function Y(e, t) { var n = null == t.defaultValue ? "" : t.defaultValue, i = null != t.checked ? t.checked : t.defaultChecked; n = W(null != t.value ? t.value : n), e._wrapperState = { initialChecked: i, initialValue: n, controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value } } function Q(e, t) { null != (t = t.checked) && b(e, "checked", t, !1) } function J(e, t) { Q(e, t); var n = W(t.value), i = t.type; if (null != n) "number" === i ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if ("submit" === i || "reset" === i) return void e.removeAttribute("value"); t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, W(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked) } function Z(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var i = t.type; if (!("submit" !== i && "reset" !== i || void 0 !== t.value && null !== t.value)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n) } function ee(e, t, n) { "number" === t && K(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var te = Array.isArray; function ne(e, t, n, i) { if (e = e.options, t) { t = {}; for (var r = 0; r < n.length; r++)t["$" + n[r]] = !0; for (n = 0; n < e.length; n++)r = t.hasOwnProperty("$" + e[n].value), e[n].selected !== r && (e[n].selected = r), r && i && (e[n].defaultSelected = !0) } else { for (n = "" + W(n), t = null, r = 0; r < e.length; r++) { if (e[r].value === n) return e[r].selected = !0, void (i && (e[r].defaultSelected = !0)); null !== t || e[r].disabled || (t = e[r]) } null !== t && (t.selected = !0) } } function ie(e, t) { if (null != t.dangerouslySetInnerHTML) throw Error(s(91)); return R({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function re(e, t) { var n = t.value; if (null == n) { if (n = t.children, t = t.defaultValue, null != n) { if (null != t) throw Error(s(92)); if (te(n)) { if (1 < n.length) throw Error(s(93)); n = n[0] } t = n } null == t && (t = ""), n = t } e._wrapperState = { initialValue: W(n) } } function se(e, t) { var n = W(t.value), i = W(t.defaultValue); null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != i && (e.defaultValue = "" + i) } function ae(e) { var t = e.textContent; t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t) } function oe(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function le(e, t) { return null == e || "http://www.w3.org/1999/xhtml" === e ? oe(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e } var ce, ue, de = (ue = function (e, t) { if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e) e.innerHTML = t; else { for ((ce = ce || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ce.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }, "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (e, t, n, i) { MSApp.execUnsafeLocalFunction((function () { return ue(e, t) })) } : ue); function he(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && 3 === n.nodeType) return void (n.nodeValue = t) } e.textContent = t } var pe = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, fe = ["Webkit", "ms", "Moz", "O"]; function me(e, t, n) { return null == t || "boolean" === typeof t || "" === t ? "" : n || "number" !== typeof t || 0 === t || pe.hasOwnProperty(e) && pe[e] ? ("" + t).trim() : t + "px" } function ge(e, t) { for (var n in e = e.style, t) if (t.hasOwnProperty(n)) { var i = 0 === n.indexOf("--"), r = me(n, t[n], i); "float" === n && (n = "cssFloat"), i ? e.setProperty(n, r) : e[n] = r } } Object.keys(pe).forEach((function (e) { fe.forEach((function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), pe[t] = pe[e] })) })); var ye = R({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function ve(e, t) { if (t) { if (ye[e] && (null != t.children || null != t.dangerouslySetInnerHTML)) throw Error(s(137, e)); if (null != t.dangerouslySetInnerHTML) { if (null != t.children) throw Error(s(60)); if ("object" !== typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML)) throw Error(s(61)) } if (null != t.style && "object" !== typeof t.style) throw Error(s(62)) } } function be(e, t) { if (-1 === e.indexOf("-")) return "string" === typeof t.is; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var _e = null; function Te(e) { return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e } var Se = null, we = null, xe = null; function ke(e) { if (e = br(e)) { if ("function" !== typeof Se) throw Error(s(280)); var t = e.stateNode; t && (t = Tr(t), Se(e.stateNode, e.type, t)) } } function Ee(e) { we ? xe ? xe.push(e) : xe = [e] : we = e } function Ce() { if (we) { var e = we, t = xe; if (xe = we = null, ke(e), t) for (e = 0; e < t.length; e++)ke(t[e]) } } function Pe(e, t) { return e(t) } function Ie() { } var Le = !1; function Oe(e, t, n) { if (Le) return e(t, n); Le = !0; try { return Pe(e, t, n) } finally { Le = !1, (null !== we || null !== xe) && (Ie(), Ce()) } } function Ae(e, t) { var n = e.stateNode; if (null === n) return null; var i = Tr(n); if (null === i) return null; n = i[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (i = !i.disabled) || (i = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !i; break e; default: e = !1 }if (e) return null; if (n && "function" !== typeof n) throw Error(s(231, t, typeof n)); return n } var Ne = !1; if (u) try { var je = {}; Object.defineProperty(je, "passive", { get: function () { Ne = !0 } }), window.addEventListener("test", je, je), window.removeEventListener("test", je, je) } catch (ue) { Ne = !1 } function De(e, t, n, i, r, s, a, o, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(n, c) } catch (u) { this.onError(u) } } var Me = !1, Re = null, Ue = !1, Be = null, Fe = { onError: function (e) { Me = !0, Re = e } }; function ze(e, t, n, i, r, s, a, o, l) { Me = !1, Re = null, De.apply(Fe, arguments) } function He(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do { 0 !== (4098 & (t = e).flags) && (n = t.return), e = t.return } while (e) } return 3 === t.tag ? n : null } function Ve(e) { if (13 === e.tag) { var t = e.memoizedState; if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)), null !== t) return t.dehydrated } return null } function We(e) { if (He(e) !== e) throw Error(s(188)) } function qe(e) { return null !== (e = function (e) { var t = e.alternate; if (!t) { if (null === (t = He(e))) throw Error(s(188)); return t !== e ? null : e } for (var n = e, i = t; ;) { var r = n.return; if (null === r) break; var a = r.alternate; if (null === a) { if (null !== (i = r.return)) { n = i; continue } break } if (r.child === a.child) { for (a = r.child; a;) { if (a === n) return We(r), e; if (a === i) return We(r), t; a = a.sibling } throw Error(s(188)) } if (n.return !== i.return) n = r, i = a; else { for (var o = !1, l = r.child; l;) { if (l === n) { o = !0, n = r, i = a; break } if (l === i) { o = !0, i = r, n = a; break } l = l.sibling } if (!o) { for (l = a.child; l;) { if (l === n) { o = !0, n = a, i = r; break } if (l === i) { o = !0, i = a, n = r; break } l = l.sibling } if (!o) throw Error(s(189)) } } if (n.alternate !== i) throw Error(s(190)) } if (3 !== n.tag) throw Error(s(188)); return n.stateNode.current === n ? e : t }(e)) ? Ge(e) : null } function Ge(e) { if (5 === e.tag || 6 === e.tag) return e; for (e = e.child; null !== e;) { var t = Ge(e); if (null !== t) return t; e = e.sibling } return null } var Xe = r.unstable_scheduleCallback, Ke = r.unstable_cancelCallback, $e = r.unstable_shouldYield, Ye = r.unstable_requestPaint, Qe = r.unstable_now, Je = r.unstable_getCurrentPriorityLevel, Ze = r.unstable_ImmediatePriority, et = r.unstable_UserBlockingPriority, tt = r.unstable_NormalPriority, nt = r.unstable_LowPriority, it = r.unstable_IdlePriority, rt = null, st = null; var at = Math.clz32 ? Math.clz32 : function (e) { return e >>>= 0, 0 === e ? 32 : 31 - (ot(e) / lt | 0) | 0 }, ot = Math.log, lt = Math.LN2; var ct = 64, ut = 4194304; function dt(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & e; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & e; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function ht(e, t) { var n = e.pendingLanes; if (0 === n) return 0; var i = 0, r = e.suspendedLanes, s = e.pingedLanes, a = 268435455 & n; if (0 !== a) { var o = a & ~r; 0 !== o ? i = dt(o) : 0 !== (s &= a) && (i = dt(s)) } else 0 !== (a = n & ~r) ? i = dt(a) : 0 !== s && (i = dt(s)); if (0 === i) return 0; if (0 !== t && t !== i && 0 === (t & r) && ((r = i & -i) >= (s = t & -t) || 16 === r && 0 !== (4194240 & s))) return t; if (0 !== (4 & i) && (i |= 16 & n), 0 !== (t = e.entangledLanes)) for (e = e.entanglements, t &= i; 0 < t;)r = 1 << (n = 31 - at(t)), i |= e[n], t &= ~r; return i } function pt(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; default: return -1 } } function ft(e) { return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0 } function mt() { var e = ct; return 0 === (4194240 & (ct <<= 1)) && (ct = 64), e } function gt(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function yt(e, t, n) { e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - at(t)] = n } function vt(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var i = 31 - at(n), r = 1 << i; r & t | e[i] & t && (e[i] |= t), n &= ~r } } var bt = 0; function _t(e) { return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1 } var Tt, St, wt, xt, kt, Et = !1, Ct = [], Pt = null, It = null, Lt = null, Ot = new Map, At = new Map, Nt = [], jt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Dt(e, t) { switch (e) { case "focusin": case "focusout": Pt = null; break; case "dragenter": case "dragleave": It = null; break; case "mouseover": case "mouseout": Lt = null; break; case "pointerover": case "pointerout": Ot.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": At.delete(t.pointerId) } } function Mt(e, t, n, i, r, s) { return null === e || e.nativeEvent !== s ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: i, nativeEvent: s, targetContainers: [r] }, null !== t && (null !== (t = br(t)) && St(t)), e) : (e.eventSystemFlags |= i, t = e.targetContainers, null !== r && -1 === t.indexOf(r) && t.push(r), e) } function Rt(e) { var t = vr(e.target); if (null !== t) { var n = He(t); if (null !== n) if (13 === (t = n.tag)) { if (null !== (t = Ve(n))) return e.blockedOn = t, void kt(e.priority, (function () { wt(n) })) } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void (e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null) } e.blockedOn = null } function Ut(e) { if (null !== e.blockedOn) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = $t(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (null !== n) return null !== (t = br(n)) && St(t), e.blockedOn = n, !1; var i = new (n = e.nativeEvent).constructor(n.type, n); _e = i, n.target.dispatchEvent(i), _e = null, t.shift() } return !0 } function Bt(e, t, n) { Ut(e) && n.delete(t) } function Ft() { Et = !1, null !== Pt && Ut(Pt) && (Pt = null), null !== It && Ut(It) && (It = null), null !== Lt && Ut(Lt) && (Lt = null), Ot.forEach(Bt), At.forEach(Bt) } function zt(e, t) { e.blockedOn === t && (e.blockedOn = null, Et || (Et = !0, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ft))) } function Ht(e) { function t(t) { return zt(t, e) } if (0 < Ct.length) { zt(Ct[0], e); for (var n = 1; n < Ct.length; n++) { var i = Ct[n]; i.blockedOn === e && (i.blockedOn = null) } } for (null !== Pt && zt(Pt, e), null !== It && zt(It, e), null !== Lt && zt(Lt, e), Ot.forEach(t), At.forEach(t), n = 0; n < Nt.length; n++)(i = Nt[n]).blockedOn === e && (i.blockedOn = null); for (; 0 < Nt.length && null === (n = Nt[0]).blockedOn;)Rt(n), null === n.blockedOn && Nt.shift() } var Vt = _.ReactCurrentBatchConfig, Wt = !0; function qt(e, t, n, i) { var r = bt, s = Vt.transition; Vt.transition = null; try { bt = 1, Xt(e, t, n, i) } finally { bt = r, Vt.transition = s } } function Gt(e, t, n, i) { var r = bt, s = Vt.transition; Vt.transition = null; try { bt = 4, Xt(e, t, n, i) } finally { bt = r, Vt.transition = s } } function Xt(e, t, n, i) { if (Wt) { var r = $t(e, t, n, i); if (null === r) Wi(e, t, i, Kt, n), Dt(e, i); else if (function (e, t, n, i, r) { switch (t) { case "focusin": return Pt = Mt(Pt, e, t, n, i, r), !0; case "dragenter": return It = Mt(It, e, t, n, i, r), !0; case "mouseover": return Lt = Mt(Lt, e, t, n, i, r), !0; case "pointerover": var s = r.pointerId; return Ot.set(s, Mt(Ot.get(s) || null, e, t, n, i, r)), !0; case "gotpointercapture": return s = r.pointerId, At.set(s, Mt(At.get(s) || null, e, t, n, i, r)), !0 }return !1 }(r, e, t, n, i)) i.stopPropagation(); else if (Dt(e, i), 4 & t && -1 < jt.indexOf(e)) { for (; null !== r;) { var s = br(r); if (null !== s && Tt(s), null === (s = $t(e, t, n, i)) && Wi(e, t, i, Kt, n), s === r) break; r = s } null !== r && i.stopPropagation() } else Wi(e, t, i, null, n) } } var Kt = null; function $t(e, t, n, i) { if (Kt = null, null !== (e = vr(e = Te(i)))) if (null === (t = He(e))) e = null; else if (13 === (n = t.tag)) { if (null !== (e = Ve(t))) return e; e = null } else if (3 === n) { if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Kt = e, null } function Yt(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Je()) { case Ze: return 1; case et: return 4; case tt: case nt: return 16; case it: return 536870912; default: return 16 }default: return 16 } } var Qt = null, Jt = null, Zt = null; function en() { if (Zt) return Zt; var e, t, n = Jt, i = n.length, r = "value" in Qt ? Qt.value : Qt.textContent, s = r.length; for (e = 0; e < i && n[e] === r[e]; e++); var a = i - e; for (t = 1; t <= a && n[i - t] === r[s - t]; t++); return Zt = r.slice(e, 1 < t ? 1 - t : void 0) } function tn(e) { var t = e.keyCode; return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0 } function nn() { return !0 } function rn() { return !1 } function sn(e) { function t(t, n, i, r, s) { for (var a in this._reactName = t, this._targetInst = i, this.type = n, this.nativeEvent = r, this.target = s, this.currentTarget = null, e) e.hasOwnProperty(a) && (t = e[a], this[a] = t ? t(r) : r[a]); return this.isDefaultPrevented = (null != r.defaultPrevented ? r.defaultPrevented : !1 === r.returnValue) ? nn : rn, this.isPropagationStopped = rn, this } return R(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var e = this.nativeEvent; e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = nn) }, stopPropagation: function () { var e = this.nativeEvent; e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = nn) }, persist: function () { }, isPersistent: nn }), t } var an, on, ln, cn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, un = sn(cn), dn = R({}, cn, { view: 0, detail: 0 }), hn = sn(dn), pn = R({}, dn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: kn, button: 0, buttons: 0, relatedTarget: function (e) { return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (an = e.screenX - ln.screenX, on = e.screenY - ln.screenY) : on = an = 0, ln = e), an) }, movementY: function (e) { return "movementY" in e ? e.movementY : on } }), fn = sn(pn), mn = sn(R({}, pn, { dataTransfer: 0 })), gn = sn(R({}, dn, { relatedTarget: 0 })), yn = sn(R({}, cn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })), vn = R({}, cn, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), bn = sn(vn), _n = sn(R({}, cn, { data: 0 })), Tn = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Sn = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, wn = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function xn(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = wn[e]) && !!t[e] } function kn() { return xn } var En = R({}, dn, { key: function (e) { if (e.key) { var t = Tn[e.key] || e.key; if ("Unidentified" !== t) return t } return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? Sn[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: kn, charCode: function (e) { return "keypress" === e.type ? tn(e) : 0 }, keyCode: function (e) { return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 }, which: function (e) { return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 } }), Cn = sn(En), Pn = sn(R({}, pn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 })), In = sn(R({}, dn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: kn })), Ln = sn(R({}, cn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })), On = R({}, pn, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), An = sn(On), Nn = [9, 13, 27, 32], jn = u && "CompositionEvent" in window, Dn = null; u && "documentMode" in document && (Dn = document.documentMode); var Mn = u && "TextEvent" in window && !Dn, Rn = u && (!jn || Dn && 8 < Dn && 11 >= Dn), Un = String.fromCharCode(32), Bn = !1; function Fn(e, t) { switch (e) { case "keyup": return -1 !== Nn.indexOf(t.keyCode); case "keydown": return 229 !== t.keyCode; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function zn(e) { return "object" === typeof (e = e.detail) && "data" in e ? e.data : null } var Hn = !1; var Vn = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Wn(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return "input" === t ? !!Vn[e.type] : "textarea" === t } function qn(e, t, n, i) { Ee(i), 0 < (t = Gi(t, "onChange")).length && (n = new un("onChange", "change", null, n, i), e.push({ event: n, listeners: t })) } var Gn = null, Xn = null; function Kn(e) { Ui(e, 0) } function $n(e) { if (X(_r(e))) return e } function Yn(e, t) { if ("change" === e) return t } var Qn = !1; if (u) { var Jn; if (u) { var Zn = "oninput" in document; if (!Zn) { var ei = document.createElement("div"); ei.setAttribute("oninput", "return;"), Zn = "function" === typeof ei.oninput } Jn = Zn } else Jn = !1; Qn = Jn && (!document.documentMode || 9 < document.documentMode) } function ti() { Gn && (Gn.detachEvent("onpropertychange", ni), Xn = Gn = null) } function ni(e) { if ("value" === e.propertyName && $n(Xn)) { var t = []; qn(t, Xn, e, Te(e)), Oe(Kn, t) } } function ii(e, t, n) { "focusin" === e ? (ti(), Xn = n, (Gn = t).attachEvent("onpropertychange", ni)) : "focusout" === e && ti() } function ri(e) { if ("selectionchange" === e || "keyup" === e || "keydown" === e) return $n(Xn) } function si(e, t) { if ("click" === e) return $n(t) } function ai(e, t) { if ("input" === e || "change" === e) return $n(t) } var oi = "function" === typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t }; function li(e, t) { if (oi(e, t)) return !0; if ("object" !== typeof e || null === e || "object" !== typeof t || null === t) return !1; var n = Object.keys(e), i = Object.keys(t); if (n.length !== i.length) return !1; for (i = 0; i < n.length; i++) { var r = n[i]; if (!d.call(t, r) || !oi(e[r], t[r])) return !1 } return !0 } function ci(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function ui(e, t) { var n, i = ci(e); for (e = 0; i;) { if (3 === i.nodeType) { if (n = e + i.textContent.length, e <= t && n >= t) return { node: i, offset: t - e }; e = n } e: { for (; i;) { if (i.nextSibling) { i = i.nextSibling; break e } i = i.parentNode } i = void 0 } i = ci(i) } } function di(e, t) { return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? di(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))) } function hi() { for (var e = window, t = K(); t instanceof e.HTMLIFrameElement;) { try { var n = "string" === typeof t.contentWindow.location.href } catch (i) { n = !1 } if (!n) break; t = K((e = t.contentWindow).document) } return t } function pi(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable) } function fi(e) { var t = hi(), n = e.focusedElem, i = e.selectionRange; if (t !== n && n && n.ownerDocument && di(n.ownerDocument.documentElement, n)) { if (null !== i && pi(n)) if (t = i.start, void 0 === (e = i.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) { e = e.getSelection(); var r = n.textContent.length, s = Math.min(i.start, r); i = void 0 === i.end ? s : Math.min(i.end, r), !e.extend && s > i && (r = i, i = s, s = r), r = ui(n, s); var a = ui(n, i); r && a && (1 !== e.rangeCount || e.anchorNode !== r.node || e.anchorOffset !== r.offset || e.focusNode !== a.node || e.focusOffset !== a.offset) && ((t = t.createRange()).setStart(r.node, r.offset), e.removeAllRanges(), s > i ? (e.addRange(t), e.extend(a.node, a.offset)) : (t.setEnd(a.node, a.offset), e.addRange(t))) } for (t = [], e = n; e = e.parentNode;)1 === e.nodeType && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for ("function" === typeof n.focus && n.focus(), n = 0; n < t.length; n++)(e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top } } var mi = u && "documentMode" in document && 11 >= document.documentMode, gi = null, yi = null, vi = null, bi = !1; function _i(e, t, n) { var i = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument; bi || null == gi || gi !== K(i) || ("selectionStart" in (i = gi) && pi(i) ? i = { start: i.selectionStart, end: i.selectionEnd } : i = { anchorNode: (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection()).anchorNode, anchorOffset: i.anchorOffset, focusNode: i.focusNode, focusOffset: i.focusOffset }, vi && li(vi, i) || (vi = i, 0 < (i = Gi(yi, "onSelect")).length && (t = new un("onSelect", "select", null, t, n), e.push({ event: t, listeners: i }), t.target = gi))) } function Ti(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var Si = { animationend: Ti("Animation", "AnimationEnd"), animationiteration: Ti("Animation", "AnimationIteration"), animationstart: Ti("Animation", "AnimationStart"), transitionend: Ti("Transition", "TransitionEnd") }, wi = {}, xi = {}; function ki(e) { if (wi[e]) return wi[e]; if (!Si[e]) return e; var t, n = Si[e]; for (t in n) if (n.hasOwnProperty(t) && t in xi) return wi[e] = n[t]; return e } u && (xi = document.createElement("div").style, "AnimationEvent" in window || (delete Si.animationend.animation, delete Si.animationiteration.animation, delete Si.animationstart.animation), "TransitionEvent" in window || delete Si.transitionend.transition); var Ei = ki("animationend"), Ci = ki("animationiteration"), Pi = ki("animationstart"), Ii = ki("transitionend"), Li = new Map, Oi = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Ai(e, t) { Li.set(e, t), l(t, [e]) } for (var Ni = 0; Ni < Oi.length; Ni++) { var ji = Oi[Ni]; Ai(ji.toLowerCase(), "on" + (ji[0].toUpperCase() + ji.slice(1))) } Ai(Ei, "onAnimationEnd"), Ai(Ci, "onAnimationIteration"), Ai(Pi, "onAnimationStart"), Ai("dblclick", "onDoubleClick"), Ai("focusin", "onFocus"), Ai("focusout", "onBlur"), Ai(Ii, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Di = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Mi = new Set("cancel close invalid load scroll toggle".split(" ").concat(Di)); function Ri(e, t, n) { var i = e.type || "unknown-event"; e.currentTarget = n, function (e, t, n, i, r, a, o, l, c) { if (ze.apply(this, arguments), Me) { if (!Me) throw Error(s(198)); var u = Re; Me = !1, Re = null, Ue || (Ue = !0, Be = u) } }(i, t, void 0, e), e.currentTarget = null } function Ui(e, t) { t = 0 !== (4 & t); for (var n = 0; n < e.length; n++) { var i = e[n], r = i.event; i = i.listeners; e: { var s = void 0; if (t) for (var a = i.length - 1; 0 <= a; a--) { var o = i[a], l = o.instance, c = o.currentTarget; if (o = o.listener, l !== s && r.isPropagationStopped()) break e; Ri(r, o, c), s = l } else for (a = 0; a < i.length; a++) { if (l = (o = i[a]).instance, c = o.currentTarget, o = o.listener, l !== s && r.isPropagationStopped()) break e; Ri(r, o, c), s = l } } } if (Ue) throw e = Be, Ue = !1, Be = null, e } function Bi(e, t) { var n = t[mr]; void 0 === n && (n = t[mr] = new Set); var i = e + "__bubble"; n.has(i) || (Vi(t, e, 2, !1), n.add(i)) } function Fi(e, t, n) { var i = 0; t && (i |= 4), Vi(n, e, i, t) } var zi = "_reactListening" + Math.random().toString(36).slice(2); function Hi(e) { if (!e[zi]) { e[zi] = !0, a.forEach((function (t) { "selectionchange" !== t && (Mi.has(t) || Fi(t, !1, e), Fi(t, !0, e)) })); var t = 9 === e.nodeType ? e : e.ownerDocument; null === t || t[zi] || (t[zi] = !0, Fi("selectionchange", !1, t)) } } function Vi(e, t, n, i) { switch (Yt(t)) { case 1: var r = qt; break; case 4: r = Gt; break; default: r = Xt }n = r.bind(null, t, n, e), r = void 0, !Ne || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (r = !0), i ? void 0 !== r ? e.addEventListener(t, n, { capture: !0, passive: r }) : e.addEventListener(t, n, !0) : void 0 !== r ? e.addEventListener(t, n, { passive: r }) : e.addEventListener(t, n, !1) } function Wi(e, t, n, i, r) { var s = i; if (0 === (1 & t) && 0 === (2 & t) && null !== i) e: for (; ;) { if (null === i) return; var a = i.tag; if (3 === a || 4 === a) { var o = i.stateNode.containerInfo; if (o === r || 8 === o.nodeType && o.parentNode === r) break; if (4 === a) for (a = i.return; null !== a;) { var l = a.tag; if ((3 === l || 4 === l) && ((l = a.stateNode.containerInfo) === r || 8 === l.nodeType && l.parentNode === r)) return; a = a.return } for (; null !== o;) { if (null === (a = vr(o))) return; if (5 === (l = a.tag) || 6 === l) { i = s = a; continue e } o = o.parentNode } } i = i.return } Oe((function () { var i = s, r = Te(n), a = []; e: { var o = Li.get(e); if (void 0 !== o) { var l = un, c = e; switch (e) { case "keypress": if (0 === tn(n)) break e; case "keydown": case "keyup": l = Cn; break; case "focusin": c = "focus", l = gn; break; case "focusout": c = "blur", l = gn; break; case "beforeblur": case "afterblur": l = gn; break; case "click": if (2 === n.button) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": l = fn; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": l = mn; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": l = In; break; case Ei: case Ci: case Pi: l = yn; break; case Ii: l = Ln; break; case "scroll": l = hn; break; case "wheel": l = An; break; case "copy": case "cut": case "paste": l = bn; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": l = Pn }var u = 0 !== (4 & t), d = !u && "scroll" === e, h = u ? null !== o ? o + "Capture" : null : o; u = []; for (var p, f = i; null !== f;) { var m = (p = f).stateNode; if (5 === p.tag && null !== m && (p = m, null !== h && (null != (m = Ae(f, h)) && u.push(qi(f, m, p)))), d) break; f = f.return } 0 < u.length && (o = new l(o, c, null, n, r), a.push({ event: o, listeners: u })) } } if (0 === (7 & t)) { if (l = "mouseout" === e || "pointerout" === e, (!(o = "mouseover" === e || "pointerover" === e) || n === _e || !(c = n.relatedTarget || n.fromElement) || !vr(c) && !c[fr]) && (l || o) && (o = r.window === r ? r : (o = r.ownerDocument) ? o.defaultView || o.parentWindow : window, l ? (l = i, null !== (c = (c = n.relatedTarget || n.toElement) ? vr(c) : null) && (c !== (d = He(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (l = null, c = i), l !== c)) { if (u = fn, m = "onMouseLeave", h = "onMouseEnter", f = "mouse", "pointerout" !== e && "pointerover" !== e || (u = Pn, m = "onPointerLeave", h = "onPointerEnter", f = "pointer"), d = null == l ? o : _r(l), p = null == c ? o : _r(c), (o = new u(m, f + "leave", l, n, r)).target = d, o.relatedTarget = p, m = null, vr(r) === i && ((u = new u(h, f + "enter", c, n, r)).target = p, u.relatedTarget = d, m = u), d = m, l && c) e: { for (h = c, f = 0, p = u = l; p; p = Xi(p))f++; for (p = 0, m = h; m; m = Xi(m))p++; for (; 0 < f - p;)u = Xi(u), f--; for (; 0 < p - f;)h = Xi(h), p--; for (; f--;) { if (u === h || null !== h && u === h.alternate) break e; u = Xi(u), h = Xi(h) } u = null } else u = null; null !== l && Ki(a, o, l, u, !1), null !== c && null !== d && Ki(a, d, c, u, !0) } if ("select" === (l = (o = i ? _r(i) : window).nodeName && o.nodeName.toLowerCase()) || "input" === l && "file" === o.type) var g = Yn; else if (Wn(o)) if (Qn) g = ai; else { g = ri; var y = ii } else (l = o.nodeName) && "input" === l.toLowerCase() && ("checkbox" === o.type || "radio" === o.type) && (g = si); switch (g && (g = g(e, i)) ? qn(a, g, n, r) : (y && y(e, o, i), "focusout" === e && (y = o._wrapperState) && y.controlled && "number" === o.type && ee(o, "number", o.value)), y = i ? _r(i) : window, e) { case "focusin": (Wn(y) || "true" === y.contentEditable) && (gi = y, yi = i, vi = null); break; case "focusout": vi = yi = gi = null; break; case "mousedown": bi = !0; break; case "contextmenu": case "mouseup": case "dragend": bi = !1, _i(a, n, r); break; case "selectionchange": if (mi) break; case "keydown": case "keyup": _i(a, n, r) }var v; if (jn) e: { switch (e) { case "compositionstart": var b = "onCompositionStart"; break e; case "compositionend": b = "onCompositionEnd"; break e; case "compositionupdate": b = "onCompositionUpdate"; break e }b = void 0 } else Hn ? Fn(e, n) && (b = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (b = "onCompositionStart"); b && (Rn && "ko" !== n.locale && (Hn || "onCompositionStart" !== b ? "onCompositionEnd" === b && Hn && (v = en()) : (Jt = "value" in (Qt = r) ? Qt.value : Qt.textContent, Hn = !0)), 0 < (y = Gi(i, b)).length && (b = new _n(b, e, null, n, r), a.push({ event: b, listeners: y }), v ? b.data = v : null !== (v = zn(n)) && (b.data = v))), (v = Mn ? function (e, t) { switch (e) { case "compositionend": return zn(t); case "keypress": return 32 !== t.which ? null : (Bn = !0, Un); case "textInput": return (e = t.data) === Un && Bn ? null : e; default: return null } }(e, n) : function (e, t) { if (Hn) return "compositionend" === e || !jn && Fn(e, t) ? (e = en(), Zt = Jt = Qt = null, Hn = !1, e) : null; switch (e) { case "paste": default: return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return Rn && "ko" !== t.locale ? null : t.data } }(e, n)) && (0 < (i = Gi(i, "onBeforeInput")).length && (r = new _n("onBeforeInput", "beforeinput", null, n, r), a.push({ event: r, listeners: i }), r.data = v)) } Ui(a, t) })) } function qi(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Gi(e, t) { for (var n = t + "Capture", i = []; null !== e;) { var r = e, s = r.stateNode; 5 === r.tag && null !== s && (r = s, null != (s = Ae(e, n)) && i.unshift(qi(e, s, r)), null != (s = Ae(e, t)) && i.push(qi(e, s, r))), e = e.return } return i } function Xi(e) { if (null === e) return null; do { e = e.return } while (e && 5 !== e.tag); return e || null } function Ki(e, t, n, i, r) { for (var s = t._reactName, a = []; null !== n && n !== i;) { var o = n, l = o.alternate, c = o.stateNode; if (null !== l && l === i) break; 5 === o.tag && null !== c && (o = c, r ? null != (l = Ae(n, s)) && a.unshift(qi(n, l, o)) : r || null != (l = Ae(n, s)) && a.push(qi(n, l, o))), n = n.return } 0 !== a.length && e.push({ event: t, listeners: a }) } var $i = /\r\n?/g, Yi = /\u0000|\uFFFD/g; function Qi(e) { return ("string" === typeof e ? e : "" + e).replace($i, "\n").replace(Yi, "") } function Ji(e, t, n) { if (t = Qi(t), Qi(e) !== t && n) throw Error(s(425)) } function Zi() { } var er = null, tr = null; function nr(e, t) { return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html } var ir = "function" === typeof setTimeout ? setTimeout : void 0, rr = "function" === typeof clearTimeout ? clearTimeout : void 0, sr = "function" === typeof Promise ? Promise : void 0, ar = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof sr ? function (e) { return sr.resolve(null).then(e).catch(or) } : ir; function or(e) { setTimeout((function () { throw e })) } function lr(e, t) { var n = t, i = 0; do { var r = n.nextSibling; if (e.removeChild(n), r && 8 === r.nodeType) if ("/$" === (n = r.data)) { if (0 === i) return e.removeChild(r), void Ht(t); i-- } else "$" !== n && "$?" !== n && "$!" !== n || i++; n = r } while (n); Ht(t) } function cr(e) { for (; null != e; e = e.nextSibling) { var t = e.nodeType; if (1 === t || 3 === t) break; if (8 === t) { if ("$" === (t = e.data) || "$!" === t || "$?" === t) break; if ("/$" === t) return null } } return e } function ur(e) { e = e.previousSibling; for (var t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("$" === n || "$!" === n || "$?" === n) { if (0 === t) return e; t-- } else "/$" === n && t++ } e = e.previousSibling } return null } var dr = Math.random().toString(36).slice(2), hr = "__reactFiber$" + dr, pr = "__reactProps$" + dr, fr = "__reactContainer$" + dr, mr = "__reactEvents$" + dr, gr = "__reactListeners$" + dr, yr = "__reactHandles$" + dr; function vr(e) { var t = e[hr]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[fr] || n[hr]) { if (n = t.alternate, null !== t.child || null !== n && null !== n.child) for (e = ur(e); null !== e;) { if (n = e[hr]) return n; e = ur(e) } return t } n = (e = n).parentNode } return null } function br(e) { return !(e = e[hr] || e[fr]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e } function _r(e) { if (5 === e.tag || 6 === e.tag) return e.stateNode; throw Error(s(33)) } function Tr(e) { return e[pr] || null } var Sr = [], wr = -1; function xr(e) { return { current: e } } function kr(e) { 0 > wr || (e.current = Sr[wr], Sr[wr] = null, wr--) } function Er(e, t) { wr++, Sr[wr] = e.current, e.current = t } var Cr = {}, Pr = xr(Cr), Ir = xr(!1), Lr = Cr; function Or(e, t) { var n = e.type.contextTypes; if (!n) return Cr; var i = e.stateNode; if (i && i.__reactInternalMemoizedUnmaskedChildContext === t) return i.__reactInternalMemoizedMaskedChildContext; var r, s = {}; for (r in n) s[r] = t[r]; return i && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = s), s } function Ar(e) { return null !== (e = e.childContextTypes) && void 0 !== e } function Nr() { kr(Ir), kr(Pr) } function jr(e, t, n) { if (Pr.current !== Cr) throw Error(s(168)); Er(Pr, t), Er(Ir, n) } function Dr(e, t, n) { var i = e.stateNode; if (t = t.childContextTypes, "function" !== typeof i.getChildContext) return n; for (var r in i = i.getChildContext()) if (!(r in t)) throw Error(s(108, V(e) || "Unknown", r)); return R({}, n, i) } function Mr(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Cr, Lr = Pr.current, Er(Pr, e), Er(Ir, Ir.current), !0 } function Rr(e, t, n) { var i = e.stateNode; if (!i) throw Error(s(169)); n ? (e = Dr(e, t, Lr), i.__reactInternalMemoizedMergedChildContext = e, kr(Ir), kr(Pr), Er(Pr, e)) : kr(Ir), Er(Ir, n) } var Ur = null, Br = !1, Fr = !1; function zr(e) { null === Ur ? Ur = [e] : Ur.push(e) } function Hr() { if (!Fr && null !== Ur) { Fr = !0; var e = 0, t = bt; try { var n = Ur; for (bt = 1; e < n.length; e++) { var i = n[e]; do { i = i(!0) } while (null !== i) } Ur = null, Br = !1 } catch (r) { throw null !== Ur && (Ur = Ur.slice(e + 1)), Xe(Ze, Hr), r } finally { bt = t, Fr = !1 } } return null } var Vr = [], Wr = 0, qr = null, Gr = 0, Xr = [], Kr = 0, $r = null, Yr = 1, Qr = ""; function Jr(e, t) { Vr[Wr++] = Gr, Vr[Wr++] = qr, qr = e, Gr = t } function Zr(e, t, n) { Xr[Kr++] = Yr, Xr[Kr++] = Qr, Xr[Kr++] = $r, $r = e; var i = Yr; e = Qr; var r = 32 - at(i) - 1; i &= ~(1 << r), n += 1; var s = 32 - at(t) + r; if (30 < s) { var a = r - r % 5; s = (i & (1 << a) - 1).toString(32), i >>= a, r -= a, Yr = 1 << 32 - at(t) + r | n << r | i, Qr = s + e } else Yr = 1 << s | n << r | i, Qr = e } function es(e) { null !== e.return && (Jr(e, 1), Zr(e, 1, 0)) } function ts(e) { for (; e === qr;)qr = Vr[--Wr], Vr[Wr] = null, Gr = Vr[--Wr], Vr[Wr] = null; for (; e === $r;)$r = Xr[--Kr], Xr[Kr] = null, Qr = Xr[--Kr], Xr[Kr] = null, Yr = Xr[--Kr], Xr[Kr] = null } var ns = null, is = null, rs = !1, ss = null; function as(e, t) { var n = Ac(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function os(e, t) { switch (e.tag) { case 5: var n = e.type; return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, ns = e, is = cr(t.firstChild), !0); case 6: return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, ns = e, is = null, !0); case 13: return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== $r ? { id: Yr, overflow: Qr } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, (n = Ac(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, ns = e, is = null, !0); default: return !1 } } function ls(e) { return 0 !== (1 & e.mode) && 0 === (128 & e.flags) } function cs(e) { if (rs) { var t = is; if (t) { var n = t; if (!os(e, t)) { if (ls(e)) throw Error(s(418)); t = cr(n.nextSibling); var i = ns; t && os(e, t) ? as(i, n) : (e.flags = -4097 & e.flags | 2, rs = !1, ns = e) } } else { if (ls(e)) throw Error(s(418)); e.flags = -4097 & e.flags | 2, rs = !1, ns = e } } } function us(e) { for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;)e = e.return; ns = e } function ds(e) { if (e !== ns) return !1; if (!rs) return us(e), rs = !0, !1; var t; if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !nr(e.type, e.memoizedProps)), t && (t = is)) { if (ls(e)) throw hs(), Error(s(418)); for (; t;)as(e, t), t = cr(t.nextSibling) } if (us(e), 13 === e.tag) { if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(s(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("/$" === n) { if (0 === t) { is = cr(e.nextSibling); break e } t-- } else "$" !== n && "$!" !== n && "$?" !== n || t++ } e = e.nextSibling } is = null } } else is = ns ? cr(e.stateNode.nextSibling) : null; return !0 } function hs() { for (var e = is; e;)e = cr(e.nextSibling) } function ps() { is = ns = null, rs = !1 } function fs(e) { null === ss ? ss = [e] : ss.push(e) } var ms = _.ReactCurrentBatchConfig; function gs(e, t) { if (e && e.defaultProps) { for (var n in t = R({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]); return t } return t } var ys = xr(null), vs = null, bs = null, _s = null; function Ts() { _s = bs = vs = null } function Ss(e) { var t = ys.current; kr(ys), e._currentValue = t } function ws(e, t, n) { for (; null !== e;) { var i = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== i && (i.childLanes |= t)) : null !== i && (i.childLanes & t) !== t && (i.childLanes |= t), e === n) break; e = e.return } } function xs(e, t) { vs = e, _s = bs = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (_o = !0), e.firstContext = null) } function ks(e) { var t = e._currentValue; if (_s !== e) if (e = { context: e, memoizedValue: t, next: null }, null === bs) { if (null === vs) throw Error(s(308)); bs = e, vs.dependencies = { lanes: 0, firstContext: e } } else bs = bs.next = e; return t } var Es = null; function Cs(e) { null === Es ? Es = [e] : Es.push(e) } function Ps(e, t, n, i) { var r = t.interleaved; return null === r ? (n.next = n, Cs(t)) : (n.next = r.next, r.next = n), t.interleaved = n, Is(e, i) } function Is(e, t) { e.lanes |= t; var n = e.alternate; for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;)e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return; return 3 === n.tag ? n.stateNode : null } var Ls = !1; function Os(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function As(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Ns(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function js(e, t, n) { var i = e.updateQueue; if (null === i) return null; if (i = i.shared, 0 !== (2 & Il)) { var r = i.pending; return null === r ? t.next = t : (t.next = r.next, r.next = t), i.pending = t, Is(e, n) } return null === (r = i.interleaved) ? (t.next = t, Cs(i)) : (t.next = r.next, r.next = t), i.interleaved = t, Is(e, n) } function Ds(e, t, n) { if (null !== (t = t.updateQueue) && (t = t.shared, 0 !== (4194240 & n))) { var i = t.lanes; n |= i &= e.pendingLanes, t.lanes = n, vt(e, n) } } function Ms(e, t) { var n = e.updateQueue, i = e.alternate; if (null !== i && n === (i = i.updateQueue)) { var r = null, s = null; if (null !== (n = n.firstBaseUpdate)) { do { var a = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; null === s ? r = s = a : s = s.next = a, n = n.next } while (null !== n); null === s ? r = s = t : s = s.next = t } else r = s = t; return n = { baseState: i.baseState, firstBaseUpdate: r, lastBaseUpdate: s, shared: i.shared, effects: i.effects }, void (e.updateQueue = n) } null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function Rs(e, t, n, i) { var r = e.updateQueue; Ls = !1; var s = r.firstBaseUpdate, a = r.lastBaseUpdate, o = r.shared.pending; if (null !== o) { r.shared.pending = null; var l = o, c = l.next; l.next = null, null === a ? s = c : a.next = c, a = l; var u = e.alternate; null !== u && ((o = (u = u.updateQueue).lastBaseUpdate) !== a && (null === o ? u.firstBaseUpdate = c : o.next = c, u.lastBaseUpdate = l)) } if (null !== s) { var d = r.baseState; for (a = 0, u = c = l = null, o = s; ;) { var h = o.lane, p = o.eventTime; if ((i & h) === h) { null !== u && (u = u.next = { eventTime: p, lane: 0, tag: o.tag, payload: o.payload, callback: o.callback, next: null }); e: { var f = e, m = o; switch (h = t, p = n, m.tag) { case 1: if ("function" === typeof (f = m.payload)) { d = f.call(p, d, h); break e } d = f; break e; case 3: f.flags = -65537 & f.flags | 128; case 0: if (null === (h = "function" === typeof (f = m.payload) ? f.call(p, d, h) : f) || void 0 === h) break e; d = R({}, d, h); break e; case 2: Ls = !0 } } null !== o.callback && 0 !== o.lane && (e.flags |= 64, null === (h = r.effects) ? r.effects = [o] : h.push(o)) } else p = { eventTime: p, lane: h, tag: o.tag, payload: o.payload, callback: o.callback, next: null }, null === u ? (c = u = p, l = d) : u = u.next = p, a |= h; if (null === (o = o.next)) { if (null === (o = r.shared.pending)) break; o = (h = o).next, h.next = null, r.lastBaseUpdate = h, r.shared.pending = null } } if (null === u && (l = d), r.baseState = l, r.firstBaseUpdate = c, r.lastBaseUpdate = u, null !== (t = r.shared.interleaved)) { r = t; do { a |= r.lane, r = r.next } while (r !== t) } else null === s && (r.shared.lanes = 0); Rl |= a, e.lanes = a, e.memoizedState = d } } function Us(e, t, n) { if (e = t.effects, t.effects = null, null !== e) for (t = 0; t < e.length; t++) { var i = e[t], r = i.callback; if (null !== r) { if (i.callback = null, i = n, "function" !== typeof r) throw Error(s(191, r)); r.call(i) } } } var Bs = (new i.Component).refs; function Fs(e, t, n, i) { n = null === (n = n(i, t = e.memoizedState)) || void 0 === n ? t : R({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n) } var zs = { isMounted: function (e) { return !!(e = e._reactInternals) && He(e) === e }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var i = tc(), r = nc(e), s = Ns(i, r); s.payload = t, void 0 !== n && null !== n && (s.callback = n), null !== (t = js(e, s, r)) && (ic(t, e, r, i), Ds(t, e, r)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var i = tc(), r = nc(e), s = Ns(i, r); s.tag = 1, s.payload = t, void 0 !== n && null !== n && (s.callback = n), null !== (t = js(e, s, r)) && (ic(t, e, r, i), Ds(t, e, r)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = tc(), i = nc(e), r = Ns(n, i); r.tag = 2, void 0 !== t && null !== t && (r.callback = t), null !== (t = js(e, r, i)) && (ic(t, e, i, n), Ds(t, e, i)) } }; function Hs(e, t, n, i, r, s, a) { return "function" === typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(i, s, a) : !t.prototype || !t.prototype.isPureReactComponent || (!li(n, i) || !li(r, s)) } function Vs(e, t, n) { var i = !1, r = Cr, s = t.contextType; return "object" === typeof s && null !== s ? s = ks(s) : (r = Ar(t) ? Lr : Pr.current, s = (i = null !== (i = t.contextTypes) && void 0 !== i) ? Or(e, r) : Cr), t = new t(n, s), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = zs, e.stateNode = t, t._reactInternals = e, i && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = r, e.__reactInternalMemoizedMaskedChildContext = s), t } function Ws(e, t, n, i) { e = t.state, "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, i), "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, i), t.state !== e && zs.enqueueReplaceState(t, t.state, null) } function qs(e, t, n, i) { var r = e.stateNode; r.props = n, r.state = e.memoizedState, r.refs = Bs, Os(e); var s = t.contextType; "object" === typeof s && null !== s ? r.context = ks(s) : (s = Ar(t) ? Lr : Pr.current, r.context = Or(e, s)), r.state = e.memoizedState, "function" === typeof (s = t.getDerivedStateFromProps) && (Fs(e, t, s, n), r.state = e.memoizedState), "function" === typeof t.getDerivedStateFromProps || "function" === typeof r.getSnapshotBeforeUpdate || "function" !== typeof r.UNSAFE_componentWillMount && "function" !== typeof r.componentWillMount || (t = r.state, "function" === typeof r.componentWillMount && r.componentWillMount(), "function" === typeof r.UNSAFE_componentWillMount && r.UNSAFE_componentWillMount(), t !== r.state && zs.enqueueReplaceState(r, r.state, null), Rs(e, n, r, i), r.state = e.memoizedState), "function" === typeof r.componentDidMount && (e.flags |= 4194308) } function Gs(e, t, n) { if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) { if (n._owner) { if (n = n._owner) { if (1 !== n.tag) throw Error(s(309)); var i = n.stateNode } if (!i) throw Error(s(147, e)); var r = i, a = "" + e; return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === a ? t.ref : (t = function (e) { var t = r.refs; t === Bs && (t = r.refs = {}), null === e ? delete t[a] : t[a] = e }, t._stringRef = a, t) } if ("string" !== typeof e) throw Error(s(284)); if (!n._owner) throw Error(s(290, e)) } return e } function Xs(e, t) { throw e = Object.prototype.toString.call(t), Error(s(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function Ks(e) { return (0, e._init)(e._payload) } function $s(e) { function t(t, n) { if (e) { var i = t.deletions; null === i ? (t.deletions = [n], t.flags |= 16) : i.push(n) } } function n(n, i) { if (!e) return null; for (; null !== i;)t(n, i), i = i.sibling; return null } function i(e, t) { for (e = new Map; null !== t;)null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling; return e } function r(e, t) { return (e = jc(e, t)).index = 0, e.sibling = null, e } function a(t, n, i) { return t.index = i, e ? null !== (i = t.alternate) ? (i = i.index) < n ? (t.flags |= 2, n) : i : (t.flags |= 2, n) : (t.flags |= 1048576, n) } function o(t) { return e && null === t.alternate && (t.flags |= 2), t } function l(e, t, n, i) { return null === t || 6 !== t.tag ? ((t = Uc(n, e.mode, i)).return = e, t) : ((t = r(t, n)).return = e, t) } function c(e, t, n, i) { var s = n.type; return s === w ? d(e, t, n.props.children, i, n.key) : null !== t && (t.elementType === s || "object" === typeof s && null !== s && s.$$typeof === A && Ks(s) === t.type) ? ((i = r(t, n.props)).ref = Gs(e, t, n), i.return = e, i) : ((i = Dc(n.type, n.key, n.props, null, e.mode, i)).ref = Gs(e, t, n), i.return = e, i) } function u(e, t, n, i) { return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Bc(n, e.mode, i)).return = e, t) : ((t = r(t, n.children || [])).return = e, t) } function d(e, t, n, i, s) { return null === t || 7 !== t.tag ? ((t = Mc(n, e.mode, i, s)).return = e, t) : ((t = r(t, n)).return = e, t) } function h(e, t, n) { if ("string" === typeof t && "" !== t || "number" === typeof t) return (t = Uc("" + t, e.mode, n)).return = e, t; if ("object" === typeof t && null !== t) { switch (t.$$typeof) { case T: return (n = Dc(t.type, t.key, t.props, null, e.mode, n)).ref = Gs(e, null, t), n.return = e, n; case S: return (t = Bc(t, e.mode, n)).return = e, t; case A: return h(e, (0, t._init)(t._payload), n) }if (te(t) || D(t)) return (t = Mc(t, e.mode, n, null)).return = e, t; Xs(e, t) } return null } function p(e, t, n, i) { var r = null !== t ? t.key : null; if ("string" === typeof n && "" !== n || "number" === typeof n) return null !== r ? null : l(e, t, "" + n, i); if ("object" === typeof n && null !== n) { switch (n.$$typeof) { case T: return n.key === r ? c(e, t, n, i) : null; case S: return n.key === r ? u(e, t, n, i) : null; case A: return p(e, t, (r = n._init)(n._payload), i) }if (te(n) || D(n)) return null !== r ? null : d(e, t, n, i, null); Xs(e, n) } return null } function f(e, t, n, i, r) { if ("string" === typeof i && "" !== i || "number" === typeof i) return l(t, e = e.get(n) || null, "" + i, r); if ("object" === typeof i && null !== i) { switch (i.$$typeof) { case T: return c(t, e = e.get(null === i.key ? n : i.key) || null, i, r); case S: return u(t, e = e.get(null === i.key ? n : i.key) || null, i, r); case A: return f(e, t, n, (0, i._init)(i._payload), r) }if (te(i) || D(i)) return d(t, e = e.get(n) || null, i, r, null); Xs(t, i) } return null } function m(r, s, o, l) { for (var c = null, u = null, d = s, m = s = 0, g = null; null !== d && m < o.length; m++) { d.index > m ? (g = d, d = null) : g = d.sibling; var y = p(r, d, o[m], l); if (null === y) { null === d && (d = g); break } e && d && null === y.alternate && t(r, d), s = a(y, s, m), null === u ? c = y : u.sibling = y, u = y, d = g } if (m === o.length) return n(r, d), rs && Jr(r, m), c; if (null === d) { for (; m < o.length; m++)null !== (d = h(r, o[m], l)) && (s = a(d, s, m), null === u ? c = d : u.sibling = d, u = d); return rs && Jr(r, m), c } for (d = i(r, d); m < o.length; m++)null !== (g = f(d, r, m, o[m], l)) && (e && null !== g.alternate && d.delete(null === g.key ? m : g.key), s = a(g, s, m), null === u ? c = g : u.sibling = g, u = g); return e && d.forEach((function (e) { return t(r, e) })), rs && Jr(r, m), c } function g(r, o, l, c) { var u = D(l); if ("function" !== typeof u) throw Error(s(150)); if (null == (l = u.call(l))) throw Error(s(151)); for (var d = u = null, m = o, g = o = 0, y = null, v = l.next(); null !== m && !v.done; g++, v = l.next()) { m.index > g ? (y = m, m = null) : y = m.sibling; var b = p(r, m, v.value, c); if (null === b) { null === m && (m = y); break } e && m && null === b.alternate && t(r, m), o = a(b, o, g), null === d ? u = b : d.sibling = b, d = b, m = y } if (v.done) return n(r, m), rs && Jr(r, g), u; if (null === m) { for (; !v.done; g++, v = l.next())null !== (v = h(r, v.value, c)) && (o = a(v, o, g), null === d ? u = v : d.sibling = v, d = v); return rs && Jr(r, g), u } for (m = i(r, m); !v.done; g++, v = l.next())null !== (v = f(m, r, g, v.value, c)) && (e && null !== v.alternate && m.delete(null === v.key ? g : v.key), o = a(v, o, g), null === d ? u = v : d.sibling = v, d = v); return e && m.forEach((function (e) { return t(r, e) })), rs && Jr(r, g), u } return function e(i, s, a, l) { if ("object" === typeof a && null !== a && a.type === w && null === a.key && (a = a.props.children), "object" === typeof a && null !== a) { switch (a.$$typeof) { case T: e: { for (var c = a.key, u = s; null !== u;) { if (u.key === c) { if ((c = a.type) === w) { if (7 === u.tag) { n(i, u.sibling), (s = r(u, a.props.children)).return = i, i = s; break e } } else if (u.elementType === c || "object" === typeof c && null !== c && c.$$typeof === A && Ks(c) === u.type) { n(i, u.sibling), (s = r(u, a.props)).ref = Gs(i, u, a), s.return = i, i = s; break e } n(i, u); break } t(i, u), u = u.sibling } a.type === w ? ((s = Mc(a.props.children, i.mode, l, a.key)).return = i, i = s) : ((l = Dc(a.type, a.key, a.props, null, i.mode, l)).ref = Gs(i, s, a), l.return = i, i = l) } return o(i); case S: e: { for (u = a.key; null !== s;) { if (s.key === u) { if (4 === s.tag && s.stateNode.containerInfo === a.containerInfo && s.stateNode.implementation === a.implementation) { n(i, s.sibling), (s = r(s, a.children || [])).return = i, i = s; break e } n(i, s); break } t(i, s), s = s.sibling } (s = Bc(a, i.mode, l)).return = i, i = s } return o(i); case A: return e(i, s, (u = a._init)(a._payload), l) }if (te(a)) return m(i, s, a, l); if (D(a)) return g(i, s, a, l); Xs(i, a) } return "string" === typeof a && "" !== a || "number" === typeof a ? (a = "" + a, null !== s && 6 === s.tag ? (n(i, s.sibling), (s = r(s, a)).return = i, i = s) : (n(i, s), (s = Uc(a, i.mode, l)).return = i, i = s), o(i)) : n(i, s) } } var Ys = $s(!0), Qs = $s(!1), Js = {}, Zs = xr(Js), ea = xr(Js), ta = xr(Js); function na(e) { if (e === Js) throw Error(s(174)); return e } function ia(e, t) { switch (Er(ta, t), Er(ea, e), Er(Zs, Js), e = t.nodeType) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : le(null, ""); break; default: t = le(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName) }kr(Zs), Er(Zs, t) } function ra() { kr(Zs), kr(ea), kr(ta) } function sa(e) { na(ta.current); var t = na(Zs.current), n = le(t, e.type); t !== n && (Er(ea, e), Er(Zs, n)) } function aa(e) { ea.current === e && (kr(Zs), kr(ea)) } var oa = xr(0); function la(e) { for (var t = e; null !== t;) { if (13 === t.tag) { var n = t.memoizedState; if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return t } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) { if (0 !== (128 & t.flags)) return t } else if (null !== t.child) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var ca = []; function ua() { for (var e = 0; e < ca.length; e++)ca[e]._workInProgressVersionPrimary = null; ca.length = 0 } var da = _.ReactCurrentDispatcher, ha = _.ReactCurrentBatchConfig, pa = 0, fa = null, ma = null, ga = null, ya = !1, va = !1, ba = 0, _a = 0; function Ta() { throw Error(s(321)) } function Sa(e, t) { if (null === t) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!oi(e[n], t[n])) return !1; return !0 } function wa(e, t, n, i, r, a) { if (pa = a, fa = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, da.current = null === e || null === e.memoizedState ? ao : oo, e = n(i, r), va) { a = 0; do { if (va = !1, ba = 0, 25 <= a) throw Error(s(301)); a += 1, ga = ma = null, t.updateQueue = null, da.current = lo, e = n(i, r) } while (va) } if (da.current = so, t = null !== ma && null !== ma.next, pa = 0, ga = ma = fa = null, ya = !1, t) throw Error(s(300)); return e } function xa() { var e = 0 !== ba; return ba = 0, e } function ka() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return null === ga ? fa.memoizedState = ga = e : ga = ga.next = e, ga } function Ea() { if (null === ma) { var e = fa.alternate; e = null !== e ? e.memoizedState : null } else e = ma.next; var t = null === ga ? fa.memoizedState : ga.next; if (null !== t) ga = t, ma = e; else { if (null === e) throw Error(s(310)); e = { memoizedState: (ma = e).memoizedState, baseState: ma.baseState, baseQueue: ma.baseQueue, queue: ma.queue, next: null }, null === ga ? fa.memoizedState = ga = e : ga = ga.next = e } return ga } function Ca(e, t) { return "function" === typeof t ? t(e) : t } function Pa(e) { var t = Ea(), n = t.queue; if (null === n) throw Error(s(311)); n.lastRenderedReducer = e; var i = ma, r = i.baseQueue, a = n.pending; if (null !== a) { if (null !== r) { var o = r.next; r.next = a.next, a.next = o } i.baseQueue = r = a, n.pending = null } if (null !== r) { a = r.next, i = i.baseState; var l = o = null, c = null, u = a; do { var d = u.lane; if ((pa & d) === d) null !== c && (c = c.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), i = u.hasEagerState ? u.eagerState : e(i, u.action); else { var h = { lane: d, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; null === c ? (l = c = h, o = i) : c = c.next = h, fa.lanes |= d, Rl |= d } u = u.next } while (null !== u && u !== a); null === c ? o = i : c.next = l, oi(i, t.memoizedState) || (_o = !0), t.memoizedState = i, t.baseState = o, t.baseQueue = c, n.lastRenderedState = i } if (null !== (e = n.interleaved)) { r = e; do { a = r.lane, fa.lanes |= a, Rl |= a, r = r.next } while (r !== e) } else null === r && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Ia(e) { var t = Ea(), n = t.queue; if (null === n) throw Error(s(311)); n.lastRenderedReducer = e; var i = n.dispatch, r = n.pending, a = t.memoizedState; if (null !== r) { n.pending = null; var o = r = r.next; do { a = e(a, o.action), o = o.next } while (o !== r); oi(a, t.memoizedState) || (_o = !0), t.memoizedState = a, null === t.baseQueue && (t.baseState = a), n.lastRenderedState = a } return [a, i] } function La() { } function Oa(e, t) { var n = fa, i = Ea(), r = t(), a = !oi(i.memoizedState, r); if (a && (i.memoizedState = r, _o = !0), i = i.queue, Va(ja.bind(null, n, i, e), [e]), i.getSnapshot !== t || a || null !== ga && 1 & ga.memoizedState.tag) { if (n.flags |= 2048, Ua(9, Na.bind(null, n, i, r, t), void 0, null), null === Ll) throw Error(s(349)); 0 !== (30 & pa) || Aa(n, t, r) } return r } function Aa(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, null === (t = fa.updateQueue) ? (t = { lastEffect: null, stores: null }, fa.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e) } function Na(e, t, n, i) { t.value = n, t.getSnapshot = i, Da(t) && Ma(e) } function ja(e, t, n) { return n((function () { Da(t) && Ma(e) })) } function Da(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !oi(e, n) } catch (i) { return !0 } } function Ma(e) { var t = Is(e, 1); null !== t && ic(t, e, 1, -1) } function Ra(e) { var t = ka(); return "function" === typeof e && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ca, lastRenderedState: e }, t.queue = e, e = e.dispatch = to.bind(null, fa, e), [t.memoizedState, e] } function Ua(e, t, n, i) { return e = { tag: e, create: t, destroy: n, deps: i, next: null }, null === (t = fa.updateQueue) ? (t = { lastEffect: null, stores: null }, fa.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (i = n.next, n.next = e, e.next = i, t.lastEffect = e), e } function Ba() { return Ea().memoizedState } function Fa(e, t, n, i) { var r = ka(); fa.flags |= e, r.memoizedState = Ua(1 | t, n, void 0, void 0 === i ? null : i) } function za(e, t, n, i) { var r = Ea(); i = void 0 === i ? null : i; var s = void 0; if (null !== ma) { var a = ma.memoizedState; if (s = a.destroy, null !== i && Sa(i, a.deps)) return void (r.memoizedState = Ua(t, n, s, i)) } fa.flags |= e, r.memoizedState = Ua(1 | t, n, s, i) } function Ha(e, t) { return Fa(8390656, 8, e, t) } function Va(e, t) { return za(2048, 8, e, t) } function Wa(e, t) { return za(4, 2, e, t) } function qa(e, t) { return za(4, 4, e, t) } function Ga(e, t) { return "function" === typeof t ? (e = e(), t(e), function () { t(null) }) : null !== t && void 0 !== t ? (e = e(), t.current = e, function () { t.current = null }) : void 0 } function Xa(e, t, n) { return n = null !== n && void 0 !== n ? n.concat([e]) : null, za(4, 4, Ga.bind(null, t, e), n) } function Ka() { } function $a(e, t) { var n = Ea(); t = void 0 === t ? null : t; var i = n.memoizedState; return null !== i && null !== t && Sa(t, i[1]) ? i[0] : (n.memoizedState = [e, t], e) } function Ya(e, t) { var n = Ea(); t = void 0 === t ? null : t; var i = n.memoizedState; return null !== i && null !== t && Sa(t, i[1]) ? i[0] : (e = e(), n.memoizedState = [e, t], e) } function Qa(e, t, n) { return 0 === (21 & pa) ? (e.baseState && (e.baseState = !1, _o = !0), e.memoizedState = n) : (oi(n, t) || (n = mt(), fa.lanes |= n, Rl |= n, e.baseState = !0), t) } function Ja(e, t) { var n = bt; bt = 0 !== n && 4 > n ? n : 4, e(!0); var i = ha.transition; ha.transition = {}; try { e(!1), t() } finally { bt = n, ha.transition = i } } function Za() { return Ea().memoizedState } function eo(e, t, n) { var i = nc(e); if (n = { lane: i, action: n, hasEagerState: !1, eagerState: null, next: null }, no(e)) io(t, n); else if (null !== (n = Ps(e, t, n, i))) { ic(n, e, i, tc()), ro(n, t, i) } } function to(e, t, n) { var i = nc(e), r = { lane: i, action: n, hasEagerState: !1, eagerState: null, next: null }; if (no(e)) io(t, r); else { var s = e.alternate; if (0 === e.lanes && (null === s || 0 === s.lanes) && null !== (s = t.lastRenderedReducer)) try { var a = t.lastRenderedState, o = s(a, n); if (r.hasEagerState = !0, r.eagerState = o, oi(o, a)) { var l = t.interleaved; return null === l ? (r.next = r, Cs(t)) : (r.next = l.next, l.next = r), void (t.interleaved = r) } } catch (c) { } null !== (n = Ps(e, t, r, i)) && (ic(n, e, i, r = tc()), ro(n, t, i)) } } function no(e) { var t = e.alternate; return e === fa || null !== t && t === fa } function io(e, t) { va = ya = !0; var n = e.pending; null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function ro(e, t, n) { if (0 !== (4194240 & n)) { var i = t.lanes; n |= i &= e.pendingLanes, t.lanes = n, vt(e, n) } } var so = { readContext: ks, useCallback: Ta, useContext: Ta, useEffect: Ta, useImperativeHandle: Ta, useInsertionEffect: Ta, useLayoutEffect: Ta, useMemo: Ta, useReducer: Ta, useRef: Ta, useState: Ta, useDebugValue: Ta, useDeferredValue: Ta, useTransition: Ta, useMutableSource: Ta, useSyncExternalStore: Ta, useId: Ta, unstable_isNewReconciler: !1 }, ao = { readContext: ks, useCallback: function (e, t) { return ka().memoizedState = [e, void 0 === t ? null : t], e }, useContext: ks, useEffect: Ha, useImperativeHandle: function (e, t, n) { return n = null !== n && void 0 !== n ? n.concat([e]) : null, Fa(4194308, 4, Ga.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Fa(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Fa(4, 2, e, t) }, useMemo: function (e, t) { var n = ka(); return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var i = ka(); return t = void 0 !== n ? n(t) : t, i.memoizedState = i.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, i.queue = e, e = e.dispatch = eo.bind(null, fa, e), [i.memoizedState, e] }, useRef: function (e) { return e = { current: e }, ka().memoizedState = e }, useState: Ra, useDebugValue: Ka, useDeferredValue: function (e) { return ka().memoizedState = e }, useTransition: function () { var e = Ra(!1), t = e[0]; return e = Ja.bind(null, e[1]), ka().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var i = fa, r = ka(); if (rs) { if (void 0 === n) throw Error(s(407)); n = n() } else { if (n = t(), null === Ll) throw Error(s(349)); 0 !== (30 & pa) || Aa(i, t, n) } r.memoizedState = n; var a = { value: n, getSnapshot: t }; return r.queue = a, Ha(ja.bind(null, i, a, e), [e]), i.flags |= 2048, Ua(9, Na.bind(null, i, a, n, t), void 0, null), n }, useId: function () { var e = ka(), t = Ll.identifierPrefix; if (rs) { var n = Qr; t = ":" + t + "R" + (n = (Yr & ~(1 << 32 - at(Yr) - 1)).toString(32) + n), 0 < (n = ba++) && (t += "H" + n.toString(32)), t += ":" } else t = ":" + t + "r" + (n = _a++).toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, oo = { readContext: ks, useCallback: $a, useContext: ks, useEffect: Va, useImperativeHandle: Xa, useInsertionEffect: Wa, useLayoutEffect: qa, useMemo: Ya, useReducer: Pa, useRef: Ba, useState: function () { return Pa(Ca) }, useDebugValue: Ka, useDeferredValue: function (e) { return Qa(Ea(), ma.memoizedState, e) }, useTransition: function () { return [Pa(Ca)[0], Ea().memoizedState] }, useMutableSource: La, useSyncExternalStore: Oa, useId: Za, unstable_isNewReconciler: !1 }, lo = { readContext: ks, useCallback: $a, useContext: ks, useEffect: Va, useImperativeHandle: Xa, useInsertionEffect: Wa, useLayoutEffect: qa, useMemo: Ya, useReducer: Ia, useRef: Ba, useState: function () { return Ia(Ca) }, useDebugValue: Ka, useDeferredValue: function (e) { var t = Ea(); return null === ma ? t.memoizedState = e : Qa(t, ma.memoizedState, e) }, useTransition: function () { return [Ia(Ca)[0], Ea().memoizedState] }, useMutableSource: La, useSyncExternalStore: Oa, useId: Za, unstable_isNewReconciler: !1 }; function co(e, t) { try { var n = "", i = t; do { n += z(i), i = i.return } while (i); var r = n } catch (s) { r = "\nError generating stack: " + s.message + "\n" + s.stack } return { value: e, source: t, stack: r, digest: null } } function uo(e, t, n) { return { value: e, source: null, stack: null != n ? n : null, digest: null != t ? t : null } } function ho(e, t) { try { console.error(t.value) } catch (n) { setTimeout((function () { throw n })) } } var po = "function" === typeof WeakMap ? WeakMap : Map; function fo(e, t, n) { (n = Ns(-1, n)).tag = 3, n.payload = { element: null }; var i = t.value; return n.callback = function () { ql || (ql = !0, Gl = i), ho(0, t) }, n } function mo(e, t, n) { (n = Ns(-1, n)).tag = 3; var i = e.type.getDerivedStateFromError; if ("function" === typeof i) { var r = t.value; n.payload = function () { return i(r) }, n.callback = function () { ho(0, t) } } var s = e.stateNode; return null !== s && "function" === typeof s.componentDidCatch && (n.callback = function () { ho(0, t), "function" !== typeof i && (null === Xl ? Xl = new Set([this]) : Xl.add(this)); var e = t.stack; this.componentDidCatch(t.value, { componentStack: null !== e ? e : "" }) }), n } function go(e, t, n) { var i = e.pingCache; if (null === i) { i = e.pingCache = new po; var r = new Set; i.set(t, r) } else void 0 === (r = i.get(t)) && (r = new Set, i.set(t, r)); r.has(n) || (r.add(n), e = Ec.bind(null, e, t, n), t.then(e, e)) } function yo(e) { do { var t; if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e; e = e.return } while (null !== e); return null } function vo(e, t, n, i, r) { return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = Ns(-1, 1)).tag = 2, js(n, t, 1))), n.lanes |= 1), e) : (e.flags |= 65536, e.lanes = r, e) } var bo = _.ReactCurrentOwner, _o = !1; function To(e, t, n, i) { t.child = null === e ? Qs(t, null, n, i) : Ys(t, e.child, n, i) } function So(e, t, n, i, r) { n = n.render; var s = t.ref; return xs(t, r), i = wa(e, t, n, i, s, r), n = xa(), null === e || _o ? (rs && n && es(t), t.flags |= 1, To(e, t, i, r), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~r, qo(e, t, r)) } function wo(e, t, n, i, r) { if (null === e) { var s = n.type; return "function" !== typeof s || Nc(s) || void 0 !== s.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Dc(n.type, null, i, t, t.mode, r)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = s, xo(e, t, s, i, r)) } if (s = e.child, 0 === (e.lanes & r)) { var a = s.memoizedProps; if ((n = null !== (n = n.compare) ? n : li)(a, i) && e.ref === t.ref) return qo(e, t, r) } return t.flags |= 1, (e = jc(s, i)).ref = t.ref, e.return = t, t.child = e } function xo(e, t, n, i, r) { if (null !== e) { var s = e.memoizedProps; if (li(s, i) && e.ref === t.ref) { if (_o = !1, t.pendingProps = i = s, 0 === (e.lanes & r)) return t.lanes = e.lanes, qo(e, t, r); 0 !== (131072 & e.flags) && (_o = !0) } } return Co(e, t, n, i, r) } function ko(e, t, n) { var i = t.pendingProps, r = i.children, s = null !== e ? e.memoizedState : null; if ("hidden" === i.mode) if (0 === (1 & t.mode)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Er(jl, Nl), Nl |= n; else { if (0 === (1073741824 & n)) return e = null !== s ? s.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Er(jl, Nl), Nl |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, i = null !== s ? s.baseLanes : n, Er(jl, Nl), Nl |= i } else null !== s ? (i = s.baseLanes | n, t.memoizedState = null) : i = n, Er(jl, Nl), Nl |= i; return To(e, t, r, n), t.child } function Eo(e, t) { var n = t.ref; (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function Co(e, t, n, i, r) { var s = Ar(n) ? Lr : Pr.current; return s = Or(t, s), xs(t, r), n = wa(e, t, n, i, s, r), i = xa(), null === e || _o ? (rs && i && es(t), t.flags |= 1, To(e, t, n, r), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~r, qo(e, t, r)) } function Po(e, t, n, i, r) { if (Ar(n)) { var s = !0; Mr(t) } else s = !1; if (xs(t, r), null === t.stateNode) Wo(e, t), Vs(t, n, i), qs(t, n, i, r), i = !0; else if (null === e) { var a = t.stateNode, o = t.memoizedProps; a.props = o; var l = a.context, c = n.contextType; "object" === typeof c && null !== c ? c = ks(c) : c = Or(t, c = Ar(n) ? Lr : Pr.current); var u = n.getDerivedStateFromProps, d = "function" === typeof u || "function" === typeof a.getSnapshotBeforeUpdate; d || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (o !== i || l !== c) && Ws(t, a, i, c), Ls = !1; var h = t.memoizedState; a.state = h, Rs(t, i, a, r), l = t.memoizedState, o !== i || h !== l || Ir.current || Ls ? ("function" === typeof u && (Fs(t, n, u, i), l = t.memoizedState), (o = Ls || Hs(t, n, o, i, h, l, c)) ? (d || "function" !== typeof a.UNSAFE_componentWillMount && "function" !== typeof a.componentWillMount || ("function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount()), "function" === typeof a.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308), t.memoizedProps = i, t.memoizedState = l), a.props = i, a.state = l, a.context = c, i = o) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308), i = !1) } else { a = t.stateNode, As(e, t), o = t.memoizedProps, c = t.type === t.elementType ? o : gs(t.type, o), a.props = c, d = t.pendingProps, h = a.context, "object" === typeof (l = n.contextType) && null !== l ? l = ks(l) : l = Or(t, l = Ar(n) ? Lr : Pr.current); var p = n.getDerivedStateFromProps; (u = "function" === typeof p || "function" === typeof a.getSnapshotBeforeUpdate) || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (o !== d || h !== l) && Ws(t, a, i, l), Ls = !1, h = t.memoizedState, a.state = h, Rs(t, i, a, r); var f = t.memoizedState; o !== d || h !== f || Ir.current || Ls ? ("function" === typeof p && (Fs(t, n, p, i), f = t.memoizedState), (c = Ls || Hs(t, n, c, i, h, f, l) || !1) ? (u || "function" !== typeof a.UNSAFE_componentWillUpdate && "function" !== typeof a.componentWillUpdate || ("function" === typeof a.componentWillUpdate && a.componentWillUpdate(i, f, l), "function" === typeof a.UNSAFE_componentWillUpdate && a.UNSAFE_componentWillUpdate(i, f, l)), "function" === typeof a.componentDidUpdate && (t.flags |= 4), "function" === typeof a.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof a.componentDidUpdate || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = i, t.memoizedState = f), a.props = i, a.state = f, a.context = l, i = c) : ("function" !== typeof a.componentDidUpdate || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || o === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), i = !1) } return Io(e, t, n, i, s, r) } function Io(e, t, n, i, r, s) { Eo(e, t); var a = 0 !== (128 & t.flags); if (!i && !a) return r && Rr(t, n, !1), qo(e, t, s); i = t.stateNode, bo.current = t; var o = a && "function" !== typeof n.getDerivedStateFromError ? null : i.render(); return t.flags |= 1, null !== e && a ? (t.child = Ys(t, e.child, null, s), t.child = Ys(t, null, o, s)) : To(e, t, o, s), t.memoizedState = i.state, r && Rr(t, n, !0), t.child } function Lo(e) { var t = e.stateNode; t.pendingContext ? jr(0, t.pendingContext, t.pendingContext !== t.context) : t.context && jr(0, t.context, !1), ia(e, t.containerInfo) } function Oo(e, t, n, i, r) { return ps(), fs(r), t.flags |= 256, To(e, t, n, i), t.child } var Ao, No, jo, Do, Mo = { dehydrated: null, treeContext: null, retryLane: 0 }; function Ro(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Uo(e, t, n) { var i, r = t.pendingProps, a = oa.current, o = !1, l = 0 !== (128 & t.flags); if ((i = l) || (i = (null === e || null !== e.memoizedState) && 0 !== (2 & a)), i ? (o = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (a |= 1), Er(oa, 1 & a), null === e) return cs(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824, null) : (l = r.children, e = r.fallback, o ? (r = t.mode, o = t.child, l = { mode: "hidden", children: l }, 0 === (1 & r) && null !== o ? (o.childLanes = 0, o.pendingProps = l) : o = Rc(l, r, 0, null), e = Mc(e, r, n, null), o.return = t, e.return = t, o.sibling = e, t.child = o, t.child.memoizedState = Ro(n), t.memoizedState = Mo, e) : Bo(t, l)); if (null !== (a = e.memoizedState) && null !== (i = a.dehydrated)) return function (e, t, n, i, r, a, o) { if (n) return 256 & t.flags ? (t.flags &= -257, Fo(e, t, o, i = uo(Error(s(422))))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (a = i.fallback, r = t.mode, i = Rc({ mode: "visible", children: i.children }, r, 0, null), (a = Mc(a, r, o, null)).flags |= 2, i.return = t, a.return = t, i.sibling = a, t.child = i, 0 !== (1 & t.mode) && Ys(t, e.child, null, o), t.child.memoizedState = Ro(o), t.memoizedState = Mo, a); if (0 === (1 & t.mode)) return Fo(e, t, o, null); if ("$!" === r.data) { if (i = r.nextSibling && r.nextSibling.dataset) var l = i.dgst; return i = l, Fo(e, t, o, i = uo(a = Error(s(419)), i, void 0)) } if (l = 0 !== (o & e.childLanes), _o || l) { if (null !== (i = Ll)) { switch (o & -o) { case 4: r = 2; break; case 16: r = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: r = 32; break; case 536870912: r = 268435456; break; default: r = 0 }0 !== (r = 0 !== (r & (i.suspendedLanes | o)) ? 0 : r) && r !== a.retryLane && (a.retryLane = r, Is(e, r), ic(i, e, r, -1)) } return gc(), Fo(e, t, o, i = uo(Error(s(421)))) } return "$?" === r.data ? (t.flags |= 128, t.child = e.child, t = Pc.bind(null, e), r._reactRetry = t, null) : (e = a.treeContext, is = cr(r.nextSibling), ns = t, rs = !0, ss = null, null !== e && (Xr[Kr++] = Yr, Xr[Kr++] = Qr, Xr[Kr++] = $r, Yr = e.id, Qr = e.overflow, $r = t), t = Bo(t, i.children), t.flags |= 4096, t) }(e, t, l, r, i, a, n); if (o) { o = r.fallback, l = t.mode, i = (a = e.child).sibling; var c = { mode: "hidden", children: r.children }; return 0 === (1 & l) && t.child !== a ? ((r = t.child).childLanes = 0, r.pendingProps = c, t.deletions = null) : (r = jc(a, c)).subtreeFlags = 14680064 & a.subtreeFlags, null !== i ? o = jc(i, o) : (o = Mc(o, l, n, null)).flags |= 2, o.return = t, r.return = t, r.sibling = o, t.child = r, r = o, o = t.child, l = null === (l = e.child.memoizedState) ? Ro(n) : { baseLanes: l.baseLanes | n, cachePool: null, transitions: l.transitions }, o.memoizedState = l, o.childLanes = e.childLanes & ~n, t.memoizedState = Mo, r } return e = (o = e.child).sibling, r = jc(o, { mode: "visible", children: r.children }), 0 === (1 & t.mode) && (r.lanes = n), r.return = t, r.sibling = null, null !== e && (null === (n = t.deletions) ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r } function Bo(e, t) { return (t = Rc({ mode: "visible", children: t }, e.mode, 0, null)).return = e, e.child = t } function Fo(e, t, n, i) { return null !== i && fs(i), Ys(t, e.child, null, n), (e = Bo(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e } function zo(e, t, n) { e.lanes |= t; var i = e.alternate; null !== i && (i.lanes |= t), ws(e.return, t, n) } function Ho(e, t, n, i, r) { var s = e.memoizedState; null === s ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: i, tail: n, tailMode: r } : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = i, s.tail = n, s.tailMode = r) } function Vo(e, t, n) { var i = t.pendingProps, r = i.revealOrder, s = i.tail; if (To(e, t, i.children, n), 0 !== (2 & (i = oa.current))) i = 1 & i | 2, t.flags |= 128; else { if (null !== e && 0 !== (128 & e.flags)) e: for (e = t.child; null !== e;) { if (13 === e.tag) null !== e.memoizedState && zo(e, n, t); else if (19 === e.tag) zo(e, n, t); else if (null !== e.child) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; null === e.sibling;) { if (null === e.return || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } i &= 1 } if (Er(oa, i), 0 === (1 & t.mode)) t.memoizedState = null; else switch (r) { case "forwards": for (n = t.child, r = null; null !== n;)null !== (e = n.alternate) && null === la(e) && (r = n), n = n.sibling; null === (n = r) ? (r = t.child, t.child = null) : (r = n.sibling, n.sibling = null), Ho(t, !1, r, n, s); break; case "backwards": for (n = null, r = t.child, t.child = null; null !== r;) { if (null !== (e = r.alternate) && null === la(e)) { t.child = r; break } e = r.sibling, r.sibling = n, n = r, r = e } Ho(t, !0, n, null, s); break; case "together": Ho(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Wo(e, t) { 0 === (1 & t.mode) && null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2) } function qo(e, t, n) { if (null !== e && (t.dependencies = e.dependencies), Rl |= t.lanes, 0 === (n & t.childLanes)) return null; if (null !== e && t.child !== e.child) throw Error(s(153)); if (null !== t.child) { for (n = jc(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;)e = e.sibling, (n = n.sibling = jc(e, e.pendingProps)).return = t; n.sibling = null } return t.child } function Go(e, t) { if (!rs) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; null !== t;)null !== t.alternate && (n = t), t = t.sibling; null === n ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var i = null; null !== n;)null !== n.alternate && (i = n), n = n.sibling; null === i ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : i.sibling = null } } function Xo(e) { var t = null !== e.alternate && e.alternate.child === e.child, n = 0, i = 0; if (t) for (var r = e.child; null !== r;)n |= r.lanes | r.childLanes, i |= 14680064 & r.subtreeFlags, i |= 14680064 & r.flags, r.return = e, r = r.sibling; else for (r = e.child; null !== r;)n |= r.lanes | r.childLanes, i |= r.subtreeFlags, i |= r.flags, r.return = e, r = r.sibling; return e.subtreeFlags |= i, e.childLanes = n, t } function Ko(e, t, n) { var i = t.pendingProps; switch (ts(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Xo(t), null; case 1: case 17: return Ar(t.type) && Nr(), Xo(t), null; case 3: return i = t.stateNode, ra(), kr(Ir), kr(Pr), ua(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), null !== e && null !== e.child || (ds(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024, null !== ss && (oc(ss), ss = null))), No(e, t), Xo(t), null; case 5: aa(t); var r = na(ta.current); if (n = t.type, null !== e && null != t.stateNode) jo(e, t, n, i, r), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!i) { if (null === t.stateNode) throw Error(s(166)); return Xo(t), null } if (e = na(Zs.current), ds(t)) { i = t.stateNode, n = t.type; var a = t.memoizedProps; switch (i[hr] = t, i[pr] = a, e = 0 !== (1 & t.mode), n) { case "dialog": Bi("cancel", i), Bi("close", i); break; case "iframe": case "object": case "embed": Bi("load", i); break; case "video": case "audio": for (r = 0; r < Di.length; r++)Bi(Di[r], i); break; case "source": Bi("error", i); break; case "img": case "image": case "link": Bi("error", i), Bi("load", i); break; case "details": Bi("toggle", i); break; case "input": Y(i, a), Bi("invalid", i); break; case "select": i._wrapperState = { wasMultiple: !!a.multiple }, Bi("invalid", i); break; case "textarea": re(i, a), Bi("invalid", i) }for (var l in ve(n, a), r = null, a) if (a.hasOwnProperty(l)) { var c = a[l]; "children" === l ? "string" === typeof c ? i.textContent !== c && (!0 !== a.suppressHydrationWarning && Ji(i.textContent, c, e), r = ["children", c]) : "number" === typeof c && i.textContent !== "" + c && (!0 !== a.suppressHydrationWarning && Ji(i.textContent, c, e), r = ["children", "" + c]) : o.hasOwnProperty(l) && null != c && "onScroll" === l && Bi("scroll", i) } switch (n) { case "input": G(i), Z(i, a, !0); break; case "textarea": G(i), ae(i); break; case "select": case "option": break; default: "function" === typeof a.onClick && (i.onclick = Zi) }i = r, t.updateQueue = i, null !== i && (t.flags |= 4) } else { l = 9 === r.nodeType ? r : r.ownerDocument, "http://www.w3.org/1999/xhtml" === e && (e = oe(n)), "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = l.createElement("div")).innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : "string" === typeof i.is ? e = l.createElement(n, { is: i.is }) : (e = l.createElement(n), "select" === n && (l = e, i.multiple ? l.multiple = !0 : i.size && (l.size = i.size))) : e = l.createElementNS(e, n), e[hr] = t, e[pr] = i, Ao(e, t, !1, !1), t.stateNode = e; e: { switch (l = be(n, i), n) { case "dialog": Bi("cancel", e), Bi("close", e), r = i; break; case "iframe": case "object": case "embed": Bi("load", e), r = i; break; case "video": case "audio": for (r = 0; r < Di.length; r++)Bi(Di[r], e); r = i; break; case "source": Bi("error", e), r = i; break; case "img": case "image": case "link": Bi("error", e), Bi("load", e), r = i; break; case "details": Bi("toggle", e), r = i; break; case "input": Y(e, i), r = $(e, i), Bi("invalid", e); break; case "option": default: r = i; break; case "select": e._wrapperState = { wasMultiple: !!i.multiple }, r = R({}, i, { value: void 0 }), Bi("invalid", e); break; case "textarea": re(e, i), r = ie(e, i), Bi("invalid", e) }for (a in ve(n, r), c = r) if (c.hasOwnProperty(a)) { var u = c[a]; "style" === a ? ge(e, u) : "dangerouslySetInnerHTML" === a ? null != (u = u ? u.__html : void 0) && de(e, u) : "children" === a ? "string" === typeof u ? ("textarea" !== n || "" !== u) && he(e, u) : "number" === typeof u && he(e, "" + u) : "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && "autoFocus" !== a && (o.hasOwnProperty(a) ? null != u && "onScroll" === a && Bi("scroll", e) : null != u && b(e, a, u, l)) } switch (n) { case "input": G(e), Z(e, i, !1); break; case "textarea": G(e), ae(e); break; case "option": null != i.value && e.setAttribute("value", "" + W(i.value)); break; case "select": e.multiple = !!i.multiple, null != (a = i.value) ? ne(e, !!i.multiple, a, !1) : null != i.defaultValue && ne(e, !!i.multiple, i.defaultValue, !0); break; default: "function" === typeof r.onClick && (e.onclick = Zi) }switch (n) { case "button": case "input": case "select": case "textarea": i = !!i.autoFocus; break e; case "img": i = !0; break e; default: i = !1 } } i && (t.flags |= 4) } null !== t.ref && (t.flags |= 512, t.flags |= 2097152) } return Xo(t), null; case 6: if (e && null != t.stateNode) Do(e, t, e.memoizedProps, i); else { if ("string" !== typeof i && null === t.stateNode) throw Error(s(166)); if (n = na(ta.current), na(Zs.current), ds(t)) { if (i = t.stateNode, n = t.memoizedProps, i[hr] = t, (a = i.nodeValue !== n) && null !== (e = ns)) switch (e.tag) { case 3: Ji(i.nodeValue, n, 0 !== (1 & e.mode)); break; case 5: !0 !== e.memoizedProps.suppressHydrationWarning && Ji(i.nodeValue, n, 0 !== (1 & e.mode)) }a && (t.flags |= 4) } else (i = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(i))[hr] = t, t.stateNode = i } return Xo(t), null; case 13: if (kr(oa), i = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) { if (rs && null !== is && 0 !== (1 & t.mode) && 0 === (128 & t.flags)) hs(), ps(), t.flags |= 98560, a = !1; else if (a = ds(t), null !== i && null !== i.dehydrated) { if (null === e) { if (!a) throw Error(s(318)); if (!(a = null !== (a = t.memoizedState) ? a.dehydrated : null)) throw Error(s(317)); a[hr] = t } else ps(), 0 === (128 & t.flags) && (t.memoizedState = null), t.flags |= 4; Xo(t), a = !1 } else null !== ss && (oc(ss), ss = null), a = !0; if (!a) return 65536 & t.flags ? t : null } return 0 !== (128 & t.flags) ? (t.lanes = n, t) : ((i = null !== i) !== (null !== e && null !== e.memoizedState) && i && (t.child.flags |= 8192, 0 !== (1 & t.mode) && (null === e || 0 !== (1 & oa.current) ? 0 === Dl && (Dl = 3) : gc())), null !== t.updateQueue && (t.flags |= 4), Xo(t), null); case 4: return ra(), No(e, t), null === e && Hi(t.stateNode.containerInfo), Xo(t), null; case 10: return Ss(t.type._context), Xo(t), null; case 19: if (kr(oa), null === (a = t.memoizedState)) return Xo(t), null; if (i = 0 !== (128 & t.flags), null === (l = a.rendering)) if (i) Go(a, !1); else { if (0 !== Dl || null !== e && 0 !== (128 & e.flags)) for (e = t.child; null !== e;) { if (null !== (l = la(e))) { for (t.flags |= 128, Go(a, !1), null !== (i = l.updateQueue) && (t.updateQueue = i, t.flags |= 4), t.subtreeFlags = 0, i = n, n = t.child; null !== n;)e = i, (a = n).flags &= 14680066, null === (l = a.alternate) ? (a.childLanes = 0, a.lanes = e, a.child = null, a.subtreeFlags = 0, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null) : (a.childLanes = l.childLanes, a.lanes = l.lanes, a.child = l.child, a.subtreeFlags = 0, a.deletions = null, a.memoizedProps = l.memoizedProps, a.memoizedState = l.memoizedState, a.updateQueue = l.updateQueue, a.type = l.type, e = l.dependencies, a.dependencies = null === e ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return Er(oa, 1 & oa.current | 2), t.child } e = e.sibling } null !== a.tail && Qe() > Vl && (t.flags |= 128, i = !0, Go(a, !1), t.lanes = 4194304) } else { if (!i) if (null !== (e = la(l))) { if (t.flags |= 128, i = !0, null !== (n = e.updateQueue) && (t.updateQueue = n, t.flags |= 4), Go(a, !0), null === a.tail && "hidden" === a.tailMode && !l.alternate && !rs) return Xo(t), null } else 2 * Qe() - a.renderingStartTime > Vl && 1073741824 !== n && (t.flags |= 128, i = !0, Go(a, !1), t.lanes = 4194304); a.isBackwards ? (l.sibling = t.child, t.child = l) : (null !== (n = a.last) ? n.sibling = l : t.child = l, a.last = l) } return null !== a.tail ? (t = a.tail, a.rendering = t, a.tail = t.sibling, a.renderingStartTime = Qe(), t.sibling = null, n = oa.current, Er(oa, i ? 1 & n | 2 : 1 & n), t) : (Xo(t), null); case 22: case 23: return hc(), i = null !== t.memoizedState, null !== e && null !== e.memoizedState !== i && (t.flags |= 8192), i && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Nl) && (Xo(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Xo(t), null; case 24: case 25: return null }throw Error(s(156, t.tag)) } function $o(e, t) { switch (ts(t), t.tag) { case 1: return Ar(t.type) && Nr(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 3: return ra(), kr(Ir), kr(Pr), ua(), 0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128, t) : null; case 5: return aa(t), null; case 13: if (kr(oa), null !== (e = t.memoizedState) && null !== e.dehydrated) { if (null === t.alternate) throw Error(s(340)); ps() } return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 19: return kr(oa), null; case 4: return ra(), null; case 10: return Ss(t.type._context), null; case 22: case 23: return hc(), null; default: return null } } Ao = function (e, t) { for (var n = t.child; null !== n;) { if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode); else if (4 !== n.tag && null !== n.child) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; null === n.sibling;) { if (null === n.return || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }, No = function () { }, jo = function (e, t, n, i) { var r = e.memoizedProps; if (r !== i) { e = t.stateNode, na(Zs.current); var s, a = null; switch (n) { case "input": r = $(e, r), i = $(e, i), a = []; break; case "select": r = R({}, r, { value: void 0 }), i = R({}, i, { value: void 0 }), a = []; break; case "textarea": r = ie(e, r), i = ie(e, i), a = []; break; default: "function" !== typeof r.onClick && "function" === typeof i.onClick && (e.onclick = Zi) }for (u in ve(n, i), n = null, r) if (!i.hasOwnProperty(u) && r.hasOwnProperty(u) && null != r[u]) if ("style" === u) { var l = r[u]; for (s in l) l.hasOwnProperty(s) && (n || (n = {}), n[s] = "") } else "dangerouslySetInnerHTML" !== u && "children" !== u && "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && "autoFocus" !== u && (o.hasOwnProperty(u) ? a || (a = []) : (a = a || []).push(u, null)); for (u in i) { var c = i[u]; if (l = null != r ? r[u] : void 0, i.hasOwnProperty(u) && c !== l && (null != c || null != l)) if ("style" === u) if (l) { for (s in l) !l.hasOwnProperty(s) || c && c.hasOwnProperty(s) || (n || (n = {}), n[s] = ""); for (s in c) c.hasOwnProperty(s) && l[s] !== c[s] && (n || (n = {}), n[s] = c[s]) } else n || (a || (a = []), a.push(u, n)), n = c; else "dangerouslySetInnerHTML" === u ? (c = c ? c.__html : void 0, l = l ? l.__html : void 0, null != c && l !== c && (a = a || []).push(u, c)) : "children" === u ? "string" !== typeof c && "number" !== typeof c || (a = a || []).push(u, "" + c) : "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && (o.hasOwnProperty(u) ? (null != c && "onScroll" === u && Bi("scroll", e), a || l === c || (a = [])) : (a = a || []).push(u, c)) } n && (a = a || []).push("style", n); var u = a; (t.updateQueue = u) && (t.flags |= 4) } }, Do = function (e, t, n, i) { n !== i && (t.flags |= 4) }; var Yo = !1, Qo = !1, Jo = "function" === typeof WeakSet ? WeakSet : Set, Zo = null; function el(e, t) { var n = e.ref; if (null !== n) if ("function" === typeof n) try { n(null) } catch (i) { kc(e, t, i) } else n.current = null } function tl(e, t, n) { try { n() } catch (i) { kc(e, t, i) } } var nl = !1; function il(e, t, n) { var i = t.updateQueue; if (null !== (i = null !== i ? i.lastEffect : null)) { var r = i = i.next; do { if ((r.tag & e) === e) { var s = r.destroy; r.destroy = void 0, void 0 !== s && tl(t, n, s) } r = r.next } while (r !== i) } } function rl(e, t) { if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) { var n = t = t.next; do { if ((n.tag & e) === e) { var i = n.create; n.destroy = i() } n = n.next } while (n !== t) } } function sl(e) { var t = e.ref; if (null !== t) { var n = e.stateNode; e.tag, e = n, "function" === typeof t ? t(e) : t.current = e } } function al(e) { var t = e.alternate; null !== t && (e.alternate = null, al(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && (null !== (t = e.stateNode) && (delete t[hr], delete t[pr], delete t[mr], delete t[gr], delete t[yr])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function ol(e) { return 5 === e.tag || 3 === e.tag || 4 === e.tag } function ll(e) { e: for (; ;) { for (; null === e.sibling;) { if (null === e.return || ol(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) { if (2 & e.flags) continue e; if (null === e.child || 4 === e.tag) continue e; e.child.return = e, e = e.child } if (!(2 & e.flags)) return e.stateNode } } function cl(e, t, n) { var i = e.tag; if (5 === i || 6 === i) e = e.stateNode, t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e), null !== (n = n._reactRootContainer) && void 0 !== n || null !== t.onclick || (t.onclick = Zi)); else if (4 !== i && null !== (e = e.child)) for (cl(e, t, n), e = e.sibling; null !== e;)cl(e, t, n), e = e.sibling } function ul(e, t, n) { var i = e.tag; if (5 === i || 6 === i) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (4 !== i && null !== (e = e.child)) for (ul(e, t, n), e = e.sibling; null !== e;)ul(e, t, n), e = e.sibling } var dl = null, hl = !1; function pl(e, t, n) { for (n = n.child; null !== n;)fl(e, t, n), n = n.sibling } function fl(e, t, n) { if (st && "function" === typeof st.onCommitFiberUnmount) try { st.onCommitFiberUnmount(rt, n) } catch (o) { } switch (n.tag) { case 5: Qo || el(n, t); case 6: var i = dl, r = hl; dl = null, pl(e, t, n), hl = r, null !== (dl = i) && (hl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : dl.removeChild(n.stateNode)); break; case 18: null !== dl && (hl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? lr(e.parentNode, n) : 1 === e.nodeType && lr(e, n), Ht(e)) : lr(dl, n.stateNode)); break; case 4: i = dl, r = hl, dl = n.stateNode.containerInfo, hl = !0, pl(e, t, n), dl = i, hl = r; break; case 0: case 11: case 14: case 15: if (!Qo && (null !== (i = n.updateQueue) && null !== (i = i.lastEffect))) { r = i = i.next; do { var s = r, a = s.destroy; s = s.tag, void 0 !== a && (0 !== (2 & s) || 0 !== (4 & s)) && tl(n, t, a), r = r.next } while (r !== i) } pl(e, t, n); break; case 1: if (!Qo && (el(n, t), "function" === typeof (i = n.stateNode).componentWillUnmount)) try { i.props = n.memoizedProps, i.state = n.memoizedState, i.componentWillUnmount() } catch (o) { kc(n, t, o) } pl(e, t, n); break; case 21: pl(e, t, n); break; case 22: 1 & n.mode ? (Qo = (i = Qo) || null !== n.memoizedState, pl(e, t, n), Qo = i) : pl(e, t, n); break; default: pl(e, t, n) } } function ml(e) { var t = e.updateQueue; if (null !== t) { e.updateQueue = null; var n = e.stateNode; null === n && (n = e.stateNode = new Jo), t.forEach((function (t) { var i = Ic.bind(null, e, t); n.has(t) || (n.add(t), t.then(i, i)) })) } } function gl(e, t) { var n = t.deletions; if (null !== n) for (var i = 0; i < n.length; i++) { var r = n[i]; try { var a = e, o = t, l = o; e: for (; null !== l;) { switch (l.tag) { case 5: dl = l.stateNode, hl = !1; break e; case 3: case 4: dl = l.stateNode.containerInfo, hl = !0; break e }l = l.return } if (null === dl) throw Error(s(160)); fl(a, o, r), dl = null, hl = !1; var c = r.alternate; null !== c && (c.return = null), r.return = null } catch (u) { kc(r, t, u) } } if (12854 & t.subtreeFlags) for (t = t.child; null !== t;)yl(t, e), t = t.sibling } function yl(e, t) { var n = e.alternate, i = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (gl(t, e), vl(e), 4 & i) { try { il(3, e, e.return), rl(3, e) } catch (g) { kc(e, e.return, g) } try { il(5, e, e.return) } catch (g) { kc(e, e.return, g) } } break; case 1: gl(t, e), vl(e), 512 & i && null !== n && el(n, n.return); break; case 5: if (gl(t, e), vl(e), 512 & i && null !== n && el(n, n.return), 32 & e.flags) { var r = e.stateNode; try { he(r, "") } catch (g) { kc(e, e.return, g) } } if (4 & i && null != (r = e.stateNode)) { var a = e.memoizedProps, o = null !== n ? n.memoizedProps : a, l = e.type, c = e.updateQueue; if (e.updateQueue = null, null !== c) try { "input" === l && "radio" === a.type && null != a.name && Q(r, a), be(l, o); var u = be(l, a); for (o = 0; o < c.length; o += 2) { var d = c[o], h = c[o + 1]; "style" === d ? ge(r, h) : "dangerouslySetInnerHTML" === d ? de(r, h) : "children" === d ? he(r, h) : b(r, d, h, u) } switch (l) { case "input": J(r, a); break; case "textarea": se(r, a); break; case "select": var p = r._wrapperState.wasMultiple; r._wrapperState.wasMultiple = !!a.multiple; var f = a.value; null != f ? ne(r, !!a.multiple, f, !1) : p !== !!a.multiple && (null != a.defaultValue ? ne(r, !!a.multiple, a.defaultValue, !0) : ne(r, !!a.multiple, a.multiple ? [] : "", !1)) }r[pr] = a } catch (g) { kc(e, e.return, g) } } break; case 6: if (gl(t, e), vl(e), 4 & i) { if (null === e.stateNode) throw Error(s(162)); r = e.stateNode, a = e.memoizedProps; try { r.nodeValue = a } catch (g) { kc(e, e.return, g) } } break; case 3: if (gl(t, e), vl(e), 4 & i && null !== n && n.memoizedState.isDehydrated) try { Ht(t.containerInfo) } catch (g) { kc(e, e.return, g) } break; case 4: default: gl(t, e), vl(e); break; case 13: gl(t, e), vl(e), 8192 & (r = e.child).flags && (a = null !== r.memoizedState, r.stateNode.isHidden = a, !a || null !== r.alternate && null !== r.alternate.memoizedState || (Hl = Qe())), 4 & i && ml(e); break; case 22: if (d = null !== n && null !== n.memoizedState, 1 & e.mode ? (Qo = (u = Qo) || d, gl(t, e), Qo = u) : gl(t, e), vl(e), 8192 & i) { if (u = null !== e.memoizedState, (e.stateNode.isHidden = u) && !d && 0 !== (1 & e.mode)) for (Zo = e, d = e.child; null !== d;) { for (h = Zo = d; null !== Zo;) { switch (f = (p = Zo).child, p.tag) { case 0: case 11: case 14: case 15: il(4, p, p.return); break; case 1: el(p, p.return); var m = p.stateNode; if ("function" === typeof m.componentWillUnmount) { i = p, n = p.return; try { t = i, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount() } catch (g) { kc(i, n, g) } } break; case 5: el(p, p.return); break; case 22: if (null !== p.memoizedState) { Sl(h); continue } }null !== f ? (f.return = p, Zo = f) : Sl(h) } d = d.sibling } e: for (d = null, h = e; ;) { if (5 === h.tag) { if (null === d) { d = h; try { r = h.stateNode, u ? "function" === typeof (a = r.style).setProperty ? a.setProperty("display", "none", "important") : a.display = "none" : (l = h.stateNode, o = void 0 !== (c = h.memoizedProps.style) && null !== c && c.hasOwnProperty("display") ? c.display : null, l.style.display = me("display", o)) } catch (g) { kc(e, e.return, g) } } } else if (6 === h.tag) { if (null === d) try { h.stateNode.nodeValue = u ? "" : h.memoizedProps } catch (g) { kc(e, e.return, g) } } else if ((22 !== h.tag && 23 !== h.tag || null === h.memoizedState || h === e) && null !== h.child) { h.child.return = h, h = h.child; continue } if (h === e) break e; for (; null === h.sibling;) { if (null === h.return || h.return === e) break e; d === h && (d = null), h = h.return } d === h && (d = null), h.sibling.return = h.return, h = h.sibling } } break; case 19: gl(t, e), vl(e), 4 & i && ml(e); case 21: } } function vl(e) { var t = e.flags; if (2 & t) { try { e: { for (var n = e.return; null !== n;) { if (ol(n)) { var i = n; break e } n = n.return } throw Error(s(160)) } switch (i.tag) { case 5: var r = i.stateNode; 32 & i.flags && (he(r, ""), i.flags &= -33), ul(e, ll(e), r); break; case 3: case 4: var a = i.stateNode.containerInfo; cl(e, ll(e), a); break; default: throw Error(s(161)) } } catch (o) { kc(e, e.return, o) } e.flags &= -3 } 4096 & t && (e.flags &= -4097) } function bl(e, t, n) { Zo = e, _l(e, t, n) } function _l(e, t, n) { for (var i = 0 !== (1 & e.mode); null !== Zo;) { var r = Zo, s = r.child; if (22 === r.tag && i) { var a = null !== r.memoizedState || Yo; if (!a) { var o = r.alternate, l = null !== o && null !== o.memoizedState || Qo; o = Yo; var c = Qo; if (Yo = a, (Qo = l) && !c) for (Zo = r; null !== Zo;)l = (a = Zo).child, 22 === a.tag && null !== a.memoizedState ? wl(r) : null !== l ? (l.return = a, Zo = l) : wl(r); for (; null !== s;)Zo = s, _l(s, t, n), s = s.sibling; Zo = r, Yo = o, Qo = c } Tl(e) } else 0 !== (8772 & r.subtreeFlags) && null !== s ? (s.return = r, Zo = s) : Tl(e) } } function Tl(e) { for (; null !== Zo;) { var t = Zo; if (0 !== (8772 & t.flags)) { var n = t.alternate; try { if (0 !== (8772 & t.flags)) switch (t.tag) { case 0: case 11: case 15: Qo || rl(5, t); break; case 1: var i = t.stateNode; if (4 & t.flags && !Qo) if (null === n) i.componentDidMount(); else { var r = t.elementType === t.type ? n.memoizedProps : gs(t.type, n.memoizedProps); i.componentDidUpdate(r, n.memoizedState, i.__reactInternalSnapshotBeforeUpdate) } var a = t.updateQueue; null !== a && Us(t, a, i); break; case 3: var o = t.updateQueue; if (null !== o) { if (n = null, null !== t.child) switch (t.child.tag) { case 5: case 1: n = t.child.stateNode }Us(t, o, n) } break; case 5: var l = t.stateNode; if (null === n && 4 & t.flags) { n = l; var c = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": c.autoFocus && n.focus(); break; case "img": c.src && (n.src = c.src) } } break; case 6: case 4: case 12: case 19: case 17: case 21: case 22: case 23: case 25: break; case 13: if (null === t.memoizedState) { var u = t.alternate; if (null !== u) { var d = u.memoizedState; if (null !== d) { var h = d.dehydrated; null !== h && Ht(h) } } } break; default: throw Error(s(163)) }Qo || 512 & t.flags && sl(t) } catch (p) { kc(t, t.return, p) } } if (t === e) { Zo = null; break } if (null !== (n = t.sibling)) { n.return = t.return, Zo = n; break } Zo = t.return } } function Sl(e) { for (; null !== Zo;) { var t = Zo; if (t === e) { Zo = null; break } var n = t.sibling; if (null !== n) { n.return = t.return, Zo = n; break } Zo = t.return } } function wl(e) { for (; null !== Zo;) { var t = Zo; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { rl(4, t) } catch (l) { kc(t, n, l) } break; case 1: var i = t.stateNode; if ("function" === typeof i.componentDidMount) { var r = t.return; try { i.componentDidMount() } catch (l) { kc(t, r, l) } } var s = t.return; try { sl(t) } catch (l) { kc(t, s, l) } break; case 5: var a = t.return; try { sl(t) } catch (l) { kc(t, a, l) } } } catch (l) { kc(t, t.return, l) } if (t === e) { Zo = null; break } var o = t.sibling; if (null !== o) { o.return = t.return, Zo = o; break } Zo = t.return } } var xl, kl = Math.ceil, El = _.ReactCurrentDispatcher, Cl = _.ReactCurrentOwner, Pl = _.ReactCurrentBatchConfig, Il = 0, Ll = null, Ol = null, Al = 0, Nl = 0, jl = xr(0), Dl = 0, Ml = null, Rl = 0, Ul = 0, Bl = 0, Fl = null, zl = null, Hl = 0, Vl = 1 / 0, Wl = null, ql = !1, Gl = null, Xl = null, Kl = !1, $l = null, Yl = 0, Ql = 0, Jl = null, Zl = -1, ec = 0; function tc() { return 0 !== (6 & Il) ? Qe() : -1 !== Zl ? Zl : Zl = Qe() } function nc(e) { return 0 === (1 & e.mode) ? 1 : 0 !== (2 & Il) && 0 !== Al ? Al & -Al : null !== ms.transition ? (0 === ec && (ec = mt()), ec) : 0 !== (e = bt) ? e : e = void 0 === (e = window.event) ? 16 : Yt(e.type) } function ic(e, t, n, i) { if (50 < Ql) throw Ql = 0, Jl = null, Error(s(185)); yt(e, n, i), 0 !== (2 & Il) && e === Ll || (e === Ll && (0 === (2 & Il) && (Ul |= n), 4 === Dl && lc(e, Al)), rc(e, i), 1 === n && 0 === Il && 0 === (1 & t.mode) && (Vl = Qe() + 500, Br && Hr())) } function rc(e, t) { var n = e.callbackNode; !function (e, t) { for (var n = e.suspendedLanes, i = e.pingedLanes, r = e.expirationTimes, s = e.pendingLanes; 0 < s;) { var a = 31 - at(s), o = 1 << a, l = r[a]; -1 === l ? 0 !== (o & n) && 0 === (o & i) || (r[a] = pt(o, t)) : l <= t && (e.expiredLanes |= o), s &= ~o } }(e, t); var i = ht(e, e === Ll ? Al : 0); if (0 === i) null !== n && Ke(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = i & -i, e.callbackPriority !== t) { if (null != n && Ke(n), 1 === t) 0 === e.tag ? function (e) { Br = !0, zr(e) }(cc.bind(null, e)) : zr(cc.bind(null, e)), ar((function () { 0 === (6 & Il) && Hr() })), n = null; else { switch (_t(i)) { case 1: n = Ze; break; case 4: n = et; break; case 16: default: n = tt; break; case 536870912: n = it }n = Lc(n, sc.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function sc(e, t) { if (Zl = -1, ec = 0, 0 !== (6 & Il)) throw Error(s(327)); var n = e.callbackNode; if (wc() && e.callbackNode !== n) return null; var i = ht(e, e === Ll ? Al : 0); if (0 === i) return null; if (0 !== (30 & i) || 0 !== (i & e.expiredLanes) || t) t = yc(e, i); else { t = i; var r = Il; Il |= 2; var a = mc(); for (Ll === e && Al === t || (Wl = null, Vl = Qe() + 500, pc(e, t)); ;)try { bc(); break } catch (l) { fc(e, l) } Ts(), El.current = a, Il = r, null !== Ol ? t = 0 : (Ll = null, Al = 0, t = Dl) } if (0 !== t) { if (2 === t && (0 !== (r = ft(e)) && (i = r, t = ac(e, r))), 1 === t) throw n = Ml, pc(e, 0), lc(e, i), rc(e, Qe()), n; if (6 === t) lc(e, i); else { if (r = e.current.alternate, 0 === (30 & i) && !function (e) { for (var t = e; ;) { if (16384 & t.flags) { var n = t.updateQueue; if (null !== n && null !== (n = n.stores)) for (var i = 0; i < n.length; i++) { var r = n[i], s = r.getSnapshot; r = r.value; try { if (!oi(s(), r)) return !1 } catch (o) { return !1 } } } if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n; else { if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 }(r) && (2 === (t = yc(e, i)) && (0 !== (a = ft(e)) && (i = a, t = ac(e, a))), 1 === t)) throw n = Ml, pc(e, 0), lc(e, i), rc(e, Qe()), n; switch (e.finishedWork = r, e.finishedLanes = i, t) { case 0: case 1: throw Error(s(345)); case 2: case 5: Sc(e, zl, Wl); break; case 3: if (lc(e, i), (130023424 & i) === i && 10 < (t = Hl + 500 - Qe())) { if (0 !== ht(e, 0)) break; if (((r = e.suspendedLanes) & i) !== i) { tc(), e.pingedLanes |= e.suspendedLanes & r; break } e.timeoutHandle = ir(Sc.bind(null, e, zl, Wl), t); break } Sc(e, zl, Wl); break; case 4: if (lc(e, i), (4194240 & i) === i) break; for (t = e.eventTimes, r = -1; 0 < i;) { var o = 31 - at(i); a = 1 << o, (o = t[o]) > r && (r = o), i &= ~a } if (i = r, 10 < (i = (120 > (i = Qe() - i) ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * kl(i / 1960)) - i)) { e.timeoutHandle = ir(Sc.bind(null, e, zl, Wl), i); break } Sc(e, zl, Wl); break; default: throw Error(s(329)) } } } return rc(e, Qe()), e.callbackNode === n ? sc.bind(null, e) : null } function ac(e, t) { var n = Fl; return e.current.memoizedState.isDehydrated && (pc(e, t).flags |= 256), 2 !== (e = yc(e, t)) && (t = zl, zl = n, null !== t && oc(t)), e } function oc(e) { null === zl ? zl = e : zl.push.apply(zl, e) } function lc(e, t) { for (t &= ~Bl, t &= ~Ul, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - at(t), i = 1 << n; e[n] = -1, t &= ~i } } function cc(e) { if (0 !== (6 & Il)) throw Error(s(327)); wc(); var t = ht(e, 0); if (0 === (1 & t)) return rc(e, Qe()), null; var n = yc(e, t); if (0 !== e.tag && 2 === n) { var i = ft(e); 0 !== i && (t = i, n = ac(e, i)) } if (1 === n) throw n = Ml, pc(e, 0), lc(e, t), rc(e, Qe()), n; if (6 === n) throw Error(s(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Sc(e, zl, Wl), rc(e, Qe()), null } function uc(e, t) { var n = Il; Il |= 1; try { return e(t) } finally { 0 === (Il = n) && (Vl = Qe() + 500, Br && Hr()) } } function dc(e) { null !== $l && 0 === $l.tag && 0 === (6 & Il) && wc(); var t = Il; Il |= 1; var n = Pl.transition, i = bt; try { if (Pl.transition = null, bt = 1, e) return e() } finally { bt = i, Pl.transition = n, 0 === (6 & (Il = t)) && Hr() } } function hc() { Nl = jl.current, kr(jl) } function pc(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (-1 !== n && (e.timeoutHandle = -1, rr(n)), null !== Ol) for (n = Ol.return; null !== n;) { var i = n; switch (ts(i), i.tag) { case 1: null !== (i = i.type.childContextTypes) && void 0 !== i && Nr(); break; case 3: ra(), kr(Ir), kr(Pr), ua(); break; case 5: aa(i); break; case 4: ra(); break; case 13: case 19: kr(oa); break; case 10: Ss(i.type._context); break; case 22: case 23: hc() }n = n.return } if (Ll = e, Ol = e = jc(e.current, null), Al = Nl = t, Dl = 0, Ml = null, Bl = Ul = Rl = 0, zl = Fl = null, null !== Es) { for (t = 0; t < Es.length; t++)if (null !== (i = (n = Es[t]).interleaved)) { n.interleaved = null; var r = i.next, s = n.pending; if (null !== s) { var a = s.next; s.next = r, i.next = a } n.pending = i } Es = null } return e } function fc(e, t) { for (; ;) { var n = Ol; try { if (Ts(), da.current = so, ya) { for (var i = fa.memoizedState; null !== i;) { var r = i.queue; null !== r && (r.pending = null), i = i.next } ya = !1 } if (pa = 0, ga = ma = fa = null, va = !1, ba = 0, Cl.current = null, null === n || null === n.return) { Dl = 1, Ml = t, Ol = null; break } e: { var a = e, o = n.return, l = n, c = t; if (t = Al, l.flags |= 32768, null !== c && "object" === typeof c && "function" === typeof c.then) { var u = c, d = l, h = d.tag; if (0 === (1 & d.mode) && (0 === h || 11 === h || 15 === h)) { var p = d.alternate; p ? (d.updateQueue = p.updateQueue, d.memoizedState = p.memoizedState, d.lanes = p.lanes) : (d.updateQueue = null, d.memoizedState = null) } var f = yo(o); if (null !== f) { f.flags &= -257, vo(f, o, l, 0, t), 1 & f.mode && go(a, u, t), c = u; var m = (t = f).updateQueue; if (null === m) { var g = new Set; g.add(c), t.updateQueue = g } else m.add(c); break e } if (0 === (1 & t)) { go(a, u, t), gc(); break e } c = Error(s(426)) } else if (rs && 1 & l.mode) { var y = yo(o); if (null !== y) { 0 === (65536 & y.flags) && (y.flags |= 256), vo(y, o, l, 0, t), fs(co(c, l)); break e } } a = c = co(c, l), 4 !== Dl && (Dl = 2), null === Fl ? Fl = [a] : Fl.push(a), a = o; do { switch (a.tag) { case 3: a.flags |= 65536, t &= -t, a.lanes |= t, Ms(a, fo(0, c, t)); break e; case 1: l = c; var v = a.type, b = a.stateNode; if (0 === (128 & a.flags) && ("function" === typeof v.getDerivedStateFromError || null !== b && "function" === typeof b.componentDidCatch && (null === Xl || !Xl.has(b)))) { a.flags |= 65536, t &= -t, a.lanes |= t, Ms(a, mo(a, l, t)); break e } }a = a.return } while (null !== a) } Tc(n) } catch (_) { t = _, Ol === n && null !== n && (Ol = n = n.return); continue } break } } function mc() { var e = El.current; return El.current = so, null === e ? so : e } function gc() { 0 !== Dl && 3 !== Dl && 2 !== Dl || (Dl = 4), null === Ll || 0 === (268435455 & Rl) && 0 === (268435455 & Ul) || lc(Ll, Al) } function yc(e, t) { var n = Il; Il |= 2; var i = mc(); for (Ll === e && Al === t || (Wl = null, pc(e, t)); ;)try { vc(); break } catch (r) { fc(e, r) } if (Ts(), Il = n, El.current = i, null !== Ol) throw Error(s(261)); return Ll = null, Al = 0, Dl } function vc() { for (; null !== Ol;)_c(Ol) } function bc() { for (; null !== Ol && !$e();)_c(Ol) } function _c(e) { var t = xl(e.alternate, e, Nl); e.memoizedProps = e.pendingProps, null === t ? Tc(e) : Ol = t, Cl.current = null } function Tc(e) { var t = e; do { var n = t.alternate; if (e = t.return, 0 === (32768 & t.flags)) { if (null !== (n = Ko(n, t, Nl))) return void (Ol = n) } else { if (null !== (n = $o(n, t))) return n.flags &= 32767, void (Ol = n); if (null === e) return Dl = 6, void (Ol = null); e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null } if (null !== (t = t.sibling)) return void (Ol = t); Ol = t = e } while (null !== t); 0 === Dl && (Dl = 5) } function Sc(e, t, n) { var i = bt, r = Pl.transition; try { Pl.transition = null, bt = 1, function (e, t, n, i) { do { wc() } while (null !== $l); if (0 !== (6 & Il)) throw Error(s(327)); n = e.finishedWork; var r = e.finishedLanes; if (null === n) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(s(177)); e.callbackNode = null, e.callbackPriority = 0; var a = n.lanes | n.childLanes; if (function (e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var i = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var r = 31 - at(n), s = 1 << r; t[r] = 0, i[r] = -1, e[r] = -1, n &= ~s } }(e, a), e === Ll && (Ol = Ll = null, Al = 0), 0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags) || Kl || (Kl = !0, Lc(tt, (function () { return wc(), null }))), a = 0 !== (15990 & n.flags), 0 !== (15990 & n.subtreeFlags) || a) { a = Pl.transition, Pl.transition = null; var o = bt; bt = 1; var l = Il; Il |= 4, Cl.current = null, function (e, t) { if (er = Wt, pi(e = hi())) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { var i = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection(); if (i && 0 !== i.rangeCount) { n = i.anchorNode; var r = i.anchorOffset, a = i.focusNode; i = i.focusOffset; try { n.nodeType, a.nodeType } catch (T) { n = null; break e } var o = 0, l = -1, c = -1, u = 0, d = 0, h = e, p = null; t: for (; ;) { for (var f; h !== n || 0 !== r && 3 !== h.nodeType || (l = o + r), h !== a || 0 !== i && 3 !== h.nodeType || (c = o + i), 3 === h.nodeType && (o += h.nodeValue.length), null !== (f = h.firstChild);)p = h, h = f; for (; ;) { if (h === e) break t; if (p === n && ++u === r && (l = o), p === a && ++d === i && (c = o), null !== (f = h.nextSibling)) break; p = (h = p).parentNode } h = f } n = -1 === l || -1 === c ? null : { start: l, end: c } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (tr = { focusedElem: e, selectionRange: n }, Wt = !1, Zo = t; null !== Zo;)if (e = (t = Zo).child, 0 !== (1028 & t.subtreeFlags) && null !== e) e.return = t, Zo = e; else for (; null !== Zo;) { t = Zo; try { var m = t.alternate; if (0 !== (1024 & t.flags)) switch (t.tag) { case 0: case 11: case 15: case 5: case 6: case 4: case 17: break; case 1: if (null !== m) { var g = m.memoizedProps, y = m.memoizedState, v = t.stateNode, b = v.getSnapshotBeforeUpdate(t.elementType === t.type ? g : gs(t.type, g), y); v.__reactInternalSnapshotBeforeUpdate = b } break; case 3: var _ = t.stateNode.containerInfo; 1 === _.nodeType ? _.textContent = "" : 9 === _.nodeType && _.documentElement && _.removeChild(_.documentElement); break; default: throw Error(s(163)) } } catch (T) { kc(t, t.return, T) } if (null !== (e = t.sibling)) { e.return = t.return, Zo = e; break } Zo = t.return } m = nl, nl = !1 }(e, n), yl(n, e), fi(tr), Wt = !!er, tr = er = null, e.current = n, bl(n, e, r), Ye(), Il = l, bt = o, Pl.transition = a } else e.current = n; if (Kl && (Kl = !1, $l = e, Yl = r), a = e.pendingLanes, 0 === a && (Xl = null), function (e) { if (st && "function" === typeof st.onCommitFiberRoot) try { st.onCommitFiberRoot(rt, e, void 0, 128 === (128 & e.current.flags)) } catch (t) { } }(n.stateNode), rc(e, Qe()), null !== t) for (i = e.onRecoverableError, n = 0; n < t.length; n++)r = t[n], i(r.value, { componentStack: r.stack, digest: r.digest }); if (ql) throw ql = !1, e = Gl, Gl = null, e; 0 !== (1 & Yl) && 0 !== e.tag && wc(), a = e.pendingLanes, 0 !== (1 & a) ? e === Jl ? Ql++ : (Ql = 0, Jl = e) : Ql = 0, Hr() }(e, t, n, i) } finally { Pl.transition = r, bt = i } return null } function wc() { if (null !== $l) { var e = _t(Yl), t = Pl.transition, n = bt; try { if (Pl.transition = null, bt = 16 > e ? 16 : e, null === $l) var i = !1; else { if (e = $l, $l = null, Yl = 0, 0 !== (6 & Il)) throw Error(s(331)); var r = Il; for (Il |= 4, Zo = e.current; null !== Zo;) { var a = Zo, o = a.child; if (0 !== (16 & Zo.flags)) { var l = a.deletions; if (null !== l) { for (var c = 0; c < l.length; c++) { var u = l[c]; for (Zo = u; null !== Zo;) { var d = Zo; switch (d.tag) { case 0: case 11: case 15: il(8, d, a) }var h = d.child; if (null !== h) h.return = d, Zo = h; else for (; null !== Zo;) { var p = (d = Zo).sibling, f = d.return; if (al(d), d === u) { Zo = null; break } if (null !== p) { p.return = f, Zo = p; break } Zo = f } } } var m = a.alternate; if (null !== m) { var g = m.child; if (null !== g) { m.child = null; do { var y = g.sibling; g.sibling = null, g = y } while (null !== g) } } Zo = a } } if (0 !== (2064 & a.subtreeFlags) && null !== o) o.return = a, Zo = o; else e: for (; null !== Zo;) { if (0 !== (2048 & (a = Zo).flags)) switch (a.tag) { case 0: case 11: case 15: il(9, a, a.return) }var v = a.sibling; if (null !== v) { v.return = a.return, Zo = v; break e } Zo = a.return } } var b = e.current; for (Zo = b; null !== Zo;) { var _ = (o = Zo).child; if (0 !== (2064 & o.subtreeFlags) && null !== _) _.return = o, Zo = _; else e: for (o = b; null !== Zo;) { if (0 !== (2048 & (l = Zo).flags)) try { switch (l.tag) { case 0: case 11: case 15: rl(9, l) } } catch (S) { kc(l, l.return, S) } if (l === o) { Zo = null; break e } var T = l.sibling; if (null !== T) { T.return = l.return, Zo = T; break e } Zo = l.return } } if (Il = r, Hr(), st && "function" === typeof st.onPostCommitFiberRoot) try { st.onPostCommitFiberRoot(rt, e) } catch (S) { } i = !0 } return i } finally { bt = n, Pl.transition = t } } return !1 } function xc(e, t, n) { e = js(e, t = fo(0, t = co(n, t), 1), 1), t = tc(), null !== e && (yt(e, 1, t), rc(e, t)) } function kc(e, t, n) { if (3 === e.tag) xc(e, e, n); else for (; null !== t;) { if (3 === t.tag) { xc(t, e, n); break } if (1 === t.tag) { var i = t.stateNode; if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof i.componentDidCatch && (null === Xl || !Xl.has(i))) { t = js(t, e = mo(t, e = co(n, e), 1), 1), e = tc(), null !== t && (yt(t, 1, e), rc(t, e)); break } } t = t.return } } function Ec(e, t, n) { var i = e.pingCache; null !== i && i.delete(t), t = tc(), e.pingedLanes |= e.suspendedLanes & n, Ll === e && (Al & n) === n && (4 === Dl || 3 === Dl && (130023424 & Al) === Al && 500 > Qe() - Hl ? pc(e, 0) : Bl |= n), rc(e, t) } function Cc(e, t) { 0 === t && (0 === (1 & e.mode) ? t = 1 : (t = ut, 0 === (130023424 & (ut <<= 1)) && (ut = 4194304))); var n = tc(); null !== (e = Is(e, t)) && (yt(e, t, n), rc(e, n)) } function Pc(e) { var t = e.memoizedState, n = 0; null !== t && (n = t.retryLane), Cc(e, n) } function Ic(e, t) { var n = 0; switch (e.tag) { case 13: var i = e.stateNode, r = e.memoizedState; null !== r && (n = r.retryLane); break; case 19: i = e.stateNode; break; default: throw Error(s(314)) }null !== i && i.delete(t), Cc(e, n) } function Lc(e, t) { return Xe(e, t) } function Oc(e, t, n, i) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Ac(e, t, n, i) { return new Oc(e, t, n, i) } function Nc(e) { return !(!(e = e.prototype) || !e.isReactComponent) } function jc(e, t) { var n = e.alternate; return null === n ? ((n = Ac(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Dc(e, t, n, i, r, a) { var o = 2; if (i = e, "function" === typeof e) Nc(e) && (o = 1); else if ("string" === typeof e) o = 5; else e: switch (e) { case w: return Mc(n.children, r, a, t); case x: o = 8, r |= 8; break; case k: return (e = Ac(12, n, t, 2 | r)).elementType = k, e.lanes = a, e; case I: return (e = Ac(13, n, t, r)).elementType = I, e.lanes = a, e; case L: return (e = Ac(19, n, t, r)).elementType = L, e.lanes = a, e; case N: return Rc(n, r, a, t); default: if ("object" === typeof e && null !== e) switch (e.$$typeof) { case E: o = 10; break e; case C: o = 9; break e; case P: o = 11; break e; case O: o = 14; break e; case A: o = 16, i = null; break e }throw Error(s(130, null == e ? e : typeof e, "")) }return (t = Ac(o, n, t, r)).elementType = e, t.type = i, t.lanes = a, t } function Mc(e, t, n, i) { return (e = Ac(7, e, i, t)).lanes = n, e } function Rc(e, t, n, i) { return (e = Ac(22, e, i, t)).elementType = N, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function Uc(e, t, n) { return (e = Ac(6, e, null, t)).lanes = n, e } function Bc(e, t, n) { return (t = Ac(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function Fc(e, t, n, i, r) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gt(0), this.expirationTimes = gt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gt(0), this.identifierPrefix = i, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null } function zc(e, t, n, i, r, s, a, o, l) { return e = new Fc(e, t, n, o, l), 1 === t ? (t = 1, !0 === s && (t |= 8)) : t = 0, s = Ac(3, null, null, t), e.current = s, s.stateNode = e, s.memoizedState = { element: i, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Os(s), e } function Hc(e) { if (!e) return Cr; e: { if (He(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(s(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Ar(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (null !== t); throw Error(s(171)) } if (1 === e.tag) { var n = e.type; if (Ar(n)) return Dr(e, n, t) } return t } function Vc(e, t, n, i, r, s, a, o, l) { return (e = zc(n, i, !0, e, 0, s, 0, o, l)).context = Hc(null), n = e.current, (s = Ns(i = tc(), r = nc(n))).callback = void 0 !== t && null !== t ? t : null, js(n, s, r), e.current.lanes = r, yt(e, r, i), rc(e, i), e } function Wc(e, t, n, i) { var r = t.current, s = tc(), a = nc(r); return n = Hc(n), null === t.context ? t.context = n : t.pendingContext = n, (t = Ns(s, a)).payload = { element: e }, null !== (i = void 0 === i ? null : i) && (t.callback = i), null !== (e = js(r, t, a)) && (ic(e, r, a, s), Ds(e, r, a)), a } function qc(e) { return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null } function Gc(e, t) { if (null !== (e = e.memoizedState) && null !== e.dehydrated) { var n = e.retryLane; e.retryLane = 0 !== n && n < t ? n : t } } function Xc(e, t) { Gc(e, t), (e = e.alternate) && Gc(e, t) } xl = function (e, t, n) { if (null !== e) if (e.memoizedProps !== t.pendingProps || Ir.current) _o = !0; else { if (0 === (e.lanes & n) && 0 === (128 & t.flags)) return _o = !1, function (e, t, n) { switch (t.tag) { case 3: Lo(t), ps(); break; case 5: sa(t); break; case 1: Ar(t.type) && Mr(t); break; case 4: ia(t, t.stateNode.containerInfo); break; case 10: var i = t.type._context, r = t.memoizedProps.value; Er(ys, i._currentValue), i._currentValue = r; break; case 13: if (null !== (i = t.memoizedState)) return null !== i.dehydrated ? (Er(oa, 1 & oa.current), t.flags |= 128, null) : 0 !== (n & t.child.childLanes) ? Uo(e, t, n) : (Er(oa, 1 & oa.current), null !== (e = qo(e, t, n)) ? e.sibling : null); Er(oa, 1 & oa.current); break; case 19: if (i = 0 !== (n & t.childLanes), 0 !== (128 & e.flags)) { if (i) return Vo(e, t, n); t.flags |= 128 } if (null !== (r = t.memoizedState) && (r.rendering = null, r.tail = null, r.lastEffect = null), Er(oa, oa.current), i) break; return null; case 22: case 23: return t.lanes = 0, ko(e, t, n) }return qo(e, t, n) }(e, t, n); _o = 0 !== (131072 & e.flags) } else _o = !1, rs && 0 !== (1048576 & t.flags) && Zr(t, Gr, t.index); switch (t.lanes = 0, t.tag) { case 2: var i = t.type; Wo(e, t), e = t.pendingProps; var r = Or(t, Pr.current); xs(t, n), r = wa(null, t, i, e, r, n); var a = xa(); return t.flags |= 1, "object" === typeof r && null !== r && "function" === typeof r.render && void 0 === r.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Ar(i) ? (a = !0, Mr(t)) : a = !1, t.memoizedState = null !== r.state && void 0 !== r.state ? r.state : null, Os(t), r.updater = zs, t.stateNode = r, r._reactInternals = t, qs(t, i, e, n), t = Io(null, t, i, !0, a, n)) : (t.tag = 0, rs && a && es(t), To(null, t, r, n), t = t.child), t; case 16: i = t.elementType; e: { switch (Wo(e, t), e = t.pendingProps, i = (r = i._init)(i._payload), t.type = i, r = t.tag = function (e) { if ("function" === typeof e) return Nc(e) ? 1 : 0; if (void 0 !== e && null !== e) { if ((e = e.$$typeof) === P) return 11; if (e === O) return 14 } return 2 }(i), e = gs(i, e), r) { case 0: t = Co(null, t, i, e, n); break e; case 1: t = Po(null, t, i, e, n); break e; case 11: t = So(null, t, i, e, n); break e; case 14: t = wo(null, t, i, gs(i.type, e), n); break e }throw Error(s(306, i, "")) } return t; case 0: return i = t.type, r = t.pendingProps, Co(e, t, i, r = t.elementType === i ? r : gs(i, r), n); case 1: return i = t.type, r = t.pendingProps, Po(e, t, i, r = t.elementType === i ? r : gs(i, r), n); case 3: e: { if (Lo(t), null === e) throw Error(s(387)); i = t.pendingProps, r = (a = t.memoizedState).element, As(e, t), Rs(t, i, null, n); var o = t.memoizedState; if (i = o.element, a.isDehydrated) { if (a = { element: i, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, t.updateQueue.baseState = a, t.memoizedState = a, 256 & t.flags) { t = Oo(e, t, i, n, r = co(Error(s(423)), t)); break e } if (i !== r) { t = Oo(e, t, i, n, r = co(Error(s(424)), t)); break e } for (is = cr(t.stateNode.containerInfo.firstChild), ns = t, rs = !0, ss = null, n = Qs(t, null, i, n), t.child = n; n;)n.flags = -3 & n.flags | 4096, n = n.sibling } else { if (ps(), i === r) { t = qo(e, t, n); break e } To(e, t, i, n) } t = t.child } return t; case 5: return sa(t), null === e && cs(t), i = t.type, r = t.pendingProps, a = null !== e ? e.memoizedProps : null, o = r.children, nr(i, r) ? o = null : null !== a && nr(i, a) && (t.flags |= 32), Eo(e, t), To(e, t, o, n), t.child; case 6: return null === e && cs(t), null; case 13: return Uo(e, t, n); case 4: return ia(t, t.stateNode.containerInfo), i = t.pendingProps, null === e ? t.child = Ys(t, null, i, n) : To(e, t, i, n), t.child; case 11: return i = t.type, r = t.pendingProps, So(e, t, i, r = t.elementType === i ? r : gs(i, r), n); case 7: return To(e, t, t.pendingProps, n), t.child; case 8: case 12: return To(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (i = t.type._context, r = t.pendingProps, a = t.memoizedProps, o = r.value, Er(ys, i._currentValue), i._currentValue = o, null !== a) if (oi(a.value, o)) { if (a.children === r.children && !Ir.current) { t = qo(e, t, n); break e } } else for (null !== (a = t.child) && (a.return = t); null !== a;) { var l = a.dependencies; if (null !== l) { o = a.child; for (var c = l.firstContext; null !== c;) { if (c.context === i) { if (1 === a.tag) { (c = Ns(-1, n & -n)).tag = 2; var u = a.updateQueue; if (null !== u) { var d = (u = u.shared).pending; null === d ? c.next = c : (c.next = d.next, d.next = c), u.pending = c } } a.lanes |= n, null !== (c = a.alternate) && (c.lanes |= n), ws(a.return, n, t), l.lanes |= n; break } c = c.next } } else if (10 === a.tag) o = a.type === t.type ? null : a.child; else if (18 === a.tag) { if (null === (o = a.return)) throw Error(s(341)); o.lanes |= n, null !== (l = o.alternate) && (l.lanes |= n), ws(o, n, t), o = a.sibling } else o = a.child; if (null !== o) o.return = a; else for (o = a; null !== o;) { if (o === t) { o = null; break } if (null !== (a = o.sibling)) { a.return = o.return, o = a; break } o = o.return } a = o } To(e, t, r.children, n), t = t.child } return t; case 9: return r = t.type, i = t.pendingProps.children, xs(t, n), i = i(r = ks(r)), t.flags |= 1, To(e, t, i, n), t.child; case 14: return r = gs(i = t.type, t.pendingProps), wo(e, t, i, r = gs(i.type, r), n); case 15: return xo(e, t, t.type, t.pendingProps, n); case 17: return i = t.type, r = t.pendingProps, r = t.elementType === i ? r : gs(i, r), Wo(e, t), t.tag = 1, Ar(i) ? (e = !0, Mr(t)) : e = !1, xs(t, n), Vs(t, i, r), qs(t, i, r, n), Io(null, t, i, !0, e, n); case 19: return Vo(e, t, n); case 22: return ko(e, t, n) }throw Error(s(156, t.tag)) }; var Kc = "function" === typeof reportError ? reportError : function (e) { console.error(e) }; function $c(e) { this._internalRoot = e } function Yc(e) { this._internalRoot = e } function Qc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType) } function Jc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue)) } function Zc() { } function eu(e, t, n, i, r) { var s = n._reactRootContainer; if (s) { var a = s; if ("function" === typeof r) { var o = r; r = function () { var e = qc(a); o.call(e) } } Wc(t, a, e, r) } else a = function (e, t, n, i, r) { if (r) { if ("function" === typeof i) { var s = i; i = function () { var e = qc(a); s.call(e) } } var a = Vc(t, i, e, 0, null, !1, 0, "", Zc); return e._reactRootContainer = a, e[fr] = a.current, Hi(8 === e.nodeType ? e.parentNode : e), dc(), a } for (; r = e.lastChild;)e.removeChild(r); if ("function" === typeof i) { var o = i; i = function () { var e = qc(l); o.call(e) } } var l = zc(e, 0, !1, null, 0, !1, 0, "", Zc); return e._reactRootContainer = l, e[fr] = l.current, Hi(8 === e.nodeType ? e.parentNode : e), dc((function () { Wc(t, l, n, i) })), l }(n, t, e, r, i); return qc(a) } Yc.prototype.render = $c.prototype.render = function (e) { var t = this._internalRoot; if (null === t) throw Error(s(409)); Wc(e, t, null, null) }, Yc.prototype.unmount = $c.prototype.unmount = function () { var e = this._internalRoot; if (null !== e) { this._internalRoot = null; var t = e.containerInfo; dc((function () { Wc(null, e, null, null) })), t[fr] = null } }, Yc.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = xt(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Nt.length && 0 !== t && t < Nt[n].priority; n++); Nt.splice(n, 0, e), 0 === n && Rt(e) } }, Tt = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = dt(t.pendingLanes); 0 !== n && (vt(t, 1 | n), rc(t, Qe()), 0 === (6 & Il) && (Vl = Qe() + 500, Hr())) } break; case 13: dc((function () { var t = Is(e, 1); if (null !== t) { var n = tc(); ic(t, e, 1, n) } })), Xc(e, 1) } }, St = function (e) { if (13 === e.tag) { var t = Is(e, 134217728); if (null !== t) ic(t, e, 134217728, tc()); Xc(e, 134217728) } }, wt = function (e) { if (13 === e.tag) { var t = nc(e), n = Is(e, t); if (null !== n) ic(n, e, t, tc()); Xc(e, t) } }, xt = function () { return bt }, kt = function (e, t) { var n = bt; try { return bt = e, t() } finally { bt = n } }, Se = function (e, t, n) { switch (t) { case "input": if (J(e, n), t = n.name, "radio" === n.type && null != t) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var i = n[t]; if (i !== e && i.form === e.form) { var r = Tr(i); if (!r) throw Error(s(90)); X(i), J(i, r) } } } break; case "textarea": se(e, n); break; case "select": null != (t = n.value) && ne(e, !!n.multiple, t, !1) } }, Pe = uc, Ie = dc; var tu = { usingClientEntryPoint: !1, Events: [br, _r, Tr, Ee, Ce, uc] }, nu = { findFiberByHostInstance: vr, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, iu = { bundleType: nu.bundleType, version: nu.version, rendererPackageName: nu.rendererPackageName, rendererConfig: nu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: _.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return null === (e = qe(e)) ? null : e.stateNode }, findFiberByHostInstance: nu.findFiberByHostInstance || function () { return null }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) { var ru = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!ru.isDisabled && ru.supportsFiber) try { rt = ru.inject(iu), st = ru } catch (ue) { } } t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tu, t.createPortal = function (e, t) { var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null; if (!Qc(t)) throw Error(s(200)); return function (e, t, n) { var i = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null; return { $$typeof: S, key: null == i ? null : "" + i, children: e, containerInfo: t, implementation: n } }(e, t, null, n) }, t.createRoot = function (e, t) { if (!Qc(e)) throw Error(s(299)); var n = !1, i = "", r = Kc; return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (i = t.identifierPrefix), void 0 !== t.onRecoverableError && (r = t.onRecoverableError)), t = zc(e, 1, !1, null, 0, n, 0, i, r), e[fr] = t.current, Hi(8 === e.nodeType ? e.parentNode : e), new $c(t) }, t.findDOMNode = function (e) { if (null == e) return null; if (1 === e.nodeType) return e; var t = e._reactInternals; if (void 0 === t) { if ("function" === typeof e.render) throw Error(s(188)); throw e = Object.keys(e).join(","), Error(s(268, e)) } return e = null === (e = qe(t)) ? null : e.stateNode }, t.flushSync = function (e) { return dc(e) }, t.hydrate = function (e, t, n) { if (!Jc(t)) throw Error(s(200)); return eu(null, e, t, !0, n) }, t.hydrateRoot = function (e, t, n) { if (!Qc(e)) throw Error(s(405)); var i = null != n && n.hydratedSources || null, r = !1, a = "", o = Kc; if (null !== n && void 0 !== n && (!0 === n.unstable_strictMode && (r = !0), void 0 !== n.identifierPrefix && (a = n.identifierPrefix), void 0 !== n.onRecoverableError && (o = n.onRecoverableError)), t = Vc(t, null, e, 1, null != n ? n : null, r, 0, a, o), e[fr] = t.current, Hi(e), i) for (e = 0; e < i.length; e++)r = (r = (n = i[e])._getVersion)(n._source), null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, r] : t.mutableSourceEagerHydrationData.push(n, r); return new Yc(t) }, t.render = function (e, t, n) { if (!Jc(t)) throw Error(s(200)); return eu(null, e, t, !1, n) }, t.unmountComponentAtNode = function (e) { if (!Jc(e)) throw Error(s(40)); return !!e._reactRootContainer && (dc((function () { eu(null, null, e, !1, (function () { e._reactRootContainer = null, e[fr] = null })) })), !0) }, t.unstable_batchedUpdates = uc, t.unstable_renderSubtreeIntoContainer = function (e, t, n, i) { if (!Jc(n)) throw Error(s(200)); if (null == e || void 0 === e._reactInternals) throw Error(s(38)); return eu(e, t, n, !1, i) }, t.version = "18.2.0-next-9e3b772b8-20220608" }, 1250: (e, t, n) => { "use strict"; var i = n(4164); t.createRoot = i.createRoot, t.hydrateRoot = i.hydrateRoot }, 4164: (e, t, n) => { "use strict"; !function e() { if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } }(), e.exports = n(4463) }, 77: e => { var t = "undefined" !== typeof Element, n = "function" === typeof Map, i = "function" === typeof Set, r = "function" === typeof ArrayBuffer && !!ArrayBuffer.isView; function s(e, a) { if (e === a) return !0; if (e && a && "object" == typeof e && "object" == typeof a) { if (e.constructor !== a.constructor) return !1; var o, l, c, u; if (Array.isArray(e)) { if ((o = e.length) != a.length) return !1; for (l = o; 0 !== l--;)if (!s(e[l], a[l])) return !1; return !0 } if (n && e instanceof Map && a instanceof Map) { if (e.size !== a.size) return !1; for (u = e.entries(); !(l = u.next()).done;)if (!a.has(l.value[0])) return !1; for (u = e.entries(); !(l = u.next()).done;)if (!s(l.value[1], a.get(l.value[0]))) return !1; return !0 } if (i && e instanceof Set && a instanceof Set) { if (e.size !== a.size) return !1; for (u = e.entries(); !(l = u.next()).done;)if (!a.has(l.value[0])) return !1; return !0 } if (r && ArrayBuffer.isView(e) && ArrayBuffer.isView(a)) { if ((o = e.length) != a.length) return !1; for (l = o; 0 !== l--;)if (e[l] !== a[l]) return !1; return !0 } if (e.constructor === RegExp) return e.source === a.source && e.flags === a.flags; if (e.valueOf !== Object.prototype.valueOf && "function" === typeof e.valueOf && "function" === typeof a.valueOf) return e.valueOf() === a.valueOf(); if (e.toString !== Object.prototype.toString && "function" === typeof e.toString && "function" === typeof a.toString) return e.toString() === a.toString(); if ((o = (c = Object.keys(e)).length) !== Object.keys(a).length) return !1; for (l = o; 0 !== l--;)if (!Object.prototype.hasOwnProperty.call(a, c[l])) return !1; if (t && e instanceof Element) return !1; for (l = o; 0 !== l--;)if (("_owner" !== c[l] && "__v" !== c[l] && "__o" !== c[l] || !e.$$typeof) && !s(e[c[l]], a[c[l]])) return !1; return !0 } return e !== e && a !== a } e.exports = function (e, t) { try { return s(e, t) } catch (n) { if ((n.message || "").match(/stack|recursion/i)) return console.warn("react-fast-compare cannot handle circular refs"), !1; throw n } } }, 1639: function (e, t, n) { var i; e.exports = (i = n(2791), (() => { "use strict"; var e = { 359: e => { e.exports = i } }, t = {}; function n(i) { var r = t[i]; if (void 0 !== r) return r.exports; var s = t[i] = { exports: {} }; return e[i](s, s.exports, n), s.exports } n.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return n.d(t, { a: t }), t }, n.d = (e, t) => { for (var i in t) n.o(t, i) && !n.o(e, i) && Object.defineProperty(e, i, { enumerable: !0, get: t[i] }) }, n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }; var r = {}; return (() => { n.r(r), n.d(r, { ReactNotifications: () => z, Store: () => A }); var e, t, i, s, a = n(359), o = n.n(a), l = !0, c = 768, u = 325, d = "rnc__notification-item"; !function (e) { e.BOTTOM_LEFT = "bottom-left", e.BOTTOM_RIGHT = "bottom-right", e.BOTTOM_CENTER = "bottom-center", e.TOP_LEFT = "top-left", e.TOP_RIGHT = "top-right", e.TOP_CENTER = "top-center", e.CENTER = "center", e.TOP_FULL = "top-full", e.BOTTOM_FULL = "bottom-full" }(e || (e = {})), function (e) { e.TOP = "top", e.BOTTOM = "bottom" }(t || (t = {})), function (e) { e.SUCCESS = "success", e.DANGER = "danger", e.INFO = "info", e.DEFAULT = "default", e.WARNING = "warning" }(i || (i = {})), function (e) { e.TIMEOUT = "timeout", e.CLICK = "click", e.TOUCH = "touch", e.MANUAL = "manual" }(s || (s = {})); var h = function (e) { return null == e }; function p(t) { return t === e.BOTTOM_FULL || t === e.BOTTOM_LEFT || t === e.BOTTOM_RIGHT || t === e.BOTTOM_CENTER } function f(t) { return t === e.TOP_FULL || t === e.TOP_LEFT || t === e.TOP_RIGHT || t === e.TOP_CENTER } function m(e) { var t = e.type, n = e.content, r = e.userDefinedTypes, s = [d]; if (n) return s; if (h(r)) return function (e) { switch (e) { case i.DEFAULT: return [d, "rnc__notification-item--default"]; case i.SUCCESS: return [d, "rnc__notification-item--success"]; case i.DANGER: return [d, "rnc__notification-item--danger"]; case i.WARNING: return [d, "rnc__notification-item--warning"]; case i.INFO: return [d, "rnc__notification-item--info"]; default: return [d] } }(t); var a = r.find((function (e) { return e.name === t })); return s.concat(a.htmlClasses) } function g(e, t) { var n = e.duration, i = e.timingFunction, r = e.delay; return "".concat(n, "ms ").concat(t, " ").concat(i, " ").concat(r, "ms") } function y(e) { return e ? (0 | 16 * Math.random()).toString(16) : "100000000000100000000000".replace(/1|0/g, y) } function v(e, t) { var n = t.duration, i = t.timingFunction, r = t.delay, s = e || {}; return h(s.duration) && (s.duration = n), h(s.timingFunction) && (s.timingFunction = i), h(s.delay) && (s.delay = r), s } function b(e, t, n) { var r = e, s = r.id, a = r.type, o = r.insert, l = r.content, c = r.container, u = r.animationIn, d = r.animationOut, p = r.slidingEnter, f = r.slidingExit, m = r.touchRevert, g = r.touchSlidingExit, b = r.dismiss, _ = r.width, T = r.onRemoval; r.id = s || y(), r.type = l ? null : a.toLowerCase(), t && !l && (r.userDefinedTypes = function (e, t) { var n = e.content, r = e.type; if (!n && r !== i.SUCCESS && r !== i.DANGER && r !== i.INFO && r !== i.DEFAULT && r !== i.WARNING && t) return t }(r, t)), r.width = h(_) ? n : _, r.container = c.toLowerCase(), r.insert = (o || "top").toLowerCase(), r.dismiss = function (e) { var t = e, n = { duration: 0, click: !0, touch: !0, onScreen: !1, pauseOnHover: !1, waitForAnimation: !1, showIcon: !1 }; return t ? (Object.keys(n).forEach((function (e) { h(t[e]) && (t[e] = n[e]) })), t) : n }(b), r.animationIn = u || [], r.animationOut = d || [], r.onRemoval = T || function () { }; var S = function (e, t, n) { return { duration: e, timingFunction: t, delay: n } }; r.slidingEnter = v(p, S(600, "linear", 0)), r.slidingExit = v(f, S(600, "linear", 0)), r.touchRevert = v(m, S(600, "linear", 0)); var w = g || {}, x = w.swipe || {}, k = w.fade || {}; return r.touchSlidingExit = w, r.touchSlidingExit.swipe = v(x, S(600, "linear", 0)), r.touchSlidingExit.fade = v(k, S(300, "linear", 0)), r } function _(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } var T = function () { function e(t, n) { !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e), this.callback = t, this.remaining = n, this.resume() } var t, n, i; return t = e, (n = [{ key: "pause", value: function () { clearTimeout(this.timerId), this.remaining -= Date.now() - this.start } }, { key: "resume", value: function () { this.start = Date.now(), clearTimeout(this.timerId), this.timerId = setTimeout(this.callback, this.remaining) } }, { key: "clear", value: function () { clearTimeout(this.timerId) } }]) && _(t.prototype, n), i && _(t, i), Object.defineProperty(t, "prototype", { writable: !1 }), e }(); function S(e) { return S = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, S(e) } function w(e) { return function (e) { if (Array.isArray(e)) return x(e) }(e) || function (e) { if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e) }(e) || function (e, t) { if (e) { if ("string" == typeof e) return x(e, t); var n = Object.prototype.toString.call(e).slice(8, -1); return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? x(e, t) : void 0 } }(e) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function x(e, t) { (null == t || t > e.length) && (t = e.length); for (var n = 0, i = new Array(t); n < t; n++)i[n] = e[n]; return i } function k(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function E(e, t) { return E = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e }, E(e, t) } function C(e) { var t = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (e) { return !1 } }(); return function () { var n, i = I(e); if (t) { var r = I(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return P(this, n) } } function P(e, t) { if (t && ("object" === S(t) || "function" == typeof t)) return t; if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined"); return function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(e) } function I(e) { return I = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) }, I(e) } var L = function (n) { !function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && E(e, t) }(c, n); var i, r, a, l = C(c); function c(e) { var t; !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, c), (t = l.call(this, e)).onClick = function () { var e = t.props.notification.dismiss; (e.click || e.showIcon) && t.removeNotification(s.CLICK) }, t.onTouchStart = function (e) { var n = e.touches[0].pageX; t.setState((function (e) { var t = e.parentStyle; return { startX: n, currentX: n, parentStyle: Object.assign(Object.assign({}, t), { position: "relative" }) } })) }, t.onTouchMove = function (e) { var n = e.touches[0].pageX, i = t.state.startX, r = t.props, a = r.toggleRemoval, o = r.notification, l = o.id, c = o.onRemoval, u = o.slidingExit, d = o.touchSlidingExit, h = d.swipe, p = d.fade, f = n - i, m = t.rootElementRef.current.offsetWidth, y = window.innerWidth + m, v = "".concat(n - i >= 0 ? y : -y, "px"); if (function (e, t) { return Math.abs(e) >= .4 * t }(f, m)) { var b = g(h, "left"), _ = g(p, "opacity"), T = function () { a(l, (function () { return c(l, s.TOUCH) })) }; return t.setState((function (e) { var n = e.parentStyle; return { touchEnabled: !1, parentStyle: Object.assign(Object.assign({}, n), { left: v, opacity: 0, transition: "".concat(b, ", ").concat(_) }), onTransitionEnd: function () { t.setState((function (e) { var t = e.parentStyle; return { parentStyle: Object.assign(Object.assign({}, t), { height: "0px", overflow: "hidden", transition: g(u, "height") }), onTransitionEnd: T } })) } } })) } return t.setState((function (e) { var t = e.parentStyle; return { currentX: n, parentStyle: Object.assign(Object.assign({}, t), { left: "".concat(0 + f, "px") }) } })) }, t.onTouchEnd = function () { var e = t.props.notification.touchRevert; t.setState((function (t) { var n = t.parentStyle; return { parentStyle: Object.assign(Object.assign({}, n), { left: 0, transition: g(e, "left") }) } })) }, t.onMouseEnter = function () { t.timer ? t.timer.pause() : t.setState({ animationPlayState: "paused" }) }, t.onMouseLeave = function () { t.timer ? t.timer.resume() : t.setState({ animationPlayState: "running" }) }, t.rootElementRef = o().createRef(); var n = e.defaultNotificationWidth, i = e.notification, r = e.isMobile, a = i.width; return t.state = { parentStyle: { height: "0px", overflow: "hidden", width: "".concat(a || n, "px") }, htmlClassList: m(i), animationPlayState: "running", touchEnabled: !0 }, r && (t.state.parentStyle.width = "100%"), t } return i = c, (r = [{ key: "componentWillUnmount", value: function () { this.timer && this.timer.clear() } }, { key: "componentDidMount", value: function () { var n = this, i = this.props, r = i.notification, a = i.notificationsCount, o = r.dismiss, l = o.duration, c = o.onScreen, u = function (n, i) { return !(i <= 1) && i > 1 && (n.insert === t.TOP && f(n.container) || n.insert === t.BOTTOM && p(n.container) || n.container === e.CENTER) }(r, a), d = this.rootElementRef.current.scrollHeight, h = function () { !l || c || n.timer || (n.timer = new T((function () { return n.removeNotification(s.TIMEOUT) }), l)) }; this.setState((function (e) { return { parentStyle: { width: e.parentStyle.width, height: "".concat(d, "px"), transition: u ? g(r.slidingEnter, "height") : "10ms height" }, onTransitionEnd: h } }), (function () { requestAnimationFrame((function () { n.setState((function (e) { return { htmlClassList: [].concat(w(r.animationIn), w(e.htmlClassList)) } })) })) })) } }, { key: "componentDidUpdate", value: function (e) { if (this.props.hasBeenRemoved && !e.hasBeenRemoved && this.removeNotification(s.MANUAL), e !== this.props && !this.props.hasBeenRemoved) { var t = this.props.notification.container, n = this.rootElementRef.current.children[0].scrollHeight; this.setState((function (e) { var i = e.parentStyle; return { parentStyle: Object.assign(Object.assign({}, i), { height: "".concat(n + (t.endsWith("full") ? 0 : 15), "px") }) } })) } } }, { key: "removeNotification", value: function (e) { var t = this, n = this.props, i = n.notification, r = n.toggleRemoval, s = i.id, a = i.onRemoval, o = i.dismiss.waitForAnimation, l = [].concat(w(i.animationOut), w(m(i))), c = function () { return r(s, (function () { return a(s, e) })) }, u = { height: "0px", overflow: "hidden", transition: g(i.slidingExit, "height") }; return o ? this.setState((function (e) { var n = e.parentStyle.width; return { htmlClassList: l, onAnimationEnd: function () { t.setState({ parentStyle: Object.assign({ width: n }, u), onTransitionEnd: c }) } } })) : this.setState((function (e) { var t = e.parentStyle.width; return { parentStyle: Object.assign({ width: t }, u), onTransitionEnd: c, htmlClassList: l } })) } }, { key: "renderTimer", value: function () { var e = this, t = this.props.notification.dismiss, n = t.duration, i = t.onScreen, r = this.state.animationPlayState; if (n && i) { var a = { animationName: "timer", animationDuration: "".concat(n, "ms"), animationTimingFunction: "linear", animationFillMode: "forwards", animationDelay: "0", animationPlayState: r }; return o().createElement("div", { className: "rnc__notification-timer" }, o().createElement("div", { className: "rnc__notification-timer-filler", onAnimationEnd: function () { return e.removeNotification(s.TIMEOUT) }, style: a })) } } }, { key: "renderCustomContent", value: function () { var e = this.state.htmlClassList, t = this.props.notification, n = t.id, i = t.content, r = t.dismiss, s = r.duration, a = r.pauseOnHover, l = s > 0 && a; return o().createElement("div", { className: "".concat(w(e).join(" ")), onMouseEnter: l ? this.onMouseEnter : null, onMouseLeave: l ? this.onMouseLeave : null }, o().isValidElement(i) ? i : o().createElement(i, Object.assign({}, { id: n, notificationConfig: Object.assign({}, this.props.notification) }))) } }, { key: "renderNotification", value: function () { var e = this.props.notification, t = e.title, n = e.message, i = e.dismiss, r = i.showIcon, s = i.duration, a = i.pauseOnHover, l = this.state.htmlClassList, c = s > 0 && a; return o().createElement("div", { className: "".concat(w(l).join(" ")), onMouseEnter: c ? this.onMouseEnter : null, onMouseLeave: c ? this.onMouseLeave : null }, o().createElement("div", { className: "rnc__notification-content" }, r && o().createElement("div", { className: "rnc__notification-close-mark", onClick: this.onClick }), t && o().createElement("div", { className: "rnc__notification-title" }, t), o().createElement("div", { className: "rnc__notification-message" }, n), this.renderTimer())) } }, { key: "render", value: function () { var e = this.props.notification, t = e.content, n = e.dismiss.click, i = this.state, r = i.parentStyle, s = i.onAnimationEnd, a = i.onTransitionEnd, l = i.touchEnabled; return o().createElement("div", { ref: this.rootElementRef, onClick: n ? this.onClick : null, style: r, className: "rnc__notification", onAnimationEnd: s, onTransitionEnd: a, onTouchStart: l ? this.onTouchStart : null, onTouchMove: l ? this.onTouchMove : null, onTouchEnd: l ? this.onTouchEnd : null }, t ? this.renderCustomContent() : this.renderNotification()) } }]) && k(i.prototype, r), a && k(i, a), Object.defineProperty(i, "prototype", { writable: !1 }), c }(o().Component); function O(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } const A = new (function () { function e() { var t = this; !function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e), this.incrementCounter = function () { return t.counter += 1 }, this.getCounter = function () { return t.counter }, this.counter = 0, this.add = null } var t, n, i; return t = e, (n = [{ key: "addNotification", value: function (e) { this.incrementCounter(); var t = b(e, this.types, this.defaultNotificationWidth); return this.add(t) } }, { key: "register", value: function (e) { var t = e.addNotification, n = e.removeNotification, i = e.removeAllNotifications, r = e.types, s = e.defaultNotificationWidth; this.add = t, this.removeNotification = n, this.removeAllNotifications = i, this.defaultNotificationWidth = s, this.types = r } }]) && O(t.prototype, n), i && O(t, i), Object.defineProperty(t, "prototype", { writable: !1 }), e }()); function N(e) { return N = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, N(e) } function j(e) { return function (e) { if (Array.isArray(e)) return D(e) }(e) || function (e) { if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e) }(e) || function (e, t) { if (e) { if ("string" == typeof e) return D(e, t); var n = Object.prototype.toString.call(e).slice(8, -1); return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? D(e, t) : void 0 } }(e) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function D(e, t) { (null == t || t > e.length) && (t = e.length); for (var n = 0, i = new Array(t); n < t; n++)i[n] = e[n]; return i } function M(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function R(e, t) { return R = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e }, R(e, t) } function U(e) { var t = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (e) { return !1 } }(); return function () { var n, i = F(e); if (t) { var r = F(this).constructor; n = Reflect.construct(i, arguments, r) } else n = i.apply(this, arguments); return B(this, n) } } function B(e, t) { if (t && ("object" === N(t) || "function" == typeof t)) return t; if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined"); return function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(e) } function F(e) { return F = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) }, F(e) } var z = function (t) { !function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && R(e, t) }(a, t); var n, i, r, s = U(a); function a(e) { var t; return function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, a), (t = s.call(this, e)).handleResize = function () { t.setState({ windowWidth: window.innerWidth }) }, t.add = function (e) { return t.setState((function (t) { var n = j(t.notifications), i = n.findIndex((function (t) { return t.id === e.id })); return i > -1 ? (n[i] = e, { notifications: n }) : { notifications: "top" === e.insert ? [e].concat(j(n)) : [].concat(j(n), [e]) } })), e.id }, t.remove = function (e) { t.setState((function (t) { return { notifications: t.notifications.map((function (t) { return t.id === e && (t.hasBeenRemoved = !0), t })) } })) }, t.removeAllNotifications = function () { t.setState({ notifications: t.state.notifications.map((function (e) { return Object.assign(Object.assign({}, e), { hasBeenRemoved: !0 }) })) }) }, t.toggleRemoval = function (e, n) { t.setState((function (t) { return { notifications: t.notifications.filter((function (t) { return t.id !== e })) } }), n) }, t.state = { isMobile: h(e.isMobile) ? l : e.isMobile, breakpoint: h(e.breakpoint) ? c : e.breakpoint, notifications: [], windowWidth: void 0 }, t } return n = a, (i = [{ key: "componentDidMount", value: function () { var e = this.props, t = e.types, n = e.defaultNotificationWidth; A.register({ addNotification: this.add, removeNotification: this.remove, removeAllNotifications: this.removeAllNotifications, defaultNotificationWidth: n || u, types: t }), this.setState({ windowWidth: window.innerWidth }), window.addEventListener("resize", this.handleResize) } }, { key: "componentWillUnmount", value: function () { window.removeEventListener("resize", this.handleResize) } }, { key: "renderNotifications", value: function (e, t) { var n = this; return e.map((function (i) { return o().createElement(L, { id: i.id, key: i.id, isMobile: t, defaultNotificationWidth: n.props.defaultNotificationWidth, notification: i, toggleRemoval: n.toggleRemoval, notificationsCount: e.length, hasBeenRemoved: i.hasBeenRemoved }) })) } }, { key: "renderMobileNotifications", value: function (t) { var n = t.className, i = t.id, r = function (t) { var n = [], i = []; return t.forEach((function (t) { var r = t.container, s = e.CENTER; f(r) || r === s ? n.push(t) : p(r) && i.push(t) })), { top: n, bottom: i } }(this.state.notifications), s = this.renderNotifications(r.top, !0), a = this.renderNotifications(r.bottom, !0); return o().createElement("div", { id: i, key: "mobile", className: "rnc__base ".concat(n || "") }, o().createElement("div", { className: "rnc__notification-container--mobile-top" }, s), o().createElement("div", { className: "rnc__notification-container--mobile-bottom" }, a)) } }, { key: "renderScreenNotifications", value: function (t) { var n = t.className, i = t.id, r = function (t) { var n = [], i = [], r = [], s = [], a = [], o = [], l = [], c = [], u = []; return t.forEach((function (t) { var d = t.container; d === e.TOP_FULL ? c.push(t) : d === e.BOTTOM_FULL ? u.push(t) : d === e.TOP_LEFT ? n.push(t) : d === e.TOP_RIGHT ? i.push(t) : d === e.TOP_CENTER ? r.push(t) : d === e.BOTTOM_LEFT ? s.push(t) : d === e.BOTTOM_RIGHT ? a.push(t) : d === e.BOTTOM_CENTER ? o.push(t) : d === e.CENTER && l.push(t) })), { topFull: c, bottomFull: u, topLeft: n, topRight: i, topCenter: r, bottomLeft: s, bottomRight: a, bottomCenter: o, center: l } }(this.state.notifications), s = this.renderNotifications(r.topFull, !1), a = this.renderNotifications(r.bottomFull, !1), l = this.renderNotifications(r.topLeft, !1), c = this.renderNotifications(r.topRight, !1), u = this.renderNotifications(r.topCenter, !1), d = this.renderNotifications(r.bottomLeft, !1), h = this.renderNotifications(r.bottomRight, !1), p = this.renderNotifications(r.bottomCenter, !1), f = this.renderNotifications(r.center, !1); return o().createElement("div", { id: i, key: "screen", className: "rnc__base ".concat(n || "") }, o().createElement("div", { className: "rnc__notification-container--top-full" }, s), o().createElement("div", { className: "rnc__notification-container--bottom-full" }, a), o().createElement("div", { className: "rnc__notification-container--top-left" }, l), o().createElement("div", { className: "rnc__notification-container--top-right" }, c), o().createElement("div", { className: "rnc__notification-container--bottom-left" }, d), o().createElement("div", { className: "rnc__notification-container--bottom-right" }, h), o().createElement("div", { className: "rnc__notification-container--top-center" }, u), o().createElement("div", { className: "rnc__notification-container--center" }, o().createElement("div", { className: "rnc__util--flex-center" }, f)), o().createElement("div", { className: "rnc__notification-container--bottom-center" }, p)) } }, { key: "render", value: function () { var e = this.props.isMobile, t = this.state, n = t.windowWidth, i = t.breakpoint; return e && n <= i ? this.renderMobileNotifications(this.props) : this.renderScreenNotifications(this.props) } }]) && M(n.prototype, i), r && M(n, r), Object.defineProperty(n, "prototype", { writable: !1 }), a }(o().Component) })(), r })()) }, 9434: (e, t, n) => { var i, r = Object.create, s = Object.defineProperty, a = Object.getOwnPropertyDescriptor, o = Object.getOwnPropertyNames, l = Object.getPrototypeOf, c = Object.prototype.hasOwnProperty, u = (e, t, n, i) => { if (t && "object" === typeof t || "function" === typeof t) for (let r of o(t)) c.call(e, r) || r === n || s(e, r, { get: () => t[r], enumerable: !(i = a(t, r)) || i.enumerable }); return e }, d = (e, t, n) => (n = null != e ? r(l(e)) : {}, u(!t && e && e.__esModule ? n : s(n, "default", { value: e, enumerable: !0 }), e)), h = (e, t, n) => (((e, t, n) => { t in e ? s(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n })(e, "symbol" !== typeof t ? t + "" : t, n), n), p = {}; ((e, t) => { for (var n in t) s(e, n, { get: t[n], enumerable: !0 }) })(p, { default: () => v }), e.exports = (i = p, u(s({}, "__esModule", { value: !0 }), i)); var f = d(n(2791)), m = d(n(77)), g = n(9174), y = n(135); class v extends f.Component { constructor() { var e; super(...arguments), e = this, h(this, "mounted", !1), h(this, "isReady", !1), h(this, "isPlaying", !1), h(this, "isLoading", !0), h(this, "loadOnReady", null), h(this, "startOnPlay", !0), h(this, "seekOnPlay", null), h(this, "onDurationCalled", !1), h(this, "handlePlayerMount", (e => { this.player || (this.player = e, this.player.load(this.props.url)), this.progress() })), h(this, "getInternalPlayer", (e => this.player ? this.player[e] : null)), h(this, "progress", (() => { if (this.props.url && this.player && this.isReady) { const e = this.getCurrentTime() || 0, t = this.getSecondsLoaded(), n = this.getDuration(); if (n) { const i = { playedSeconds: e, played: e / n }; null !== t && (i.loadedSeconds = t, i.loaded = t / n), i.playedSeconds === this.prevPlayed && i.loadedSeconds === this.prevLoaded || this.props.onProgress(i), this.prevPlayed = i.playedSeconds, this.prevLoaded = i.loadedSeconds } } this.progressTimeout = setTimeout(this.progress, this.props.progressFrequency || this.props.progressInterval) })), h(this, "handleReady", (() => { if (!this.mounted) return; this.isReady = !0, this.isLoading = !1; const { onReady: e, playing: t, volume: n, muted: i } = this.props; e(), i || null === n || this.player.setVolume(n), this.loadOnReady ? (this.player.load(this.loadOnReady, !0), this.loadOnReady = null) : t && this.player.play(), this.handleDurationCheck() })), h(this, "handlePlay", (() => { this.isPlaying = !0, this.isLoading = !1; const { onStart: e, onPlay: t, playbackRate: n } = this.props; this.startOnPlay && (this.player.setPlaybackRate && 1 !== n && this.player.setPlaybackRate(n), e(), this.startOnPlay = !1), t(), this.seekOnPlay && (this.seekTo(this.seekOnPlay), this.seekOnPlay = null), this.handleDurationCheck() })), h(this, "handlePause", (e => { this.isPlaying = !1, this.isLoading || this.props.onPause(e) })), h(this, "handleEnded", (() => { const { activePlayer: e, loop: t, onEnded: n } = this.props; e.loopOnEnded && t && this.seekTo(0), t || (this.isPlaying = !1, n()) })), h(this, "handleError", (function () { e.isLoading = !1, e.props.onError(...arguments) })), h(this, "handleDurationCheck", (() => { clearTimeout(this.durationCheckTimeout); const e = this.getDuration(); e ? this.onDurationCalled || (this.props.onDuration(e), this.onDurationCalled = !0) : this.durationCheckTimeout = setTimeout(this.handleDurationCheck, 100) })), h(this, "handleLoaded", (() => { this.isLoading = !1 })) } componentDidMount() { this.mounted = !0 } componentWillUnmount() { clearTimeout(this.progressTimeout), clearTimeout(this.durationCheckTimeout), this.isReady && this.props.stopOnUnmount && (this.player.stop(), this.player.disablePIP && this.player.disablePIP()), this.mounted = !1 } componentDidUpdate(e) { if (!this.player) return; const { url: t, playing: n, volume: i, muted: r, playbackRate: s, pip: a, loop: o, activePlayer: l, disableDeferredLoading: c } = this.props; if (!(0, m.default)(e.url, t)) { if (this.isLoading && !l.forceLoad && !c && !(0, y.isMediaStream)(t)) return console.warn("ReactPlayer: the attempt to load ".concat(t, " is being deferred until the player has loaded")), void (this.loadOnReady = t); this.isLoading = !0, this.startOnPlay = !0, this.onDurationCalled = !1, this.player.load(t, this.isReady) } e.playing || !n || this.isPlaying || this.player.play(), e.playing && !n && this.isPlaying && this.player.pause(), !e.pip && a && this.player.enablePIP && this.player.enablePIP(), e.pip && !a && this.player.disablePIP && this.player.disablePIP(), e.volume !== i && null !== i && this.player.setVolume(i), e.muted !== r && (r ? this.player.mute() : (this.player.unmute(), null !== i && setTimeout((() => this.player.setVolume(i))))), e.playbackRate !== s && this.player.setPlaybackRate && this.player.setPlaybackRate(s), e.loop !== o && this.player.setLoop && this.player.setLoop(o) } getDuration() { return this.isReady ? this.player.getDuration() : null } getCurrentTime() { return this.isReady ? this.player.getCurrentTime() : null } getSecondsLoaded() { return this.isReady ? this.player.getSecondsLoaded() : null } seekTo(e, t, n) { if (!this.isReady) return void (0 !== e && (this.seekOnPlay = e, setTimeout((() => { this.seekOnPlay = null }), 5e3))); if (t ? "fraction" === t : e > 0 && e < 1) { const t = this.player.getDuration(); return t ? void this.player.seekTo(t * e, n) : void console.warn("ReactPlayer: could not seek using fraction \u2013\xa0duration not yet available") } this.player.seekTo(e, n) } render() { const e = this.props.activePlayer; return e ? f.default.createElement(e, { ...this.props, onMount: this.handlePlayerMount, onReady: this.handleReady, onPlay: this.handlePlay, onPause: this.handlePause, onEnded: this.handleEnded, onLoaded: this.handleLoaded, onError: this.handleError }) : null } } h(v, "displayName", "Player"), h(v, "propTypes", g.propTypes), h(v, "defaultProps", g.defaultProps) }, 2646: (e, t, n) => { var i, r = Object.create, s = Object.defineProperty, a = Object.getOwnPropertyDescriptor, o = Object.getOwnPropertyNames, l = Object.getPrototypeOf, c = Object.prototype.hasOwnProperty, u = (e, t, n, i) => { if (t && "object" === typeof t || "function" === typeof t) for (let r of o(t)) c.call(e, r) || r === n || s(e, r, { get: () => t[r], enumerable: !(i = a(t, r)) || i.enumerable }); return e }, d = (e, t, n) => (n = null != e ? r(l(e)) : {}, u(!t && e && e.__esModule ? n : s(n, "default", { value: e, enumerable: !0 }), e)), h = (e, t, n) => (((e, t, n) => { t in e ? s(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n })(e, "symbol" !== typeof t ? t + "" : t, n), n), p = {}; ((e, t) => { for (var n in t) s(e, n, { get: t[n], enumerable: !0 }) })(p, { createReactPlayer: () => C }), e.exports = (i = p, u(s({}, "__esModule", { value: !0 }), i)); var f = d(n(2791)), m = d(n(9948)), g = d(n(5781)), y = d(n(77)), v = n(9174), b = n(135), _ = d(n(9434)); const T = (0, b.lazy)((() => n.e(664).then(n.t.bind(n, 8275, 23)))), S = "undefined" !== typeof window && window.document && "undefined" !== typeof document, w = "undefined" !== typeof n.g && n.g.window && n.g.window.document, x = Object.keys(v.propTypes), k = S || w ? f.Suspense : () => null, E = [], C = (e, t) => { var n; return n = class extends f.Component { constructor() { var n; super(...arguments), n = this, h(this, "state", { showPreview: !!this.props.light }), h(this, "references", { wrapper: e => { this.wrapper = e }, player: e => { this.player = e } }), h(this, "handleClickPreview", (e => { this.setState({ showPreview: !1 }), this.props.onClickPreview(e) })), h(this, "showPreview", (() => { this.setState({ showPreview: !0 }) })), h(this, "getDuration", (() => this.player ? this.player.getDuration() : null)), h(this, "getCurrentTime", (() => this.player ? this.player.getCurrentTime() : null)), h(this, "getSecondsLoaded", (() => this.player ? this.player.getSecondsLoaded() : null)), h(this, "getInternalPlayer", (function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "player"; return n.player ? n.player.getInternalPlayer(e) : null })), h(this, "seekTo", ((e, t, n) => { if (!this.player) return null; this.player.seekTo(e, t, n) })), h(this, "handleReady", (() => { this.props.onReady(this) })), h(this, "getActivePlayer", (0, g.default)((n => { for (const t of [...E, ...e]) if (t.canPlay(n)) return t; return t || null }))), h(this, "getConfig", (0, g.default)(((e, t) => { const { config: n } = this.props; return m.default.all([v.defaultProps.config, v.defaultProps.config[t] || {}, n, n[t] || {}]) }))), h(this, "getAttributes", (0, g.default)((e => (0, b.omit)(this.props, x)))), h(this, "renderActivePlayer", (e => { if (!e) return null; const t = this.getActivePlayer(e); if (!t) return null; const n = this.getConfig(e, t.key); return f.default.createElement(_.default, { ...this.props, key: t.key, ref: this.references.player, config: n, activePlayer: t.lazyPlayer || t, onReady: this.handleReady }) })) } shouldComponentUpdate(e, t) { return !(0, y.default)(this.props, e) || !(0, y.default)(this.state, t) } componentDidUpdate(e) { const { light: t } = this.props; !e.light && t && this.setState({ showPreview: !0 }), e.light && !t && this.setState({ showPreview: !1 }) } renderPreview(e) { if (!e) return null; const { light: t, playIcon: n, previewTabIndex: i, oEmbedUrl: r, previewAriaLabel: s } = this.props; return f.default.createElement(T, { url: e, light: t, playIcon: n, previewTabIndex: i, previewAriaLabel: s, oEmbedUrl: r, onClick: this.handleClickPreview }) } render() { const { url: e, style: t, width: n, height: i, fallback: r, wrapper: s } = this.props, { showPreview: a } = this.state, o = this.getAttributes(e), l = "string" === typeof s ? this.references.wrapper : void 0; return f.default.createElement(s, { ref: l, style: { ...t, width: n, height: i }, ...o }, f.default.createElement(k, { fallback: r }, a ? this.renderPreview(e) : this.renderActivePlayer(e))) } }, h(n, "displayName", "ReactPlayer"), h(n, "propTypes", v.propTypes), h(n, "defaultProps", v.defaultProps), h(n, "addCustomPlayer", (e => { E.push(e) })), h(n, "removeCustomPlayers", (() => { E.length = 0 })), h(n, "canPlay", (t => { for (const n of [...E, ...e]) if (n.canPlay(t)) return !0; return !1 })), h(n, "canEnablePIP", (t => { for (const n of [...E, ...e]) if (n.canEnablePIP && n.canEnablePIP(t)) return !0; return !1 })), n } }, 6710: (e, t, n) => { var i, r = Object.create, s = Object.defineProperty, a = Object.getOwnPropertyDescriptor, o = Object.getOwnPropertyNames, l = Object.getPrototypeOf, c = Object.prototype.hasOwnProperty, u = (e, t, n, i) => { if (t && "object" === typeof t || "function" === typeof t) for (let r of o(t)) c.call(e, r) || r === n || s(e, r, { get: () => t[r], enumerable: !(i = a(t, r)) || i.enumerable }); return e }, d = {}; ((e, t) => { for (var n in t) s(e, n, { get: t[n], enumerable: !0 }) })(d, { default: () => m }), e.exports = (i = d, u(s({}, "__esModule", { value: !0 }), i)); var h = ((e, t, n) => (n = null != e ? r(l(e)) : {}, u(!t && e && e.__esModule ? n : s(n, "default", { value: e, enumerable: !0 }), e)))(n(4687)), p = n(2646); const f = h.default[h.default.length - 1]; var m = (0, p.createReactPlayer)(h.default, f) }, 365: (e, t, n) => { var i, r = Object.defineProperty, s = Object.getOwnPropertyDescriptor, a = Object.getOwnPropertyNames, o = Object.prototype.hasOwnProperty, l = {}; ((e, t) => { for (var n in t) r(e, n, { get: t[n], enumerable: !0 }) })(l, { AUDIO_EXTENSIONS: () => x, DASH_EXTENSIONS: () => C, FLV_EXTENSIONS: () => P, HLS_EXTENSIONS: () => E, MATCH_URL_DAILYMOTION: () => _, MATCH_URL_FACEBOOK: () => f, MATCH_URL_FACEBOOK_WATCH: () => m, MATCH_URL_KALTURA: () => w, MATCH_URL_MIXCLOUD: () => T, MATCH_URL_MUX: () => p, MATCH_URL_SOUNDCLOUD: () => d, MATCH_URL_STREAMABLE: () => g, MATCH_URL_TWITCH_CHANNEL: () => b, MATCH_URL_TWITCH_VIDEO: () => v, MATCH_URL_VIDYARD: () => S, MATCH_URL_VIMEO: () => h, MATCH_URL_WISTIA: () => y, MATCH_URL_YOUTUBE: () => u, VIDEO_EXTENSIONS: () => k, canPlay: () => L }), e.exports = (i = l, ((e, t, n, i) => { if (t && "object" === typeof t || "function" === typeof t) for (let l of a(t)) o.call(e, l) || l === n || r(e, l, { get: () => t[l], enumerable: !(i = s(t, l)) || i.enumerable }); return e })(r({}, "__esModule", { value: !0 }), i)); var c = n(135); const u = /(?:youtu\.be\/|youtube(?:-nocookie|education)?\.com\/(?:embed\/|v\/|watch\/|watch\?v=|watch\?.+&v=|shorts\/|live\/))((\w|-){11})|youtube\.com\/playlist\?list=|youtube\.com\/user\//, d = /(?:soundcloud\.com|snd\.sc)\/[^.]+$/, h = /vimeo\.com\/(?!progressive_redirect).+/, p = /stream\.mux\.com\/(\w+)/, f = /^https?:\/\/(www\.)?facebook\.com.*\/(video(s)?|watch|story)(\.php?|\/).+$/, m = /^https?:\/\/fb\.watch\/.+$/, g = /streamable\.com\/([a-z0-9]+)$/, y = /(?:wistia\.(?:com|net)|wi\.st)\/(?:medias|embed)\/(?:iframe\/)?([^?]+)/, v = /(?:www\.|go\.)?twitch\.tv\/videos\/(\d+)($|\?)/, b = /(?:www\.|go\.)?twitch\.tv\/([a-zA-Z0-9_]+)($|\?)/, _ = /^(?:(?:https?):)?(?:\/\/)?(?:www\.)?(?:(?:dailymotion\.com(?:\/embed)?\/video)|dai\.ly)\/([a-zA-Z0-9]+)(?:_[\w_-]+)?(?:[\w.#_-]+)?/, T = /mixcloud\.com\/([^/]+\/[^/]+)/, S = /vidyard.com\/(?:watch\/)?([a-zA-Z0-9-_]+)/, w = /^https?:\/\/[a-zA-Z]+\.kaltura.(com|org)\/p\/([0-9]+)\/sp\/([0-9]+)00\/embedIframeJs\/uiconf_id\/([0-9]+)\/partner_id\/([0-9]+)(.*)entry_id.([a-zA-Z0-9-_].*)$/, x = /\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i, k = /\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\d+]+)?($|\?)/i, E = /\.(m3u8)($|\?)/i, C = /\.(mpd)($|\?)/i, P = /\.(flv)($|\?)/i, I = e => { if (e instanceof Array) { for (const t of e) { if ("string" === typeof t && I(t)) return !0; if (I(t.src)) return !0 } return !1 } return !(!(0, c.isMediaStream)(e) && !(0, c.isBlobUrl)(e)) || (x.test(e) || k.test(e) || E.test(e) || C.test(e) || P.test(e)) }, L = { youtube: e => e instanceof Array ? e.every((e => u.test(e))) : u.test(e), soundcloud: e => d.test(e) && !x.test(e), vimeo: e => h.test(e) && !k.test(e) && !E.test(e), mux: e => p.test(e), facebook: e => f.test(e) || m.test(e), streamable: e => g.test(e), wistia: e => y.test(e), twitch: e => v.test(e) || b.test(e), dailymotion: e => _.test(e), mixcloud: e => T.test(e), vidyard: e => S.test(e), kaltura: e => w.test(e), file: I } }, 4687: (e, t, n) => { Object.create; var i, r = Object.defineProperty, s = Object.getOwnPropertyDescriptor, a = Object.getOwnPropertyNames, o = (Object.getPrototypeOf, Object.prototype.hasOwnProperty), l = (e, t, n, i) => { if (t && "object" === typeof t || "function" === typeof t) for (let l of a(t)) o.call(e, l) || l === n || r(e, l, { get: () => t[l], enumerable: !(i = s(t, l)) || i.enumerable }); return e }, c = {}; ((e, t) => { for (var n in t) r(e, n, { get: t[n], enumerable: !0 }) })(c, { default: () => h }), e.exports = (i = c, l(r({}, "__esModule", { value: !0 }), i)); var u = n(135), d = n(365), h = [{ key: "youtube", name: "YouTube", canPlay: d.canPlay.youtube, lazyPlayer: (0, u.lazy)((() => n.e(439).then(n.t.bind(n, 8322, 23)))) }, { key: "soundcloud", name: "SoundCloud", canPlay: d.canPlay.soundcloud, lazyPlayer: (0, u.lazy)((() => n.e(125).then(n.t.bind(n, 1801, 23)))) }, { key: "vimeo", name: "Vimeo", canPlay: d.canPlay.vimeo, lazyPlayer: (0, u.lazy)((() => n.e(743).then(n.t.bind(n, 7600, 23)))) }, { key: "mux", name: "Mux", canPlay: d.canPlay.mux, lazyPlayer: (0, u.lazy)((() => n.e(258).then(n.t.bind(n, 4599, 23)))) }, { key: "facebook", name: "Facebook", canPlay: d.canPlay.facebook, lazyPlayer: (0, u.lazy)((() => n.e(121).then(n.t.bind(n, 4793, 23)))) }, { key: "streamable", name: "Streamable", canPlay: d.canPlay.streamable, lazyPlayer: (0, u.lazy)((() => n.e(546).then(n.t.bind(n, 1286, 23)))) }, { key: "wistia", name: "Wistia", canPlay: d.canPlay.wistia, lazyPlayer: (0, u.lazy)((() => n.e(55).then(n.t.bind(n, 5793, 23)))) }, { key: "twitch", name: "Twitch", canPlay: d.canPlay.twitch, lazyPlayer: (0, u.lazy)((() => n.e(216).then(n.t.bind(n, 6741, 23)))) }, { key: "dailymotion", name: "DailyMotion", canPlay: d.canPlay.dailymotion, lazyPlayer: (0, u.lazy)((() => n.e(596).then(n.t.bind(n, 4303, 23)))) }, { key: "mixcloud", name: "Mixcloud", canPlay: d.canPlay.mixcloud, lazyPlayer: (0, u.lazy)((() => n.e(667).then(n.t.bind(n, 2732, 23)))) }, { key: "vidyard", name: "Vidyard", canPlay: d.canPlay.vidyard, lazyPlayer: (0, u.lazy)((() => n.e(888).then(n.t.bind(n, 5561, 23)))) }, { key: "kaltura", name: "Kaltura", canPlay: d.canPlay.kaltura, lazyPlayer: (0, u.lazy)((() => n.e(261).then(n.t.bind(n, 9332, 23)))) }, { key: "file", name: "FilePlayer", canPlay: d.canPlay.file, canEnablePIP: e => d.canPlay.file(e) && (document.pictureInPictureEnabled || (0, u.supportsWebKitPresentationMode)()) && !d.AUDIO_EXTENSIONS.test(e), lazyPlayer: (0, u.lazy)((() => n.e(11).then(n.t.bind(n, 8997, 23)))) }] }, 9174: (e, t, n) => { var i, r = Object.create, s = Object.defineProperty, a = Object.getOwnPropertyDescriptor, o = Object.getOwnPropertyNames, l = Object.getPrototypeOf, c = Object.prototype.hasOwnProperty, u = (e, t, n, i) => { if (t && "object" === typeof t || "function" === typeof t) for (let r of o(t)) c.call(e, r) || r === n || s(e, r, { get: () => t[r], enumerable: !(i = a(t, r)) || i.enumerable }); return e }, d = {}; ((e, t) => { for (var n in t) s(e, n, { get: t[n], enumerable: !0 }) })(d, { defaultProps: () => x, propTypes: () => S }), e.exports = (i = d, u(s({}, "__esModule", { value: !0 }), i)); var h = ((e, t, n) => (n = null != e ? r(l(e)) : {}, u(!t && e && e.__esModule ? n : s(n, "default", { value: e, enumerable: !0 }), e)))(n(2007)); const { string: p, bool: f, number: m, array: g, oneOfType: y, shape: v, object: b, func: _, node: T } = h.default, S = { url: y([p, g, b]), playing: f, loop: f, controls: f, volume: m, muted: f, playbackRate: m, width: y([p, m]), height: y([p, m]), style: b, progressInterval: m, playsinline: f, pip: f, stopOnUnmount: f, light: y([f, p, b]), playIcon: T, previewTabIndex: m, previewAriaLabel: p, fallback: T, oEmbedUrl: p, wrapper: y([p, _, v({ render: _.isRequired })]), config: v({ soundcloud: v({ options: b }), youtube: v({ playerVars: b, embedOptions: b, onUnstarted: _ }), facebook: v({ appId: p, version: p, playerId: p, attributes: b }), dailymotion: v({ params: b }), vimeo: v({ playerOptions: b, title: p }), mux: v({ attributes: b, version: p }), file: v({ attributes: b, tracks: g, forceVideo: f, forceAudio: f, forceHLS: f, forceSafariHLS: f, forceDisableHls: f, forceDASH: f, forceFLV: f, hlsOptions: b, hlsVersion: p, dashVersion: p, flvVersion: p }), wistia: v({ options: b, playerId: p, customControls: g }), mixcloud: v({ options: b }), twitch: v({ options: b, playerId: p }), vidyard: v({ options: b }) }), onReady: _, onStart: _, onPlay: _, onPause: _, onBuffer: _, onBufferEnd: _, onEnded: _, onError: _, onDuration: _, onSeek: _, onPlaybackRateChange: _, onPlaybackQualityChange: _, onProgress: _, onClickPreview: _, onEnablePIP: _, onDisablePIP: _ }, w = () => { }, x = { playing: !1, loop: !1, controls: !1, volume: null, muted: !1, playbackRate: 1, width: "640px", height: "360px", style: {}, progressInterval: 1e3, playsinline: !1, pip: !1, stopOnUnmount: !0, light: !1, fallback: null, wrapper: "div", previewTabIndex: 0, previewAriaLabel: "", oEmbedUrl: "https://noembed.com/embed?url={url}", config: { soundcloud: { options: { visual: !0, buying: !1, liking: !1, download: !1, sharing: !1, show_comments: !1, show_playcount: !1 } }, youtube: { playerVars: { playsinline: 1, showinfo: 0, rel: 0, iv_load_policy: 3, modestbranding: 1 }, embedOptions: {}, onUnstarted: w }, facebook: { appId: "1309697205772819", version: "v3.3", playerId: null, attributes: {} }, dailymotion: { params: { api: 1, "endscreen-enable": !1 } }, vimeo: { playerOptions: { autopause: !1, byline: !1, portrait: !1, title: !1 }, title: null }, mux: { attributes: {}, version: "2" }, file: { attributes: {}, tracks: [], forceVideo: !1, forceAudio: !1, forceHLS: !1, forceDASH: !1, forceFLV: !1, hlsOptions: {}, hlsVersion: "1.1.4", dashVersion: "3.1.3", flvVersion: "1.5.0", forceDisableHls: !1 }, wistia: { options: {}, playerId: null, customControls: null }, mixcloud: { options: { hide_cover: 1 } }, twitch: { options: {}, playerId: null }, vidyard: { options: {} } }, onReady: w, onStart: w, onPlay: w, onPause: w, onBuffer: w, onBufferEnd: w, onEnded: w, onError: w, onDuration: w, onSeek: w, onPlaybackRateChange: w, onPlaybackQualityChange: w, onProgress: w, onClickPreview: w, onEnablePIP: w, onDisablePIP: w } }, 135: (e, t, n) => { var i, r = Object.create, s = Object.defineProperty, a = Object.getOwnPropertyDescriptor, o = Object.getOwnPropertyNames, l = Object.getPrototypeOf, c = Object.prototype.hasOwnProperty, u = (e, t, n, i) => { if (t && "object" === typeof t || "function" === typeof t) for (let r of o(t)) c.call(e, r) || r === n || s(e, r, { get: () => t[r], enumerable: !(i = a(t, r)) || i.enumerable }); return e }, d = (e, t, n) => (n = null != e ? r(l(e)) : {}, u(!t && e && e.__esModule ? n : s(n, "default", { value: e, enumerable: !0 }), e)), h = {}; ((e, t) => { for (var n in t) s(e, n, { get: t[n], enumerable: !0 }) })(h, { callPlayer: () => O, getConfig: () => I, getSDK: () => P, isBlobUrl: () => N, isMediaStream: () => A, lazy: () => g, omit: () => L, parseEndTime: () => w, parseStartTime: () => S, queryString: () => k, randomString: () => x, supportsWebKitPresentationMode: () => j }), e.exports = (i = h, u(s({}, "__esModule", { value: !0 }), i)); var p = d(n(2791)), f = d(n(5102)), m = d(n(9948)); const g = e => p.default.lazy((async () => { const t = await e(); return "function" === typeof t.default ? t : t.default })), y = /[?&#](?:start|t)=([0-9hms]+)/, v = /[?&#]end=([0-9hms]+)/, b = /(\d+)(h|m|s)/g, _ = /^\d+$/; function T(e, t) { if (e instanceof Array) return; const n = e.match(t); if (n) { const e = n[1]; if (e.match(b)) return function (e) { let t = 0, n = b.exec(e); for (; null !== n;) { const [, i, r] = n; "h" === r && (t += 60 * parseInt(i, 10) * 60), "m" === r && (t += 60 * parseInt(i, 10)), "s" === r && (t += parseInt(i, 10)), n = b.exec(e) } return t }(e); if (_.test(e)) return parseInt(e) } } function S(e) { return T(e, y) } function w(e) { return T(e, v) } function x() { return Math.random().toString(36).substr(2, 5) } function k(e) { return Object.keys(e).map((t => "".concat(t, "=").concat(e[t]))).join("&") } function E(e) { return window[e] ? window[e] : window.exports && window.exports[e] ? window.exports[e] : window.module && window.module.exports && window.module.exports[e] ? window.module.exports[e] : null } const C = {}, P = function (e) { 0; return e }((function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : () => !0, r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : f.default; const s = E(t); return s && i(s) ? Promise.resolve(s) : new Promise(((i, s) => { if (C[e]) return void C[e].push({ resolve: i, reject: s }); C[e] = [{ resolve: i, reject: s }]; const a = t => { C[e].forEach((e => e.resolve(t))) }; if (n) { const e = window[n]; window[n] = function () { e && e(), a(E(t)) } } r(e, (i => { i ? (C[e].forEach((e => e.reject(i))), C[e] = null) : n || a(E(t)) })) })) })); function I(e, t) { return (0, m.default)(t.config, e.config) } function L(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; const r = [].concat(...n), s = {}, a = Object.keys(e); for (const o of a) -1 === r.indexOf(o) && (s[o] = e[o]); return s } function O(e) { if (!this.player || !this.player[e]) { let t = "ReactPlayer: ".concat(this.constructor.displayName, " player could not call %c").concat(e, "%c \u2013 "); return this.player ? this.player[e] || (t += "The method was not available") : t += "The player was not available", console.warn(t, "font-weight: bold", ""), null } for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; return this.player[e](...n) } function A(e) { return "undefined" !== typeof window && "undefined" !== typeof window.MediaStream && e instanceof window.MediaStream } function N(e) { return /^blob:/.test(e) } function j() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document.createElement("video"); const t = !1 === /iPhone|iPod/.test(navigator.userAgent); return e.webkitSupportsPresentationMode && "function" === typeof e.webkitSetPresentationMode && t } }, 6374: (e, t, n) => { "use strict"; var i = n(2791), r = Symbol.for("react.element"), s = Symbol.for("react.fragment"), a = Object.prototype.hasOwnProperty, o = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, l = { key: !0, ref: !0, __self: !0, __source: !0 }; function c(e, t, n) { var i, s = {}, c = null, u = null; for (i in void 0 !== n && (c = "" + n), void 0 !== t.key && (c = "" + t.key), void 0 !== t.ref && (u = t.ref), t) a.call(t, i) && !l.hasOwnProperty(i) && (s[i] = t[i]); if (e && e.defaultProps) for (i in t = e.defaultProps) void 0 === s[i] && (s[i] = t[i]); return { $$typeof: r, type: e, key: c, ref: u, props: s, _owner: o.current } } t.Fragment = s, t.jsx = c, t.jsxs = c }, 9117: (e, t) => { "use strict"; var n = Symbol.for("react.element"), i = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), p = Symbol.iterator; var f = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, m = Object.assign, g = {}; function y(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || f } function v() { } function b(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || f } y.prototype.isReactComponent = {}, y.prototype.setState = function (e, t) { if ("object" !== typeof e && "function" !== typeof e && null != e) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }, y.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }, v.prototype = y.prototype; var _ = b.prototype = new v; _.constructor = b, m(_, y.prototype), _.isPureReactComponent = !0; var T = Array.isArray, S = Object.prototype.hasOwnProperty, w = { current: null }, x = { key: !0, ref: !0, __self: !0, __source: !0 }; function k(e, t, i) { var r, s = {}, a = null, o = null; if (null != t) for (r in void 0 !== t.ref && (o = t.ref), void 0 !== t.key && (a = "" + t.key), t) S.call(t, r) && !x.hasOwnProperty(r) && (s[r] = t[r]); var l = arguments.length - 2; if (1 === l) s.children = i; else if (1 < l) { for (var c = Array(l), u = 0; u < l; u++)c[u] = arguments[u + 2]; s.children = c } if (e && e.defaultProps) for (r in l = e.defaultProps) void 0 === s[r] && (s[r] = l[r]); return { $$typeof: n, type: e, key: a, ref: o, props: s, _owner: w.current } } function E(e) { return "object" === typeof e && null !== e && e.$$typeof === n } var C = /\/+/g; function P(e, t) { return "object" === typeof e && null !== e && null != e.key ? function (e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, (function (e) { return t[e] })) }("" + e.key) : t.toString(36) } function I(e, t, r, s, a) { var o = typeof e; "undefined" !== o && "boolean" !== o || (e = null); var l = !1; if (null === e) l = !0; else switch (o) { case "string": case "number": l = !0; break; case "object": switch (e.$$typeof) { case n: case i: l = !0 } }if (l) return a = a(l = e), e = "" === s ? "." + P(l, 0) : s, T(a) ? (r = "", null != e && (r = e.replace(C, "$&/") + "/"), I(a, t, r, "", (function (e) { return e }))) : null != a && (E(a) && (a = function (e, t) { return { $$typeof: n, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } }(a, r + (!a.key || l && l.key === a.key ? "" : ("" + a.key).replace(C, "$&/") + "/") + e)), t.push(a)), 1; if (l = 0, s = "" === s ? "." : s + ":", T(e)) for (var c = 0; c < e.length; c++) { var u = s + P(o = e[c], c); l += I(o, t, r, u, a) } else if (u = function (e) { return null === e || "object" !== typeof e ? null : "function" === typeof (e = p && e[p] || e["@@iterator"]) ? e : null }(e), "function" === typeof u) for (e = u.call(e), c = 0; !(o = e.next()).done;)l += I(o = o.value, t, r, u = s + P(o, c++), a); else if ("object" === o) throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return l } function L(e, t, n) { if (null == e) return e; var i = [], r = 0; return I(e, i, "", "", (function (e) { return t.call(n, e, r++) })), i } function O(e) { if (-1 === e._status) { var t = e._result; (t = t()).then((function (t) { 0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t) }), (function (t) { 0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t) })), -1 === e._status && (e._status = 0, e._result = t) } if (1 === e._status) return e._result.default; throw e._result } var A = { current: null }, N = { transition: null }, j = { ReactCurrentDispatcher: A, ReactCurrentBatchConfig: N, ReactCurrentOwner: w }; t.Children = { map: L, forEach: function (e, t, n) { L(e, (function () { t.apply(this, arguments) }), n) }, count: function (e) { var t = 0; return L(e, (function () { t++ })), t }, toArray: function (e) { return L(e, (function (e) { return e })) || [] }, only: function (e) { if (!E(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }, t.Component = y, t.Fragment = r, t.Profiler = a, t.PureComponent = b, t.StrictMode = s, t.Suspense = u, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = j, t.cloneElement = function (e, t, i) { if (null === e || void 0 === e) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = m({}, e.props), s = e.key, a = e.ref, o = e._owner; if (null != t) { if (void 0 !== t.ref && (a = t.ref, o = w.current), void 0 !== t.key && (s = "" + t.key), e.type && e.type.defaultProps) var l = e.type.defaultProps; for (c in t) S.call(t, c) && !x.hasOwnProperty(c) && (r[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c]) } var c = arguments.length - 2; if (1 === c) r.children = i; else if (1 < c) { l = Array(c); for (var u = 0; u < c; u++)l[u] = arguments[u + 2]; r.children = l } return { $$typeof: n, type: e.type, key: s, ref: a, props: r, _owner: o } }, t.createContext = function (e) { return (e = { $$typeof: l, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }).Provider = { $$typeof: o, _context: e }, e.Consumer = e }, t.createElement = k, t.createFactory = function (e) { var t = k.bind(null, e); return t.type = e, t }, t.createRef = function () { return { current: null } }, t.forwardRef = function (e) { return { $$typeof: c, render: e } }, t.isValidElement = E, t.lazy = function (e) { return { $$typeof: h, _payload: { _status: -1, _result: e }, _init: O } }, t.memo = function (e, t) { return { $$typeof: d, type: e, compare: void 0 === t ? null : t } }, t.startTransition = function (e) { var t = N.transition; N.transition = {}; try { e() } finally { N.transition = t } }, t.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }, t.useCallback = function (e, t) { return A.current.useCallback(e, t) }, t.useContext = function (e) { return A.current.useContext(e) }, t.useDebugValue = function () { }, t.useDeferredValue = function (e) { return A.current.useDeferredValue(e) }, t.useEffect = function (e, t) { return A.current.useEffect(e, t) }, t.useId = function () { return A.current.useId() }, t.useImperativeHandle = function (e, t, n) { return A.current.useImperativeHandle(e, t, n) }, t.useInsertionEffect = function (e, t) { return A.current.useInsertionEffect(e, t) }, t.useLayoutEffect = function (e, t) { return A.current.useLayoutEffect(e, t) }, t.useMemo = function (e, t) { return A.current.useMemo(e, t) }, t.useReducer = function (e, t, n) { return A.current.useReducer(e, t, n) }, t.useRef = function (e) { return A.current.useRef(e) }, t.useState = function (e) { return A.current.useState(e) }, t.useSyncExternalStore = function (e, t, n) { return A.current.useSyncExternalStore(e, t, n) }, t.useTransition = function () { return A.current.useTransition() }, t.version = "18.2.0" }, 2791: (e, t, n) => { "use strict"; e.exports = n(9117) }, 184: (e, t, n) => { "use strict"; e.exports = n(6374) }, 4947: e => { e.exports = function (e, t) { var n, i = null; try { n = JSON.parse(e, t) } catch (r) { i = r } return [i, n] } }, 6813: (e, t) => { "use strict"; function n(e, t) { var n = e.length; e.push(t); e: for (; 0 < n;) { var i = n - 1 >>> 1, r = e[i]; if (!(0 < s(r, t))) break e; e[i] = t, e[n] = r, n = i } } function i(e) { return 0 === e.length ? null : e[0] } function r(e) { if (0 === e.length) return null; var t = e[0], n = e.pop(); if (n !== t) { e[0] = n; e: for (var i = 0, r = e.length, a = r >>> 1; i < a;) { var o = 2 * (i + 1) - 1, l = e[o], c = o + 1, u = e[c]; if (0 > s(l, n)) c < r && 0 > s(u, l) ? (e[i] = u, e[c] = n, i = c) : (e[i] = l, e[o] = n, i = o); else { if (!(c < r && 0 > s(u, n))) break e; e[i] = u, e[c] = n, i = c } } } return t } function s(e, t) { var n = e.sortIndex - t.sortIndex; return 0 !== n ? n : e.id - t.id } if ("object" === typeof performance && "function" === typeof performance.now) { var a = performance; t.unstable_now = function () { return a.now() } } else { var o = Date, l = o.now(); t.unstable_now = function () { return o.now() - l } } var c = [], u = [], d = 1, h = null, p = 3, f = !1, m = !1, g = !1, y = "function" === typeof setTimeout ? setTimeout : null, v = "function" === typeof clearTimeout ? clearTimeout : null, b = "undefined" !== typeof setImmediate ? setImmediate : null; function _(e) { for (var t = i(u); null !== t;) { if (null === t.callback) r(u); else { if (!(t.startTime <= e)) break; r(u), t.sortIndex = t.expirationTime, n(c, t) } t = i(u) } } function T(e) { if (g = !1, _(e), !m) if (null !== i(c)) m = !0, N(S); else { var t = i(u); null !== t && j(T, t.startTime - e) } } function S(e, n) { m = !1, g && (g = !1, v(E), E = -1), f = !0; var s = p; try { for (_(n), h = i(c); null !== h && (!(h.expirationTime > n) || e && !I());) { var a = h.callback; if ("function" === typeof a) { h.callback = null, p = h.priorityLevel; var o = a(h.expirationTime <= n); n = t.unstable_now(), "function" === typeof o ? h.callback = o : h === i(c) && r(c), _(n) } else r(c); h = i(c) } if (null !== h) var l = !0; else { var d = i(u); null !== d && j(T, d.startTime - n), l = !1 } return l } finally { h = null, p = s, f = !1 } } "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling); var w, x = !1, k = null, E = -1, C = 5, P = -1; function I() { return !(t.unstable_now() - P < C) } function L() { if (null !== k) { var e = t.unstable_now(); P = e; var n = !0; try { n = k(!0, e) } finally { n ? w() : (x = !1, k = null) } } else x = !1 } if ("function" === typeof b) w = function () { b(L) }; else if ("undefined" !== typeof MessageChannel) { var O = new MessageChannel, A = O.port2; O.port1.onmessage = L, w = function () { A.postMessage(null) } } else w = function () { y(L, 0) }; function N(e) { k = e, x || (x = !0, w()) } function j(e, n) { E = y((function () { e(t.unstable_now()) }), n) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (e) { e.callback = null }, t.unstable_continueExecution = function () { m || f || (m = !0, N(S)) }, t.unstable_forceFrameRate = function (e) { 0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < e ? Math.floor(1e3 / e) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return p }, t.unstable_getFirstCallbackNode = function () { return i(c) }, t.unstable_next = function (e) { switch (p) { case 1: case 2: case 3: var t = 3; break; default: t = p }var n = p; p = t; try { return e() } finally { p = n } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3 }var n = p; p = e; try { return t() } finally { p = n } }, t.unstable_scheduleCallback = function (e, r, s) { var a = t.unstable_now(); switch ("object" === typeof s && null !== s ? s = "number" === typeof (s = s.delay) && 0 < s ? a + s : a : s = a, e) { case 1: var o = -1; break; case 2: o = 250; break; case 5: o = 1073741823; break; case 4: o = 1e4; break; default: o = 5e3 }return e = { id: d++, callback: r, priorityLevel: e, startTime: s, expirationTime: o = s + o, sortIndex: -1 }, s > a ? (e.sortIndex = s, n(u, e), null === i(c) && e === i(u) && (g ? (v(E), E = -1) : g = !0, j(T, s - a))) : (e.sortIndex = o, n(c, e), m || f || (m = !0, N(S))), e }, t.unstable_shouldYield = I, t.unstable_wrapCallback = function (e) { var t = p; return function () { var n = p; p = t; try { return e.apply(this, arguments) } finally { p = n } } } }, 5296: (e, t, n) => { "use strict"; e.exports = n(6813) }, 4556: function (e) { !function (t) { var n = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, i = /^(?=([^\/?#]*))\1([^]*)$/, r = /(?:\/|^)\.(?=\/)/g, s = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, a = { buildAbsoluteURL: function (e, t, n) { if (n = n || {}, e = e.trim(), !(t = t.trim())) { if (!n.alwaysNormalize) return e; var r = a.parseURL(e); if (!r) throw new Error("Error trying to parse base URL."); return r.path = a.normalizePath(r.path), a.buildURLFromParts(r) } var s = a.parseURL(t); if (!s) throw new Error("Error trying to parse relative URL."); if (s.scheme) return n.alwaysNormalize ? (s.path = a.normalizePath(s.path), a.buildURLFromParts(s)) : t; var o = a.parseURL(e); if (!o) throw new Error("Error trying to parse base URL."); if (!o.netLoc && o.path && "/" !== o.path[0]) { var l = i.exec(o.path); o.netLoc = l[1], o.path = l[2] } o.netLoc && !o.path && (o.path = "/"); var c = { scheme: o.scheme, netLoc: s.netLoc, path: null, params: s.params, query: s.query, fragment: s.fragment }; if (!s.netLoc && (c.netLoc = o.netLoc, "/" !== s.path[0])) if (s.path) { var u = o.path, d = u.substring(0, u.lastIndexOf("/") + 1) + s.path; c.path = a.normalizePath(d) } else c.path = o.path, s.params || (c.params = o.params, s.query || (c.query = o.query)); return null === c.path && (c.path = n.alwaysNormalize ? a.normalizePath(s.path) : s.path), a.buildURLFromParts(c) }, parseURL: function (e) { var t = n.exec(e); return t ? { scheme: t[1] || "", netLoc: t[2] || "", path: t[3] || "", params: t[4] || "", query: t[5] || "", fragment: t[6] || "" } : null }, normalizePath: function (e) { for (e = e.split("").reverse().join("").replace(r, ""); e.length !== (e = e.replace(s, "")).length;); return e.split("").reverse().join("") }, buildURLFromParts: function (e) { return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment } }; e.exports = a }() }, 1561: (e, t, n) => { "use strict"; var i = n(2791); var r = "function" === typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t }, s = i.useState, a = i.useEffect, o = i.useLayoutEffect, l = i.useDebugValue; function c(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !r(e, n) } catch (i) { return !0 } } var u = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? function (e, t) { return t() } : function (e, t) { var n = t(), i = s({ inst: { value: n, getSnapshot: t } }), r = i[0].inst, u = i[1]; return o((function () { r.value = n, r.getSnapshot = t, c(r) && u({ inst: r }) }), [e, n, t]), a((function () { return c(r) && u({ inst: r }), e((function () { c(r) && u({ inst: r }) })) }), [e]), l(n), n }; t.useSyncExternalStore = void 0 !== i.useSyncExternalStore ? i.useSyncExternalStore : u }, 7595: (e, t, n) => { "use strict"; var i = n(2791), r = n(7248); var s = "function" === typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t }, a = r.useSyncExternalStore, o = i.useRef, l = i.useEffect, c = i.useMemo, u = i.useDebugValue; t.useSyncExternalStoreWithSelector = function (e, t, n, i, r) { var d = o(null); if (null === d.current) { var h = { hasValue: !1, value: null }; d.current = h } else h = d.current; d = c((function () { function e(e) { if (!l) { if (l = !0, a = e, e = i(e), void 0 !== r && h.hasValue) { var t = h.value; if (r(t, e)) return o = t } return o = e } if (t = o, s(a, e)) return t; var n = i(e); return void 0 !== r && r(t, n) ? t : (a = e, o = n) } var a, o, l = !1, c = void 0 === n ? null : n; return [function () { return e(t()) }, null === c ? void 0 : function () { return e(c()) }] }), [t, n, i, r]); var p = a(e, d[0], d[1]); return l((function () { h.hasValue = !0, h.value = p }), [p]), u(p), p } }, 7248: (e, t, n) => { "use strict"; e.exports = n(1561) }, 327: (e, t, n) => { "use strict"; e.exports = n(7595) }, 566: (e, t, n) => { var i = n(9851), r = e.exports = { WebVTT: n(7914), VTTCue: n(5616), VTTRegion: n(9320) }; i.vttjs = r, i.WebVTT = r.WebVTT; var s = r.VTTCue, a = r.VTTRegion, o = i.VTTCue, l = i.VTTRegion; r.shim = function () { i.VTTCue = s, i.VTTRegion = a }, r.restore = function () { i.VTTCue = o, i.VTTRegion = l }, i.VTTCue || r.shim() }, 7914: (e, t, n) => { var i = n(7203), r = Object.create || function () { function e() { } return function (t) { if (1 !== arguments.length) throw new Error("Object.create shim only accepts one parameter."); return e.prototype = t, new e } }(); function s(e, t) { this.name = "ParsingError", this.code = e.code, this.message = t || e.message } function a(e) { function t(e, t, n, i) { return 3600 * (0 | e) + 60 * (0 | t) + (0 | n) + (0 | i) / 1e3 } var n = e.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/); return n ? n[3] ? t(n[1], n[2], n[3].replace(":", ""), n[4]) : n[1] > 59 ? t(n[1], n[2], 0, n[4]) : t(0, n[1], n[2], n[4]) : null } function o() { this.values = r(null) } function l(e, t, n, i) { var r = i ? e.split(i) : [e]; for (var s in r) if ("string" === typeof r[s]) { var a = r[s].split(n); if (2 === a.length) t(a[0].trim(), a[1].trim()) } } function c(e, t, n) { var i = e; function r() { var t = a(e); if (null === t) throw new s(s.Errors.BadTimeStamp, "Malformed timestamp: " + i); return e = e.replace(/^[^\sa-zA-Z-]+/, ""), t } function c() { e = e.replace(/^\s+/, "") } if (c(), t.startTime = r(), c(), "--\x3e" !== e.substr(0, 3)) throw new s(s.Errors.BadTimeStamp, "Malformed time stamp (time stamps must be separated by '--\x3e'): " + i); e = e.substr(3), c(), t.endTime = r(), c(), function (e, t) { var i = new o; l(e, (function (e, t) { switch (e) { case "region": for (var r = n.length - 1; r >= 0; r--)if (n[r].id === t) { i.set(e, n[r].region); break } break; case "vertical": i.alt(e, t, ["rl", "lr"]); break; case "line": var s = t.split(","), a = s[0]; i.integer(e, a), i.percent(e, a) && i.set("snapToLines", !1), i.alt(e, a, ["auto"]), 2 === s.length && i.alt("lineAlign", s[1], ["start", "center", "end"]); break; case "position": s = t.split(","), i.percent(e, s[0]), 2 === s.length && i.alt("positionAlign", s[1], ["start", "center", "end"]); break; case "size": i.percent(e, t); break; case "align": i.alt(e, t, ["start", "center", "end", "left", "right"]) } }), /:/, /\s/), t.region = i.get("region", null), t.vertical = i.get("vertical", ""); try { t.line = i.get("line", "auto") } catch (r) { } t.lineAlign = i.get("lineAlign", "start"), t.snapToLines = i.get("snapToLines", !0), t.size = i.get("size", 100); try { t.align = i.get("align", "center") } catch (r) { t.align = i.get("align", "middle") } try { t.position = i.get("position", "auto") } catch (r) { t.position = i.get("position", { start: 0, left: 0, center: 50, middle: 50, end: 100, right: 100 }, t.align) } t.positionAlign = i.get("positionAlign", { start: "start", left: "start", center: "center", middle: "center", end: "end", right: "end" }, t.align) }(e, t) } s.prototype = r(Error.prototype), s.prototype.constructor = s, s.Errors = { BadSignature: { code: 0, message: "Malformed WebVTT signature." }, BadTimeStamp: { code: 1, message: "Malformed time stamp." } }, o.prototype = { set: function (e, t) { this.get(e) || "" === t || (this.values[e] = t) }, get: function (e, t, n) { return n ? this.has(e) ? this.values[e] : t[n] : this.has(e) ? this.values[e] : t }, has: function (e) { return e in this.values }, alt: function (e, t, n) { for (var i = 0; i < n.length; ++i)if (t === n[i]) { this.set(e, t); break } }, integer: function (e, t) { /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10)) }, percent: function (e, t) { return !!(t.match(/^([\d]{1,3})(\.[\d]*)?%$/) && (t = parseFloat(t)) >= 0 && t <= 100) && (this.set(e, t), !0) } }; var u = i.createElement && i.createElement("textarea"), d = { c: "span", i: "i", b: "b", u: "u", ruby: "ruby", rt: "rt", v: "span", lang: "span" }, h = { white: "rgba(255,255,255,1)", lime: "rgba(0,255,0,1)", cyan: "rgba(0,255,255,1)", red: "rgba(255,0,0,1)", yellow: "rgba(255,255,0,1)", magenta: "rgba(255,0,255,1)", blue: "rgba(0,0,255,1)", black: "rgba(0,0,0,1)" }, p = { v: "title", lang: "lang" }, f = { rt: "ruby" }; function m(e, t) { function n() { if (!t) return null; var e, n = t.match(/^([^<]*)(<[^>]*>?)?/); return e = n[1] ? n[1] : n[2], t = t.substr(e.length), e } function i(e, t) { return !f[t.localName] || f[t.localName] === e.localName } function r(t, n) { var i = d[t]; if (!i) return null; var r = e.document.createElement(i), s = p[t]; return s && n && (r[s] = n.trim()), r } for (var s, o, l = e.document.createElement("div"), c = l, m = []; null !== (s = n());)if ("<" !== s[0]) c.appendChild(e.document.createTextNode((o = s, u.innerHTML = o, o = u.textContent, u.textContent = "", o))); else { if ("/" === s[1]) { m.length && m[m.length - 1] === s.substr(2).replace(">", "") && (m.pop(), c = c.parentNode); continue } var g, y = a(s.substr(1, s.length - 2)); if (y) { g = e.document.createProcessingInstruction("timestamp", y), c.appendChild(g); continue } var v = s.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/); if (!v) continue; if (!(g = r(v[1], v[3]))) continue; if (!i(c, g)) continue; if (v[2]) { var b = v[2].split("."); b.forEach((function (e) { var t = /^bg_/.test(e), n = t ? e.slice(3) : e; if (h.hasOwnProperty(n)) { var i = t ? "background-color" : "color", r = h[n]; g.style[i] = r } })), g.className = b.join(" ") } m.push(v[1]), c.appendChild(g), c = g } return l } var g = [[1470, 1470], [1472, 1472], [1475, 1475], [1478, 1478], [1488, 1514], [1520, 1524], [1544, 1544], [1547, 1547], [1549, 1549], [1563, 1563], [1566, 1610], [1645, 1647], [1649, 1749], [1765, 1766], [1774, 1775], [1786, 1805], [1807, 1808], [1810, 1839], [1869, 1957], [1969, 1969], [1984, 2026], [2036, 2037], [2042, 2042], [2048, 2069], [2074, 2074], [2084, 2084], [2088, 2088], [2096, 2110], [2112, 2136], [2142, 2142], [2208, 2208], [2210, 2220], [8207, 8207], [64285, 64285], [64287, 64296], [64298, 64310], [64312, 64316], [64318, 64318], [64320, 64321], [64323, 64324], [64326, 64449], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65020], [65136, 65140], [65142, 65276], [67584, 67589], [67592, 67592], [67594, 67637], [67639, 67640], [67644, 67644], [67647, 67669], [67671, 67679], [67840, 67867], [67872, 67897], [67903, 67903], [67968, 68023], [68030, 68031], [68096, 68096], [68112, 68115], [68117, 68119], [68121, 68147], [68160, 68167], [68176, 68184], [68192, 68223], [68352, 68405], [68416, 68437], [68440, 68466], [68472, 68479], [68608, 68680], [126464, 126467], [126469, 126495], [126497, 126498], [126500, 126500], [126503, 126503], [126505, 126514], [126516, 126519], [126521, 126521], [126523, 126523], [126530, 126530], [126535, 126535], [126537, 126537], [126539, 126539], [126541, 126543], [126545, 126546], [126548, 126548], [126551, 126551], [126553, 126553], [126555, 126555], [126557, 126557], [126559, 126559], [126561, 126562], [126564, 126564], [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], [126590, 126590], [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [1114109, 1114109]]; function y(e) { for (var t = 0; t < g.length; t++) { var n = g[t]; if (e >= n[0] && e <= n[1]) return !0 } return !1 } function v(e) { var t = [], n = ""; if (!e || !e.childNodes) return "ltr"; function i(e, t) { for (var n = t.childNodes.length - 1; n >= 0; n--)e.push(t.childNodes[n]) } function r(e) { if (!e || !e.length) return null; var t = e.pop(), n = t.textContent || t.innerText; if (n) { var s = n.match(/^.*(\n|\r)/); return s ? (e.length = 0, s[0]) : n } return "ruby" === t.tagName ? r(e) : t.childNodes ? (i(e, t), r(e)) : void 0 } for (i(t, e); n = r(t);)for (var s = 0; s < n.length; s++)if (y(n.charCodeAt(s))) return "rtl"; return "ltr" } function b() { } function _(e, t, n) { b.call(this), this.cue = t, this.cueDiv = m(e, t.text); var i = { color: "rgba(255, 255, 255, 1)", backgroundColor: "rgba(0, 0, 0, 0.8)", position: "relative", left: 0, right: 0, top: 0, bottom: 0, display: "inline", writingMode: "" === t.vertical ? "horizontal-tb" : "lr" === t.vertical ? "vertical-lr" : "vertical-rl", unicodeBidi: "plaintext" }; this.applyStyles(i, this.cueDiv), this.div = e.document.createElement("div"), i = { direction: v(this.cueDiv), writingMode: "" === t.vertical ? "horizontal-tb" : "lr" === t.vertical ? "vertical-lr" : "vertical-rl", unicodeBidi: "plaintext", textAlign: "middle" === t.align ? "center" : t.align, font: n.font, whiteSpace: "pre-line", position: "absolute" }, this.applyStyles(i), this.div.appendChild(this.cueDiv); var r = 0; switch (t.positionAlign) { case "start": r = t.position; break; case "center": r = t.position - t.size / 2; break; case "end": r = t.position - t.size }"" === t.vertical ? this.applyStyles({ left: this.formatStyle(r, "%"), width: this.formatStyle(t.size, "%") }) : this.applyStyles({ top: this.formatStyle(r, "%"), height: this.formatStyle(t.size, "%") }), this.move = function (e) { this.applyStyles({ top: this.formatStyle(e.top, "px"), bottom: this.formatStyle(e.bottom, "px"), left: this.formatStyle(e.left, "px"), right: this.formatStyle(e.right, "px"), height: this.formatStyle(e.height, "px"), width: this.formatStyle(e.width, "px") }) } } function T(e) { var t, n, i, r; if (e.div) { n = e.div.offsetHeight, i = e.div.offsetWidth, r = e.div.offsetTop; var s = (s = e.div.childNodes) && (s = s[0]) && s.getClientRects && s.getClientRects(); e = e.div.getBoundingClientRect(), t = s ? Math.max(s[0] && s[0].height || 0, e.height / s.length) : 0 } this.left = e.left, this.right = e.right, this.top = e.top || r, this.height = e.height || n, this.bottom = e.bottom || r + (e.height || n), this.width = e.width || i, this.lineHeight = void 0 !== t ? t : e.lineHeight } function S(e, t, n, i) { var r = new T(t), s = t.cue, a = function (e) { if ("number" === typeof e.line && (e.snapToLines || e.line >= 0 && e.line <= 100)) return e.line; if (!e.track || !e.track.textTrackList || !e.track.textTrackList.mediaElement) return -1; for (var t = e.track, n = t.textTrackList, i = 0, r = 0; r < n.length && n[r] !== t; r++)"showing" === n[r].mode && i++; return -1 * ++i }(s), o = []; if (s.snapToLines) { var l; switch (s.vertical) { case "": o = ["+y", "-y"], l = "height"; break; case "rl": o = ["+x", "-x"], l = "width"; break; case "lr": o = ["-x", "+x"], l = "width" }var c = r.lineHeight, u = c * Math.round(a), d = n[l] + c, h = o[0]; Math.abs(u) > d && (u = u < 0 ? -1 : 1, u *= Math.ceil(d / c) * c), a < 0 && (u += "" === s.vertical ? n.height : n.width, o = o.reverse()), r.move(h, u) } else { var p = r.lineHeight / n.height * 100; switch (s.lineAlign) { case "center": a -= p / 2; break; case "end": a -= p }switch (s.vertical) { case "": t.applyStyles({ top: t.formatStyle(a, "%") }); break; case "rl": t.applyStyles({ left: t.formatStyle(a, "%") }); break; case "lr": t.applyStyles({ right: t.formatStyle(a, "%") }) }o = ["+y", "-x", "+x", "-y"], r = new T(t) } var f = function (e, t) { for (var r, s = new T(e), a = 1, o = 0; o < t.length; o++) { for (; e.overlapsOppositeAxis(n, t[o]) || e.within(n) && e.overlapsAny(i);)e.move(t[o]); if (e.within(n)) return e; var l = e.intersectPercentage(n); a > l && (r = new T(e), a = l), e = new T(s) } return r || s }(r, o); t.move(f.toCSSCompatValues(n)) } function w() { } b.prototype.applyStyles = function (e, t) { for (var n in t = t || this.div, e) e.hasOwnProperty(n) && (t.style[n] = e[n]) }, b.prototype.formatStyle = function (e, t) { return 0 === e ? 0 : e + t }, _.prototype = r(b.prototype), _.prototype.constructor = _, T.prototype.move = function (e, t) { switch (t = void 0 !== t ? t : this.lineHeight, e) { case "+x": this.left += t, this.right += t; break; case "-x": this.left -= t, this.right -= t; break; case "+y": this.top += t, this.bottom += t; break; case "-y": this.top -= t, this.bottom -= t } }, T.prototype.overlaps = function (e) { return this.left < e.right && this.right > e.left && this.top < e.bottom && this.bottom > e.top }, T.prototype.overlapsAny = function (e) { for (var t = 0; t < e.length; t++)if (this.overlaps(e[t])) return !0; return !1 }, T.prototype.within = function (e) { return this.top >= e.top && this.bottom <= e.bottom && this.left >= e.left && this.right <= e.right }, T.prototype.overlapsOppositeAxis = function (e, t) { switch (t) { case "+x": return this.left < e.left; case "-x": return this.right > e.right; case "+y": return this.top < e.top; case "-y": return this.bottom > e.bottom } }, T.prototype.intersectPercentage = function (e) { return Math.max(0, Math.min(this.right, e.right) - Math.max(this.left, e.left)) * Math.max(0, Math.min(this.bottom, e.bottom) - Math.max(this.top, e.top)) / (this.height * this.width) }, T.prototype.toCSSCompatValues = function (e) { return { top: this.top - e.top, bottom: e.bottom - this.bottom, left: this.left - e.left, right: e.right - this.right, height: this.height, width: this.width } }, T.getSimpleBoxPosition = function (e) { var t = e.div ? e.div.offsetHeight : e.tagName ? e.offsetHeight : 0, n = e.div ? e.div.offsetWidth : e.tagName ? e.offsetWidth : 0, i = e.div ? e.div.offsetTop : e.tagName ? e.offsetTop : 0; return { left: (e = e.div ? e.div.getBoundingClientRect() : e.tagName ? e.getBoundingClientRect() : e).left, right: e.right, top: e.top || i, height: e.height || t, bottom: e.bottom || i + (e.height || t), width: e.width || n } }, w.StringDecoder = function () { return { decode: function (e) { if (!e) return ""; if ("string" !== typeof e) throw new Error("Error - expected string data."); return decodeURIComponent(encodeURIComponent(e)) } } }, w.convertCueToDOMTree = function (e, t) { return e && t ? m(e, t) : null }; w.processCues = function (e, t, n) { if (!e || !t || !n) return null; for (; n.firstChild;)n.removeChild(n.firstChild); var i = e.document.createElement("div"); if (i.style.position = "absolute", i.style.left = "0", i.style.right = "0", i.style.top = "0", i.style.bottom = "0", i.style.margin = "1.5%", n.appendChild(i), function (e) { for (var t = 0; t < e.length; t++)if (e[t].hasBeenReset || !e[t].displayState) return !0; return !1 }(t)) { var r = [], s = T.getSimpleBoxPosition(i), a = { font: Math.round(.05 * s.height * 100) / 100 + "px sans-serif" }; !function () { for (var n, o, l = 0; l < t.length; l++)o = t[l], n = new _(e, o, a), i.appendChild(n.div), S(0, n, s, r), o.displayState = n.div, r.push(T.getSimpleBoxPosition(n)) }() } else for (var o = 0; o < t.length; o++)i.appendChild(t[o].displayState) }, w.Parser = function (e, t, n) { n || (n = t, t = {}), t || (t = {}), this.window = e, this.vttjs = t, this.state = "INITIAL", this.buffer = "", this.decoder = n || new TextDecoder("utf8"), this.regionList = [] }, w.Parser.prototype = { reportOrThrowError: function (e) { if (!(e instanceof s)) throw e; this.onparsingerror && this.onparsingerror(e) }, parse: function (e) { var t = this; function n() { for (var e = t.buffer, n = 0; n < e.length && "\r" !== e[n] && "\n" !== e[n];)++n; var i = e.substr(0, n); return "\r" === e[n] && ++n, "\n" === e[n] && ++n, t.buffer = e.substr(n), i } function i(e) { e.match(/X-TIMESTAMP-MAP/) ? l(e, (function (e, n) { if ("X-TIMESTAMP-MAP" === e) !function (e) { var n = new o; l(e, (function (e, t) { switch (e) { case "MPEGT": n.integer(e + "S", t); break; case "LOCA": n.set(e + "L", a(t)) } }), /[^\d]:/, /,/), t.ontimestampmap && t.ontimestampmap({ MPEGTS: n.get("MPEGTS"), LOCAL: n.get("LOCAL") }) }(n) }), /=/) : l(e, (function (e, n) { if ("Region" === e) !function (e) { var n = new o; if (l(e, (function (e, t) { switch (e) { case "id": n.set(e, t); break; case "width": n.percent(e, t); break; case "lines": n.integer(e, t); break; case "regionanchor": case "viewportanchor": var i = t.split(","); if (2 !== i.length) break; var r = new o; if (r.percent("x", i[0]), r.percent("y", i[1]), !r.has("x") || !r.has("y")) break; n.set(e + "X", r.get("x")), n.set(e + "Y", r.get("y")); break; case "scroll": n.alt(e, t, ["up"]) } }), /=/, /\s/), n.has("id")) { var i = new (t.vttjs.VTTRegion || t.window.VTTRegion); i.width = n.get("width", 100), i.lines = n.get("lines", 3), i.regionAnchorX = n.get("regionanchorX", 0), i.regionAnchorY = n.get("regionanchorY", 100), i.viewportAnchorX = n.get("viewportanchorX", 0), i.viewportAnchorY = n.get("viewportanchorY", 100), i.scroll = n.get("scroll", ""), t.onregion && t.onregion(i), t.regionList.push({ id: n.get("id"), region: i }) } }(n) }), /:/) } e && (t.buffer += t.decoder.decode(e, { stream: !0 })); try { var r; if ("INITIAL" === t.state) { if (!/\r\n|\n/.test(t.buffer)) return this; var u = (r = n()).match(/^WEBVTT([ \t].*)?$/); if (!u || !u[0]) throw new s(s.Errors.BadSignature); t.state = "HEADER" } for (var d = !1; t.buffer;) { if (!/\r\n|\n/.test(t.buffer)) return this; switch (d ? d = !1 : r = n(), t.state) { case "HEADER": /:/.test(r) ? i(r) : r || (t.state = "ID"); continue; case "NOTE": r || (t.state = "ID"); continue; case "ID": if (/^NOTE($|[ \t])/.test(r)) { t.state = "NOTE"; break } if (!r) continue; t.cue = new (t.vttjs.VTTCue || t.window.VTTCue)(0, 0, ""); try { t.cue.align = "center" } catch (p) { t.cue.align = "middle" } if (t.state = "CUE", -1 === r.indexOf("--\x3e")) { t.cue.id = r; continue } case "CUE": try { c(r, t.cue, t.regionList) } catch (p) { t.reportOrThrowError(p), t.cue = null, t.state = "BADCUE"; continue } t.state = "CUETEXT"; continue; case "CUETEXT": var h = -1 !== r.indexOf("--\x3e"); if (!r || h && (d = !0)) { t.oncue && t.oncue(t.cue), t.cue = null, t.state = "ID"; continue } t.cue.text && (t.cue.text += "\n"), t.cue.text += r.replace(/\u2028/g, "\n").replace(/u2029/g, "\n"); continue; case "BADCUE": r || (t.state = "ID"); continue } } } catch (p) { t.reportOrThrowError(p), "CUETEXT" === t.state && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = "INITIAL" === t.state ? "BADWEBVTT" : "BADCUE" } return this }, flush: function () { var e = this; try { if (e.buffer += e.decoder.decode(), (e.cue || "HEADER" === e.state) && (e.buffer += "\n\n", e.parse()), "INITIAL" === e.state) throw new s(s.Errors.BadSignature) } catch (t) { e.reportOrThrowError(t) } return e.onflush && e.onflush(), this } }, e.exports = w }, 5616: e => { var t = { "": 1, lr: 1, rl: 1 }, n = { start: 1, center: 1, end: 1, left: 1, right: 1, auto: 1, "line-left": 1, "line-right": 1 }; function i(e) { return "string" === typeof e && (!!n[e.toLowerCase()] && e.toLowerCase()) } function r(e, n, r) { this.hasBeenReset = !1; var s = "", a = !1, o = e, l = n, c = r, u = null, d = "", h = !0, p = "auto", f = "start", m = "auto", g = "auto", y = 100, v = "center"; Object.defineProperties(this, { id: { enumerable: !0, get: function () { return s }, set: function (e) { s = "" + e } }, pauseOnExit: { enumerable: !0, get: function () { return a }, set: function (e) { a = !!e } }, startTime: { enumerable: !0, get: function () { return o }, set: function (e) { if ("number" !== typeof e) throw new TypeError("Start time must be set to a number."); o = e, this.hasBeenReset = !0 } }, endTime: { enumerable: !0, get: function () { return l }, set: function (e) { if ("number" !== typeof e) throw new TypeError("End time must be set to a number."); l = e, this.hasBeenReset = !0 } }, text: { enumerable: !0, get: function () { return c }, set: function (e) { c = "" + e, this.hasBeenReset = !0 } }, region: { enumerable: !0, get: function () { return u }, set: function (e) { u = e, this.hasBeenReset = !0 } }, vertical: { enumerable: !0, get: function () { return d }, set: function (e) { var n = function (e) { return "string" === typeof e && !!t[e.toLowerCase()] && e.toLowerCase() }(e); if (!1 === n) throw new SyntaxError("Vertical: an invalid or illegal direction string was specified."); d = n, this.hasBeenReset = !0 } }, snapToLines: { enumerable: !0, get: function () { return h }, set: function (e) { h = !!e, this.hasBeenReset = !0 } }, line: { enumerable: !0, get: function () { return p }, set: function (e) { if ("number" !== typeof e && "auto" !== e) throw new SyntaxError("Line: an invalid number or illegal string was specified."); p = e, this.hasBeenReset = !0 } }, lineAlign: { enumerable: !0, get: function () { return f }, set: function (e) { var t = i(e); t ? (f = t, this.hasBeenReset = !0) : console.warn("lineAlign: an invalid or illegal string was specified.") } }, position: { enumerable: !0, get: function () { return m }, set: function (e) { if (e < 0 || e > 100) throw new Error("Position must be between 0 and 100."); m = e, this.hasBeenReset = !0 } }, positionAlign: { enumerable: !0, get: function () { return g }, set: function (e) { var t = i(e); t ? (g = t, this.hasBeenReset = !0) : console.warn("positionAlign: an invalid or illegal string was specified.") } }, size: { enumerable: !0, get: function () { return y }, set: function (e) { if (e < 0 || e > 100) throw new Error("Size must be between 0 and 100."); y = e, this.hasBeenReset = !0 } }, align: { enumerable: !0, get: function () { return v }, set: function (e) { var t = i(e); if (!t) throw new SyntaxError("align: an invalid or illegal alignment string was specified."); v = t, this.hasBeenReset = !0 } } }), this.displayState = void 0 } r.prototype.getCueAsHTML = function () { return WebVTT.convertCueToDOMTree(window, this.text) }, e.exports = r }, 9320: e => { var t = { "": !0, up: !0 }; function n(e) { return "number" === typeof e && e >= 0 && e <= 100 } e.exports = function () { var e = 100, i = 3, r = 0, s = 100, a = 0, o = 100, l = ""; Object.defineProperties(this, { width: { enumerable: !0, get: function () { return e }, set: function (t) { if (!n(t)) throw new Error("Width must be between 0 and 100."); e = t } }, lines: { enumerable: !0, get: function () { return i }, set: function (e) { if ("number" !== typeof e) throw new TypeError("Lines must be set to a number."); i = e } }, regionAnchorY: { enumerable: !0, get: function () { return s }, set: function (e) { if (!n(e)) throw new Error("RegionAnchorX must be between 0 and 100."); s = e } }, regionAnchorX: { enumerable: !0, get: function () { return r }, set: function (e) { if (!n(e)) throw new Error("RegionAnchorY must be between 0 and 100."); r = e } }, viewportAnchorY: { enumerable: !0, get: function () { return o }, set: function (e) { if (!n(e)) throw new Error("ViewportAnchorY must be between 0 and 100."); o = e } }, viewportAnchorX: { enumerable: !0, get: function () { return a }, set: function (e) { if (!n(e)) throw new Error("ViewportAnchorX must be between 0 and 100."); a = e } }, scroll: { enumerable: !0, get: function () { return l }, set: function (e) { var n = function (e) { return "string" === typeof e && !!t[e.toLowerCase()] && e.toLowerCase() }(e); !1 === n ? console.warn("Scroll: an invalid or illegal string was specified.") : l = n } } }) } }, 5893: () => { }, 434: e => { function t() { return e.exports = t = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, e.exports.__esModule = !0, e.exports.default = e.exports, t.apply(this, arguments) } e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports } }, t = {}; function n(i) { var r = t[i]; if (void 0 !== r) return r.exports; var s = t[i] = { exports: {} }; return e[i].call(s.exports, s, s.exports, n), s.exports } n.m = e, n.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return n.d(t, { a: t }), t }, (() => { var e, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__; n.t = function (i, r) { if (1 & r && (i = this(i)), 8 & r) return i; if ("object" === typeof i && i) { if (4 & r && i.__esModule) return i; if (16 & r && "function" === typeof i.then) return i } var s = Object.create(null); n.r(s); var a = {}; e = e || [null, t({}), t([]), t(t)]; for (var o = 2 & r && i; "object" == typeof o && !~e.indexOf(o); o = t(o))Object.getOwnPropertyNames(o).forEach((e => a[e] = () => i[e])); return a.default = () => i, n.d(s, a), s } })(), n.d = (e, t) => { for (var i in t) n.o(t, i) && !n.o(e, i) && Object.defineProperty(e, i, { enumerable: !0, get: t[i] }) }, n.f = {}, n.e = e => Promise.all(Object.keys(n.f).reduce(((t, i) => (n.f[i](e, t), t)), [])), n.u = e => "static/js/" + ({ 11: "reactPlayerFilePlayer", 55: "reactPlayerWistia", 121: "reactPlayerFacebook", 125: "reactPlayerSoundCloud", 216: "reactPlayerTwitch", 258: "reactPlayerMux", 261: "reactPlayerKaltura", 439: "reactPlayerYouTube", 546: "reactPlayerStreamable", 596: "reactPlayerDailyMotion", 664: "reactPlayerPreview", 667: "reactPlayerMixcloud", 743: "reactPlayerVimeo", 888: "reactPlayerVidyard" }[e] || e) + "." + { 11: "a2532adb", 55: "c60f5197", 121: "65d1e685", 125: "a1a9c55b", 216: "69ff4fc4", 258: "edf0ec49", 261: "d433f239", 439: "050c9fbe", 546: "3828b65a", 596: "9c4534e8", 664: "446fd5be", 667: "b1821f64", 743: "2399e3ec", 787: "02296961", 888: "4b07b6f2" }[e] + ".chunk.js", n.miniCssF = e => { }, n.g = function () { if ("object" === typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (e) { if ("object" === typeof window) return window } }(), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => { var e = {}, t = "chocolate_react:"; n.l = (i, r, s, a) => { if (e[i]) e[i].push(r); else { var o, l; if (void 0 !== s) for (var c = document.getElementsByTagName("script"), u = 0; u < c.length; u++) { var d = c[u]; if (d.getAttribute("src") == i || d.getAttribute("data-webpack") == t + s) { o = d; break } } o || (l = !0, (o = document.createElement("script")).charset = "utf-8", o.timeout = 120, n.nc && o.setAttribute("nonce", n.nc), o.setAttribute("data-webpack", t + s), o.src = i), e[i] = [r]; var h = (t, n) => { o.onerror = o.onload = null, clearTimeout(p); var r = e[i]; if (delete e[i], o.parentNode && o.parentNode.removeChild(o), r && r.forEach((e => e(n))), t) return t(n) }, p = setTimeout(h.bind(null, void 0, { type: "timeout", target: o }), 12e4); o.onerror = h.bind(null, o.onerror), o.onload = h.bind(null, o.onload), l && document.head.appendChild(o) } } })(), n.r = e => { "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, n.p = "/", (() => { var e = { 179: 0 }; n.f.j = (t, i) => { var r = n.o(e, t) ? e[t] : void 0; if (0 !== r) if (r) i.push(r[2]); else { var s = new Promise(((n, i) => r = e[t] = [n, i])); i.push(r[2] = s); var a = n.p + n.u(t), o = new Error; n.l(a, (i => { if (n.o(e, t) && (0 !== (r = e[t]) && (e[t] = void 0), r)) { var s = i && ("load" === i.type ? "missing" : i.type), a = i && i.target && i.target.src; o.message = "Loading chunk " + t + " failed.\n(" + s + ": " + a + ")", o.name = "ChunkLoadError", o.type = s, o.request = a, r[1](o) } }), "chunk-" + t, t) } }; var t = (t, i) => { var r, s, a = i[0], o = i[1], l = i[2], c = 0; if (a.some((t => 0 !== e[t]))) { for (r in o) n.o(o, r) && (n.m[r] = o[r]); if (l) l(n) } for (t && t(i); c < a.length; c++)s = a[c], n.o(e, s) && e[s] && e[s][0](), e[s] = 0 }, i = self.webpackChunkchocolate_react = self.webpackChunkchocolate_react || []; i.forEach(t.bind(null, 0)), i.push = t.bind(null, i.push.bind(i)) })(), (() => { "use strict"; var e, t = n(2791), i = n(1250); function r() { return r = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, r.apply(this, arguments) } !function (e) { e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE" }(e || (e = {})); const s = "popstate"; function a(e, t) { if (!1 === e || null === e || "undefined" === typeof e) throw new Error(t) } function o(e, t) { if (!e) { "undefined" !== typeof console && console.warn(t); try { throw new Error(t) } catch (n) { } } } function l(e, t) { return { usr: e.state, key: e.key, idx: t } } function c(e, t, n, i) { return void 0 === n && (n = null), r({ pathname: "string" === typeof e ? e : e.pathname, search: "", hash: "" }, "string" === typeof t ? d(t) : t, { state: n, key: t && t.key || i || Math.random().toString(36).substr(2, 8) }) } function u(e) { let { pathname: t = "/", search: n = "", hash: i = "" } = e; return n && "?" !== n && (t += "?" === n.charAt(0) ? n : "?" + n), i && "#" !== i && (t += "#" === i.charAt(0) ? i : "#" + i), t } function d(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let i = e.indexOf("?"); i >= 0 && (t.search = e.substr(i), e = e.substr(0, i)), e && (t.pathname = e) } return t } function h(t, n, i, o) { void 0 === o && (o = {}); let { window: d = document.defaultView, v5Compat: h = !1 } = o, p = d.history, f = e.Pop, m = null, g = y(); function y() { return (p.state || { idx: null }).idx } function v() { f = e.Pop; let t = y(), n = null == t ? null : t - g; g = t, m && m({ action: f, location: _.location, delta: n }) } function b(e) { let t = "null" !== d.location.origin ? d.location.origin : d.location.href, n = "string" === typeof e ? e : u(e); return a(t, "No window.location.(origin|href) available to create URL for href: " + n), new URL(n, t) } null == g && (g = 0, p.replaceState(r({}, p.state, { idx: g }), "")); let _ = { get action() { return f }, get location() { return t(d, p) }, listen(e) { if (m) throw new Error("A history only accepts one active listener"); return d.addEventListener(s, v), m = e, () => { d.removeEventListener(s, v), m = null } }, createHref: e => n(d, e), createURL: b, encodeLocation(e) { let t = b(e); return { pathname: t.pathname, search: t.search, hash: t.hash } }, push: function (t, n) { f = e.Push; let r = c(_.location, t, n); i && i(r, t), g = y() + 1; let s = l(r, g), a = _.createHref(r); try { p.pushState(s, "", a) } catch (o) { d.location.assign(a) } h && m && m({ action: f, location: _.location, delta: 1 }) }, replace: function (t, n) { f = e.Replace; let r = c(_.location, t, n); i && i(r, t), g = y(); let s = l(r, g), a = _.createHref(r); p.replaceState(s, "", a), h && m && m({ action: f, location: _.location, delta: 0 }) }, go: e => p.go(e) }; return _ } var p; !function (e) { e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error" }(p || (p = {})); new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]); function f(e, t, n) { void 0 === n && (n = "/"); let i = P(("string" === typeof t ? d(t) : t).pathname || "/", n); if (null == i) return null; let r = m(e); !function (e) { e.sort(((e, t) => e.score !== t.score ? t.score - e.score : function (e, t) { let n = e.length === t.length && e.slice(0, -1).every(((e, n) => e === t[n])); return n ? e[e.length - 1] - t[t.length - 1] : 0 }(e.routesMeta.map((e => e.childrenIndex)), t.routesMeta.map((e => e.childrenIndex))))) }(r); let s = null; for (let a = 0; null == s && a < r.length; ++a)s = k(r[a], C(i)); return s } function m(e, t, n, i) { void 0 === t && (t = []), void 0 === n && (n = []), void 0 === i && (i = ""); let r = (e, r, s) => { let o = { relativePath: void 0 === s ? e.path || "" : s, caseSensitive: !0 === e.caseSensitive, childrenIndex: r, route: e }; o.relativePath.startsWith("/") && (a(o.relativePath.startsWith(i), 'Absolute route path "' + o.relativePath + '" nested under path "' + i + '" is not valid. An absolute child route path must start with the combined path of all its parent routes.'), o.relativePath = o.relativePath.slice(i.length)); let l = A([i, o.relativePath]), c = n.concat(o); e.children && e.children.length > 0 && (a(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path "' + l + '".'), m(e.children, t, c, l)), (null != e.path || e.index) && t.push({ path: l, score: x(l, e.index), routesMeta: c }) }; return e.forEach(((e, t) => { var n; if ("" !== e.path && null != (n = e.path) && n.includes("?")) for (let i of g(e.path)) r(e, t, i); else r(e, t) })), t } function g(e) { let t = e.split("/"); if (0 === t.length) return []; let [n, ...i] = t, r = n.endsWith("?"), s = n.replace(/\?$/, ""); if (0 === i.length) return r ? [s, ""] : [s]; let a = g(i.join("/")), o = []; return o.push(...a.map((e => "" === e ? s : [s, e].join("/")))), r && o.push(...a), o.map((t => e.startsWith("/") && "" === t ? "/" : t)) } const y = /^:\w+$/, v = 3, b = 2, _ = 1, T = 10, S = -2, w = e => "*" === e; function x(e, t) { let n = e.split("/"), i = n.length; return n.some(w) && (i += S), t && (i += b), n.filter((e => !w(e))).reduce(((e, t) => e + (y.test(t) ? v : "" === t ? _ : T)), i) } function k(e, t) { let { routesMeta: n } = e, i = {}, r = "/", s = []; for (let a = 0; a < n.length; ++a) { let e = n[a], o = a === n.length - 1, l = "/" === r ? t : t.slice(r.length) || "/", c = E({ path: e.relativePath, caseSensitive: e.caseSensitive, end: o }, l); if (!c) return null; Object.assign(i, c.params); let u = e.route; s.push({ params: i, pathname: A([r, c.pathname]), pathnameBase: N(A([r, c.pathnameBase])), route: u }), "/" !== c.pathnameBase && (r = A([r, c.pathnameBase])) } return s } function E(e, t) { "string" === typeof e && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, i] = function (e, t, n) { void 0 === t && (t = !1); void 0 === n && (n = !0); o("*" === e || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were "' + e.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "' + e.replace(/\*$/, "/*") + '".'); let i = [], r = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, ((e, t) => (i.push(t), "/([^\\/]+)"))); e.endsWith("*") ? (i.push("*"), r += "*" === e || "/*" === e ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? r += "\\/*$" : "" !== e && "/" !== e && (r += "(?:(?=\\/|$))"); let s = new RegExp(r, t ? void 0 : "i"); return [s, i] }(e.path, e.caseSensitive, e.end), r = t.match(n); if (!r) return null; let s = r[0], a = s.replace(/(.)\/+$/, "$1"), l = r.slice(1); return { params: i.reduce(((e, t, n) => { if ("*" === t) { let e = l[n] || ""; a = s.slice(0, s.length - e.length).replace(/(.)\/+$/, "$1") } return e[t] = function (e, t) { try { return decodeURIComponent(e) } catch (n) { return o(!1, 'The value for the URL param "' + t + '" will not be decoded because the string "' + e + '" is a malformed URL segment. This is probably due to a bad percent encoding (' + n + ")."), e } }(l[n] || "", t), e }), {}), pathname: s, pathnameBase: a, pattern: e } } function C(e) { try { return decodeURI(e) } catch (t) { return o(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + t + ")."), e } } function P(e, t) { if ("/" === t) return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, i = e.charAt(n); return i && "/" !== i ? null : e.slice(n) || "/" } function I(e, t, n, i) { return "Cannot include a '" + e + "' character in a manually specified `to." + t + "` field [" + JSON.stringify(i) + "].  Please separate it out to the `to." + n + '` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.' } function L(e) { return e.filter(((e, t) => 0 === t || e.route.path && e.route.path.length > 0)) } function O(e, t, n, i) { let s; void 0 === i && (i = !1), "string" === typeof e ? s = d(e) : (s = r({}, e), a(!s.pathname || !s.pathname.includes("?"), I("?", "pathname", "search", s)), a(!s.pathname || !s.pathname.includes("#"), I("#", "pathname", "hash", s)), a(!s.search || !s.search.includes("#"), I("#", "search", "hash", s))); let o, l = "" === e || "" === s.pathname, c = l ? "/" : s.pathname; if (i || null == c) o = n; else { let e = t.length - 1; if (c.startsWith("..")) { let t = c.split("/"); for (; ".." === t[0];)t.shift(), e -= 1; s.pathname = t.join("/") } o = e >= 0 ? t[e] : "/" } let u = function (e, t) { void 0 === t && (t = "/"); let { pathname: n, search: i = "", hash: r = "" } = "string" === typeof e ? d(e) : e, s = n ? n.startsWith("/") ? n : function (e, t) { let n = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach((e => { ".." === e ? n.length > 1 && n.pop() : "." !== e && n.push(e) })), n.length > 1 ? n.join("/") : "/" }(n, t) : t; return { pathname: s, search: j(i), hash: D(r) } }(s, o), h = c && "/" !== c && c.endsWith("/"), p = (l || "." === c) && n.endsWith("/"); return u.pathname.endsWith("/") || !h && !p || (u.pathname += "/"), u } const A = e => e.join("/").replace(/\/\/+/g, "/"), N = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), j = e => e && "?" !== e ? e.startsWith("?") ? e : "?" + e : "", D = e => e && "#" !== e ? e.startsWith("#") ? e : "#" + e : ""; class M extends Error { } function R(e) { return null != e && "number" === typeof e.status && "string" === typeof e.statusText && "boolean" === typeof e.internal && "data" in e } const U = ["post", "put", "patch", "delete"], B = (new Set(U), ["get", ...U]); new Set(B), new Set([301, 302, 303, 307, 308]), new Set([307, 308]), "undefined" !== typeof window && "undefined" !== typeof window.document && window.document.createElement; Symbol("deferred"); function F() { return F = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, F.apply(this, arguments) } const z = t.createContext(null); const H = t.createContext(null); const V = t.createContext(null); const W = t.createContext(null); const q = t.createContext({ outlet: null, matches: [], isDataRoute: !1 }); const G = t.createContext(null); function X() { return null != t.useContext(W) } function K() { return X() || a(!1), t.useContext(W).location } function $(e) { t.useContext(V).static || t.useLayoutEffect(e) } function Y() { let { isDataRoute: e } = t.useContext(q); return e ? function () { let { router: e } = oe(se.UseNavigateStable), n = ce(ae.UseNavigateStable), i = t.useRef(!1); return $((() => { i.current = !0 })), t.useCallback((function (t, r) { void 0 === r && (r = {}), i.current && ("number" === typeof t ? e.navigate(t) : e.navigate(t, F({ fromRouteId: n }, r))) }), [e, n]) }() : function () { X() || a(!1); let { basename: e, navigator: n } = t.useContext(V), { matches: i } = t.useContext(q), { pathname: r } = K(), s = JSON.stringify(L(i).map((e => e.pathnameBase))), o = t.useRef(!1); return $((() => { o.current = !0 })), t.useCallback((function (t, i) { if (void 0 === i && (i = {}), !o.current) return; if ("number" === typeof t) return void n.go(t); let a = O(t, JSON.parse(s), r, "path" === i.relative); "/" !== e && (a.pathname = "/" === a.pathname ? e : A([e, a.pathname])), (i.replace ? n.replace : n.push)(a, i.state, i) }), [e, n, s, r]) }() } function Q() { let { matches: e } = t.useContext(q), n = e[e.length - 1]; return n ? n.params : {} } function J(e, n) { let { relative: i } = void 0 === n ? {} : n, { matches: r } = t.useContext(q), { pathname: s } = K(), a = JSON.stringify(L(r).map((e => e.pathnameBase))); return t.useMemo((() => O(e, JSON.parse(a), s, "path" === i)), [e, a, s, i]) } function Z(n, i, r) { X() || a(!1); let { navigator: s } = t.useContext(V), { matches: o } = t.useContext(q), l = o[o.length - 1], c = l ? l.params : {}, u = (l && l.pathname, l ? l.pathnameBase : "/"); l && l.route; let h, p = K(); if (i) { var m; let e = "string" === typeof i ? d(i) : i; "/" === u || (null == (m = e.pathname) ? void 0 : m.startsWith(u)) || a(!1), h = e } else h = p; let g = h.pathname || "/", y = f(n, { pathname: "/" === u ? g : g.slice(u.length) || "/" }); let v = re(y && y.map((e => Object.assign({}, e, { params: Object.assign({}, c, e.params), pathname: A([u, s.encodeLocation ? s.encodeLocation(e.pathname).pathname : e.pathname]), pathnameBase: "/" === e.pathnameBase ? u : A([u, s.encodeLocation ? s.encodeLocation(e.pathnameBase).pathname : e.pathnameBase]) }))), o, r); return i && v ? t.createElement(W.Provider, { value: { location: F({ pathname: "/", search: "", hash: "", state: null, key: "default" }, h), navigationType: e.Pop } }, v) : v } function ee() { let e = function () { var e; let n = t.useContext(G), i = le(ae.UseRouteError), r = ce(ae.UseRouteError); if (n) return n; return null == (e = i.errors) ? void 0 : e[r] }(), n = R(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), i = e instanceof Error ? e.stack : null, r = "rgba(200,200,200, 0.5)", s = { padding: "0.5rem", backgroundColor: r }; return t.createElement(t.Fragment, null, t.createElement("h2", null, "Unexpected Application Error!"), t.createElement("h3", { style: { fontStyle: "italic" } }, n), i ? t.createElement("pre", { style: s }, i) : null, null) } const te = t.createElement(ee, null); class ne extends t.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { return t.location !== e.location || "idle" !== t.revalidation && "idle" === e.revalidation ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: e.error || t.error, location: t.location, revalidation: e.revalidation || t.revalidation } } componentDidCatch(e, t) { console.error("React Router caught the following error during render", e, t) } render() { return this.state.error ? t.createElement(q.Provider, { value: this.props.routeContext }, t.createElement(G.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function ie(e) { let { routeContext: n, match: i, children: r } = e, s = t.useContext(z); return s && s.static && s.staticContext && (i.route.errorElement || i.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = i.route.id), t.createElement(q.Provider, { value: n }, r) } function re(e, n, i) { var r; if (void 0 === n && (n = []), void 0 === i && (i = null), null == e) { var s; if (null == (s = i) || !s.errors) return null; e = i.matches } let o = e, l = null == (r = i) ? void 0 : r.errors; if (null != l) { let e = o.findIndex((e => e.route.id && (null == l ? void 0 : l[e.route.id]))); e >= 0 || a(!1), o = o.slice(0, Math.min(o.length, e + 1)) } return o.reduceRight(((e, r, s) => { let a = r.route.id ? null == l ? void 0 : l[r.route.id] : null, c = null; i && (c = r.route.errorElement || te); let u = n.concat(o.slice(0, s + 1)), d = () => { let n; return n = a ? c : r.route.Component ? t.createElement(r.route.Component, null) : r.route.element ? r.route.element : e, t.createElement(ie, { match: r, routeContext: { outlet: e, matches: u, isDataRoute: null != i }, children: n }) }; return i && (r.route.ErrorBoundary || r.route.errorElement || 0 === s) ? t.createElement(ne, { location: i.location, revalidation: i.revalidation, component: c, error: a, children: d(), routeContext: { outlet: null, matches: u, isDataRoute: !0 } }) : d() }), null) } var se, ae; function oe(e) { let n = t.useContext(z); return n || a(!1), n } function le(e) { let n = t.useContext(H); return n || a(!1), n } function ce(e) { let n = function (e) { let n = t.useContext(q); return n || a(!1), n }(), i = n.matches[n.matches.length - 1]; return i.route.id || a(!1), i.route.id } !function (e) { e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate" }(se || (se = {})), function (e) { e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId" }(ae || (ae = {})); function ue(e) { a(!1) } function de(n) { let { basename: i = "/", children: r = null, location: s, navigationType: o = e.Pop, navigator: l, static: c = !1 } = n; X() && a(!1); let u = i.replace(/^\/*/, "/"), h = t.useMemo((() => ({ basename: u, navigator: l, static: c })), [u, l, c]); "string" === typeof s && (s = d(s)); let { pathname: p = "/", search: f = "", hash: m = "", state: g = null, key: y = "default" } = s, v = t.useMemo((() => { let e = P(p, u); return null == e ? null : { location: { pathname: e, search: f, hash: m, state: g, key: y }, navigationType: o } }), [u, p, f, m, g, y, o]); return null == v ? null : t.createElement(V.Provider, { value: h }, t.createElement(W.Provider, { children: r, value: v })) } function he(e) { let { children: t, location: n } = e; return Z(me(t), n) } var pe; !function (e) { e[e.pending = 0] = "pending", e[e.success = 1] = "success", e[e.error = 2] = "error" }(pe || (pe = {})); new Promise((() => { })); class fe extends t.Component { constructor(e) { super(e), this.state = { error: null } } static getDerivedStateFromError(e) { return { error: e } } componentDidCatch(e, t) { console.error("<Await> caught the following error during render", e, t) } render() { let { children: e, errorElement: t, resolve: n } = this.props, i = null, r = pe.pending; if (n instanceof Promise) if (this.state.error) { pe.error; let e = this.state.error; Promise.reject().catch((() => { })), Object.defineProperty(i, "_tracked", { get: () => !0 }), Object.defineProperty(i, "_error", { get: () => e }) } else n._tracked ? (n, void 0 !== i._error ? pe.error : void 0 !== i._data ? pe.success : pe.pending) : (pe.pending, Object.defineProperty(n, "_tracked", { get: () => !0 }), n.then((e => Object.defineProperty(n, "_data", { get: () => e })), (e => Object.defineProperty(n, "_error", { get: () => e })))); else pe.success, Promise.resolve(), Object.defineProperty(i, "_tracked", { get: () => !0 }), Object.defineProperty(i, "_data", { get: () => n }); if (r === pe.error && i._error instanceof AbortedDeferredError) throw neverSettledPromise; if (r === pe.error && !t) throw i._error; if (r === pe.error) return React.createElement(AwaitContext.Provider, { value: i, children: t }); if (r === pe.success) return React.createElement(AwaitContext.Provider, { value: i, children: e }); throw i } } function me(e, n) { void 0 === n && (n = []); let i = []; return t.Children.forEach(e, ((e, r) => { if (!t.isValidElement(e)) return; let s = [...n, r]; if (e.type === t.Fragment) return void i.push.apply(i, me(e.props.children, s)); e.type !== ue && a(!1), e.props.index && e.props.children && a(!1); let o = { id: e.props.id || s.join("-"), caseSensitive: e.props.caseSensitive, element: e.props.element, Component: e.props.Component, index: e.props.index, path: e.props.path, loader: e.props.loader, action: e.props.action, errorElement: e.props.errorElement, ErrorBoundary: e.props.ErrorBoundary, hasErrorBoundary: null != e.props.ErrorBoundary || null != e.props.errorElement, shouldRevalidate: e.props.shouldRevalidate, handle: e.props.handle, lazy: e.props.lazy }; e.props.children && (o.children = me(e.props.children, s)), i.push(o) })), i } function ge() { return ge = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, ge.apply(this, arguments) } function ye(e, t) { if (null == e) return {}; var n, i, r = {}, s = Object.keys(e); for (i = 0; i < s.length; i++)n = s[i], t.indexOf(n) >= 0 || (r[n] = e[n]); return r } const ve = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"]; function be(e) { let { basename: n, children: i, window: r } = e, s = t.useRef(); var a; null == s.current && (s.current = (void 0 === (a = { window: r, v5Compat: !0 }) && (a = {}), h((function (e, t) { let { pathname: n, search: i, hash: r } = e.location; return c("", { pathname: n, search: i, hash: r }, t.state && t.state.usr || null, t.state && t.state.key || "default") }), (function (e, t) { return "string" === typeof t ? t : u(t) }), null, a))); let o = s.current, [l, d] = t.useState({ action: o.action, location: o.location }); return t.useLayoutEffect((() => o.listen(d)), [o]), t.createElement(de, { basename: n, children: i, location: l.location, navigationType: l.action, navigator: o }) } const _e = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement, Te = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Se = t.forwardRef((function (e, n) { let i, { onClick: r, relative: s, reloadDocument: o, replace: l, state: c, target: d, to: h, preventScrollReset: p } = e, f = ye(e, ve), { basename: m } = t.useContext(V), g = !1; if ("string" === typeof h && Te.test(h) && (i = h, _e)) try { let e = new URL(window.location.href), t = h.startsWith("//") ? new URL(e.protocol + h) : new URL(h), n = P(t.pathname, m); t.origin === e.origin && null != n ? h = n + t.search + t.hash : g = !0 } catch (b) { } let y = function (e, n) { let { relative: i } = void 0 === n ? {} : n; X() || a(!1); let { basename: r, navigator: s } = t.useContext(V), { hash: o, pathname: l, search: c } = J(e, { relative: i }), u = l; return "/" !== r && (u = "/" === l ? r : A([r, l])), s.createHref({ pathname: u, search: c, hash: o }) }(h, { relative: s }), v = function (e, n) { let { target: i, replace: r, state: s, preventScrollReset: a, relative: o } = void 0 === n ? {} : n, l = Y(), c = K(), d = J(e, { relative: o }); return t.useCallback((t => { if (function (e, t) { return 0 === e.button && (!t || "_self" === t) && !function (e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) }(e) }(t, i)) { t.preventDefault(); let n = void 0 !== r ? r : u(c) === u(d); l(e, { replace: n, state: s, preventScrollReset: a, relative: o }) } }), [c, l, d, r, s, i, e, a, o]) }(h, { replace: l, state: c, target: d, preventScrollReset: p, relative: s }); return t.createElement("a", ge({}, f, { href: i || y, onClick: g || o ? r : function (e) { r && r(e), e.defaultPrevented || v(e) }, ref: n, target: d })) })); var we, xe; (function (e) { e.UseScrollRestoration = "useScrollRestoration", e.UseSubmitImpl = "useSubmitImpl", e.UseFetcher = "useFetcher" })(we || (we = {})), function (e) { e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration" }(xe || (xe = {})); var ke = n(1639), Ee = n(7945), Ce = n.n(Ee); const Pe = e => { let t; const n = new Set, i = (e, i) => { const r = "function" === typeof e ? e(t) : e; if (!Object.is(r, t)) { const e = t; t = (null != i ? i : "object" !== typeof r) ? r : Object.assign({}, t, r), n.forEach((n => n(t, e))) } }, r = () => t, s = { setState: i, getState: r, subscribe: e => (n.add(e), () => n.delete(e)), destroy: () => { console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), n.clear() } }; return t = e(i, r, s), s }, Ie = e => e ? Pe(e) : Pe; var Le = n(327); const { useSyncExternalStoreWithSelector: Oe } = Le; const Ae = e => { "function" !== typeof e && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."); const n = "function" === typeof e ? Ie(e) : e, i = (e, i) => function (e) { let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.getState, i = arguments.length > 2 ? arguments[2] : void 0; const r = Oe(e.subscribe, e.getState, e.getServerState || e.getState, n, i); return (0, t.useDebugValue)(r), r }(n, e, i); return Object.assign(i, n), i }, Ne = e => e ? Ae(e) : Ae; const je = e => { const [n, i] = (0, t.useState)(null), [r, s] = (0, t.useState)(!0), [a, o] = (0, t.useState)(null), l = (0, t.useCallback)((async () => { try { const t = await fetch(e, { headers: { Authorization: "Bearer ".concat(localStorage.getItem("token")) } }), n = await t.json(); i(n), s(!1) } catch (a) { console.log({ NODE_ENV: "production", PUBLIC_URL: "", WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0, REACT_APP_DEV_URL: "" }), console.log(a), o(a), s(!1) } }), [e]); return (0, t.useEffect)((() => { l() }), [l]), { data: n, loading: r, error: a, fetchData: l } }; function De() { const [e, n] = (0, t.useState)({}), [i, r] = (0, t.useState)(null), [s, a] = (0, t.useState)(null), [o, l] = (0, t.useState)(null), c = { Authorization: "Bearer ".concat(localStorage.getItem("token")) }; return { data: e, handleSubmit: async t => { let { e: n = "", url: i, body: s = e, headers: o = { ...c }, dispatcher: u = null, dispatch: d = null } = t; n && n.preventDefault(), r(!0), a(null); try { const e = { method: "POST", headers: { ...o, ...c, "Content-Type": s instanceof FormData ? "multipart/form-data" : "application/json" }, body: s instanceof FormData ? s : JSON.stringify(s) }, t = await fetch(i, e); if (!t.ok) throw new Error("Request failed with status ".concat(t.status)); const n = await t.json(); null !== u && null !== d ? u(d(n)) : l(n), r(!1), a(null) } catch (h) { console.log(h), a(h.message), r(!1) } }, handleChange: e => { e.persist(), n((t => ({ ...t, [e.target.name]: e.target.value.trim() }))) }, pending: i, error: s, resMsg: o } } var Me = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, Re = t.createContext && t.createContext(Me), Ue = function () { return Ue = Object.assign || function (e) { for (var t, n = 1, i = arguments.length; n < i; n++)for (var r in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]); return e }, Ue.apply(this, arguments) }, Be = function (e, t) { var n = {}; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]); if (null != e && "function" === typeof Object.getOwnPropertySymbols) { var r = 0; for (i = Object.getOwnPropertySymbols(e); r < i.length; r++)t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]) } return n }; function Fe(e) { return e && e.map((function (e, n) { return t.createElement(e.tag, Ue({ key: n }, e.attr), Fe(e.child)) })) } function ze(e) { return function (n) { return t.createElement(He, Ue({ attr: Ue({}, e.attr) }, n), Fe(e.child)) } } function He(e) { var n = function (n) { var i, r = e.attr, s = e.size, a = e.title, o = Be(e, ["attr", "size", "title"]), l = s || n.size || "1em"; return n.className && (i = n.className), e.className && (i = (i ? i + " " : "") + e.className), t.createElement("svg", Ue({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, n.attr, r, o, { className: i, style: Ue(Ue({ color: e.color || n.color }, n.style), e.style), height: l, width: l, xmlns: "http://www.w3.org/2000/svg" }), a && t.createElement("title", null, a), e.children) }; return void 0 !== Re ? t.createElement(Re.Consumer, null, (function (e) { return n(e) })) : n(Me) } function Ve(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeMiterlimit: "10", strokeWidth: "32", d: "M448 256c0-106-86-192-192-192S64 150 64 256s86 192 192 192 192-86 192-192z" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M256 176v160m80-80H176" } }] })(e) } function We(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M256 112v288m144-144H112" } }] })(e) } function qe(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "48", d: "M244 400L100 256l144-144M120 256h292" } }] })(e) } function Ge(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M256 160c16-63.16 76.43-95.41 208-96a15.94 15.94 0 0116 16v288a16 16 0 01-16 16c-128 0-177.45 25.81-208 64-30.37-38-80-64-208-64-9.88 0-16-8.05-16-17.93V80a15.94 15.94 0 0116-16c131.57.59 192 32.84 208 96zm0 0v288" } }] })(e) } function Xe(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M98 190.06l139.78 163.12a24 24 0 0036.44 0L414 190.06c13.34-15.57 2.28-39.62-18.22-39.62h-279.6c-20.5 0-31.56 24.05-18.18 39.62z" } }] })(e) } function Ke(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M414 321.94L274.22 158.82a24 24 0 00-36.44 0L98 321.94c-13.34 15.57-2.28 39.62 18.22 39.62h279.6c20.5 0 31.56-24.05 18.18-39.62z" } }] })(e) } function $e(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M416 128L192 384l-96-96" } }] })(e) } function Ye(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "48", d: "M328 112L184 256l144 144" } }] })(e) } function Qe(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "48", d: "M184 112l144 144-144 144" } }] })(e) } function Je(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M368 368L144 144m224 0L144 368" } }] })(e) } function Ze(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M456.7 242.27l-26.08-4.2a8 8 0 01-6.6-6.82c-.5-3.2-1-6.41-1.7-9.51a8.08 8.08 0 013.9-8.62l23.09-12.82a8.05 8.05 0 003.9-9.92l-4-11a7.94 7.94 0 00-9.4-5l-25.89 5a8 8 0 01-8.59-4.11q-2.25-4.2-4.8-8.41a8.16 8.16 0 01.7-9.52l17.29-19.94a8 8 0 00.3-10.62l-7.49-9a7.88 7.88 0 00-10.5-1.51l-22.69 13.63a8 8 0 01-9.39-.9c-2.4-2.11-4.9-4.21-7.4-6.22a8 8 0 01-2.5-9.11l9.4-24.75A8 8 0 00365 78.77l-10.2-5.91a8 8 0 00-10.39 2.21l-16.64 20.84a7.15 7.15 0 01-8.5 2.5s-5.6-2.3-9.8-3.71A8 8 0 01304 87l.4-26.45a8.07 8.07 0 00-6.6-8.42l-11.59-2a8.07 8.07 0 00-9.1 5.61l-8.6 25.05a8 8 0 01-7.79 5.41h-9.8a8.07 8.07 0 01-7.79-5.41l-8.6-25.05a8.07 8.07 0 00-9.1-5.61l-11.59 2a8.07 8.07 0 00-6.6 8.42l.4 26.45a8 8 0 01-5.49 7.71c-2.3.9-7.3 2.81-9.7 3.71-2.8 1-6.1.2-8.8-2.91l-16.51-20.34A8 8 0 00156.75 73l-10.2 5.91a7.94 7.94 0 00-3.3 10.09l9.4 24.75a8.06 8.06 0 01-2.5 9.11c-2.5 2-5 4.11-7.4 6.22a8 8 0 01-9.39.9L111 116.14a8 8 0 00-10.5 1.51l-7.49 9a8 8 0 00.3 10.62l17.29 19.94a8 8 0 01.7 9.52q-2.55 4-4.8 8.41a8.11 8.11 0 01-8.59 4.11l-25.89-5a8 8 0 00-9.4 5l-4 11a8.05 8.05 0 003.9 9.92L85.58 213a7.94 7.94 0 013.9 8.62c-.6 3.2-1.2 6.31-1.7 9.51a8.08 8.08 0 01-6.6 6.82l-26.08 4.2a8.09 8.09 0 00-7.1 7.92v11.72a7.86 7.86 0 007.1 7.92l26.08 4.2a8 8 0 016.6 6.82c.5 3.2 1 6.41 1.7 9.51a8.08 8.08 0 01-3.9 8.62L62.49 311.7a8.05 8.05 0 00-3.9 9.92l4 11a7.94 7.94 0 009.4 5l25.89-5a8 8 0 018.59 4.11q2.25 4.2 4.8 8.41a8.16 8.16 0 01-.7 9.52l-17.29 19.96a8 8 0 00-.3 10.62l7.49 9a7.88 7.88 0 0010.5 1.51l22.69-13.63a8 8 0 019.39.9c2.4 2.11 4.9 4.21 7.4 6.22a8 8 0 012.5 9.11l-9.4 24.75a8 8 0 003.3 10.12l10.2 5.91a8 8 0 0010.39-2.21l16.79-20.64c2.1-2.6 5.5-3.7 8.2-2.6 3.4 1.4 5.7 2.2 9.9 3.61a8 8 0 015.49 7.71l-.4 26.45a8.07 8.07 0 006.6 8.42l11.59 2a8.07 8.07 0 009.1-5.61l8.6-25a8 8 0 017.79-5.41h9.8a8.07 8.07 0 017.79 5.41l8.6 25a8.07 8.07 0 009.1 5.61l11.59-2a8.07 8.07 0 006.6-8.42l-.4-26.45a8 8 0 015.49-7.71c4.2-1.41 7-2.51 9.6-3.51s5.8-1 8.3 2.1l17 20.94A8 8 0 00355 439l10.2-5.91a7.93 7.93 0 003.3-10.12l-9.4-24.75a8.08 8.08 0 012.5-9.12c2.5-2 5-4.1 7.4-6.21a8 8 0 019.39-.9L401 395.66a8 8 0 0010.5-1.51l7.49-9a8 8 0 00-.3-10.62l-17.29-19.94a8 8 0 01-.7-9.52q2.55-4.05 4.8-8.41a8.11 8.11 0 018.59-4.11l25.89 5a8 8 0 009.4-5l4-11a8.05 8.05 0 00-3.9-9.92l-23.09-12.82a7.94 7.94 0 01-3.9-8.62c.6-3.2 1.2-6.31 1.7-9.51a8.08 8.08 0 016.6-6.82l26.08-4.2a8.09 8.09 0 007.1-7.92V250a8.25 8.25 0 00-7.27-7.73zM256 112a143.82 143.82 0 01139.38 108.12A16 16 0 01379.85 240H274.61a16 16 0 01-13.91-8.09l-52.1-91.71a16 16 0 019.85-23.39A146.94 146.94 0 01256 112zM112 256a144 144 0 0143.65-103.41 16 16 0 0125.17 3.47L233.06 248a16 16 0 010 15.87l-52.67 91.7a16 16 0 01-25.18 3.36A143.94 143.94 0 01112 256zm144 144a146.9 146.9 0 01-38.19-4.95 16 16 0 01-9.76-23.44l52.58-91.55a16 16 0 0113.88-8H379.9a16 16 0 0115.52 19.88A143.84 143.84 0 01256 400z" } }] })(e) } function et(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "rect", attr: { width: "448", height: "320", x: "32", y: "64", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "32", ry: "32" } }, { tag: "path", attr: { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M304 448l-8-64h-80l-8 64h96z" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M368 448H144" } }, { tag: "path", attr: { d: "M32 304v48a32.09 32.09 0 0032 32h384a32.09 32.09 0 0032-32v-48zm224 64a16 16 0 1116-16 16 16 0 01-16 16z" } }] })(e) } function tt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M336 176h40a40 40 0 0140 40v208a40 40 0 01-40 40H136a40 40 0 01-40-40V216a40 40 0 0140-40h40" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M176 272l80 80 80-80M256 48v288" } }] })(e) } function nt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "rect", attr: { width: "416", height: "320", x: "48", y: "96", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "28", ry: "28" } }, { tag: "rect", attr: { width: "80", height: "80", x: "384", y: "336", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "28", ry: "28" } }, { tag: "rect", attr: { width: "80", height: "80", x: "384", y: "256", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "28", ry: "28" } }, { tag: "rect", attr: { width: "80", height: "80", x: "384", y: "176", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "28", ry: "28" } }, { tag: "rect", attr: { width: "80", height: "80", x: "384", y: "96", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "28", ry: "28" } }, { tag: "rect", attr: { width: "80", height: "80", x: "48", y: "336", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "28", ry: "28" } }, { tag: "rect", attr: { width: "80", height: "80", x: "48", y: "256", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "28", ry: "28" } }, { tag: "rect", attr: { width: "80", height: "80", x: "48", y: "176", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "28", ry: "28" } }, { tag: "rect", attr: { width: "80", height: "80", x: "48", y: "96", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "28", ry: "28" } }, { tag: "rect", attr: { width: "256", height: "160", x: "128", y: "96", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "28", ry: "28" } }, { tag: "rect", attr: { width: "256", height: "160", x: "128", y: "256", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "28", ry: "28" } }] })(e) } function it(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeMiterlimit: "10", strokeWidth: "32", d: "M467.51 248.83c-18.4-83.18-45.69-136.24-89.43-149.17A91.5 91.5 0 00352 96c-26.89 0-48.11 16-96 16s-69.15-16-96-16a99.09 99.09 0 00-27.2 3.66C89 112.59 61.94 165.7 43.33 248.83c-19 84.91-15.56 152 21.58 164.88 26 9 49.25-9.61 71.27-37 25-31.2 55.79-40.8 119.82-40.8s93.62 9.6 118.66 40.8c22 27.41 46.11 45.79 71.42 37.16 41.02-14.01 40.44-79.13 21.43-165.04z" } }, { tag: "circle", attr: { cx: "292", cy: "224", r: "20" } }, { tag: "path", attr: { d: "M336 288a20 20 0 1120-19.95A20 20 0 01336 288z" } }, { tag: "circle", attr: { cx: "336", cy: "180", r: "20" } }, { tag: "circle", attr: { cx: "380", cy: "224", r: "20" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M160 176v96m48-48h-96" } }] })(e) } function rt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M83 384c-13-33-35-93.37-35-128C48 141.12 149.33 48 256 48s208 93.12 208 208c0 34.63-23 97-35 128" } }, { tag: "path", attr: { fill: "none", strokeMiterlimit: "10", strokeWidth: "32", d: "M108.39 270.13l-13.69 8h0c-30.23 17.7-31.7 72.41-3.38 122.2s75.87 75.81 106.1 58.12h0l13.69-8a16.16 16.16 0 005.78-21.87L130 276a15.74 15.74 0 00-21.61-5.87zm295.22 0l13.69 8h0c30.23 17.69 31.74 72.4 3.38 122.19s-75.87 75.81-106.1 58.12h0l-13.69-8a16.16 16.16 0 01-5.78-21.87L382 276a15.74 15.74 0 0121.61-5.87z" } }] })(e) } function st(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M80 212v236a16 16 0 0016 16h96V328a24 24 0 0124-24h80a24 24 0 0124 24v136h96a16 16 0 0016-16V212" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M480 256L266.89 52c-5-5.28-16.69-5.34-21.78 0L32 256m368-77V64h-48v69" } }] })(e) } function at(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M304 336v40a40 40 0 01-40 40H104a40 40 0 01-40-40V136a40 40 0 0140-40h152c22.09 0 48 17.91 48 40v40m64 160l80-80-80-80m-192 80h256" } }] })(e) } function ot(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M176 96h16v320h-16zm144 0h16v320h-16z" } }] })(e) } function lt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M364.13 125.25L87 403l-23 45 44.99-23 277.76-277.13-22.62-22.62zm56.56-56.56l-22.62 22.62 22.62 22.63 22.62-22.63a16 16 0 000-22.62h0a16 16 0 00-22.62 0z" } }] })(e) } function ct(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M344 144c-3.92 52.87-44 96-88 96s-84.15-43.12-88-96c-4-55 35-96 88-96s92 42 88 96z" } }, { tag: "path", attr: { fill: "none", strokeMiterlimit: "10", strokeWidth: "32", d: "M256 304c-87 0-175.3 48-191.64 138.6C62.39 453.52 68.57 464 80 464h352c11.44 0 17.62-10.48 15.65-21.4C431.3 352 343 304 256 304z" } }] })(e) } function ut(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeMiterlimit: "10", strokeWidth: "32", d: "M112 111v290c0 17.44 17 28.52 31 20.16l247.9-148.37c12.12-7.25 12.12-26.33 0-33.58L143 90.84c-14-8.36-31 2.72-31 20.16z" } }] })(e) } function dt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeMiterlimit: "10", strokeWidth: "32", d: "M400 111v290c0 17.44-17 28.52-31 20.16L121.09 272.79c-12.12-7.25-12.12-26.33 0-33.58L369 90.84c14-8.36 31 2.72 31 20.16z" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "32", d: "M112 80v352" } }] })(e) } function ht(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeMiterlimit: "10", strokeWidth: "32", d: "M112 111v290c0 17.44 17 28.52 31 20.16l247.9-148.37c12.12-7.25 12.12-26.33 0-33.58L143 90.84c-14-8.36-31 2.72-31 20.16z" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "32", d: "M400 80v352" } }] })(e) } function pt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "32", d: "M320 146s24.36-12-64-12a160 160 0 10160 160" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M256 58l80 80-80 80" } }] })(e) } function ft(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M320 120l48 48-48 48" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M352 168H144a80.24 80.24 0 00-80 80v16m128 128l-48-48 48-48" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M160 344h208a80.24 80.24 0 0080-80v-16" } }] })(e) } function mt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeMiterlimit: "10", strokeWidth: "32", d: "M221.09 64a157.09 157.09 0 10157.09 157.09A157.1 157.1 0 00221.09 64z" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "32", d: "M338.29 338.29L448 448" } }] })(e) } function gt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M400 304l48 48-48 48m0-288l48 48-48 48M64 352h85.19a80 80 0 0066.56-35.62L256 256" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M64 160h85.19a80 80 0 0166.56 35.62l80.5 120.76A80 80 0 00362.81 352H416m0-192h-53.19a80 80 0 00-66.56 35.62L288 208" } }] })(e) } function yt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M320 458.16S304 464 256 464s-74-16-96-32H96a64 64 0 01-64-64v-48a64 64 0 0164-64h30a32.34 32.34 0 0027.37-15.4S162 221.81 188 176.78 264 64 272 48c29 0 43 22 34 47.71-10.28 29.39-23.71 54.38-27.46 87.09-.54 4.78 3.14 12 7.95 12L416 205" } }, { tag: "path", attr: { fill: "none", strokeMiterlimit: "10", strokeWidth: "32", d: "M416 271l-80-2c-20-1.84-32-12.4-32-30h0c0-17.6 14-28.84 32-30l80-4c17.6 0 32 16.4 32 34v.17A32 32 0 01416 271zm32 65l-112-2c-18-.84-32-12.41-32-30h0c0-17.61 14-28.86 32-30l112-2a32.1 32.1 0 0132 32h0a32.1 32.1 0 01-32 32zm-48 128l-64-3c-21-1.84-32-11.4-32-29h0c0-17.6 14.4-30 32-30l64-2a32.09 32.09 0 0132 32h0a32.09 32.09 0 01-32 32zm32-64l-96-2c-19-.84-32-12.4-32-30h0c0-17.6 13-28.84 32-30l96-2a32.09 32.09 0 0132 32h0a32.09 32.09 0 01-32 32z" } }] })(e) } function vt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M472.06 334l-144.16-6.13c-4.61-.36-23.9-1.21-23.9-25.87 0-23.81 19.16-25.33 24.14-25.88L472.06 270c12.67.13 23.94 14.43 23.94 32s-11.27 31.87-23.94 32zM330.61 202.33L437.35 194C450 194 464 210.68 464 227.88v.33c0 16.32-11.14 29.62-24.88 29.79l-108.45-1.73C304 253 304 236.83 304 229.88c0-22.88 21.8-27.15 26.61-27.55zM421.85 480l-89.37-8.93C308 470.14 304 453.82 304 443.59c0-18.38 13.41-24.6 26.67-24.6l91-3c14.54.23 26.32 14.5 26.32 32s-11.67 31.67-26.14 32.01zm34.36-71.5l-126.4-6.21c-9.39-.63-25.81-3-25.81-26.37 0-12 4.35-25.61 25-27.53l127.19-3.88c13.16.14 23.81 13.49 23.81 31.4s-10.65 32.43-23.79 32.58z" } }, { tag: "path", attr: { fill: "none", d: "M133.55 238.06A15.85 15.85 0 01126 240a15.82 15.82 0 007.51-1.92zm40.59-69.28l.13-.23-.13.23c-20.5 35.51-30.36 54.95-33.82 62 3.47-7.07 13.34-26.51 33.82-62z" } }, { tag: "path", attr: { d: "M139.34 232.84l1-2a16.27 16.27 0 01-6.77 7.25 16.35 16.35 0 005.77-5.25z" } }, { tag: "path", attr: { d: "M316.06 52.62C306.63 39.32 291 32 272 32a16 16 0 00-14.31 8.84c-3 6.07-15.25 24-28.19 42.91-18 26.33-40.35 59.07-55.23 84.8l-.13.23c-20.48 35.49-30.35 54.93-33.82 62l-1 2a16.35 16.35 0 01-5.79 5.22 15.82 15.82 0 01-7.53 2h-25.31A84.69 84.69 0 0016 324.69v38.61a84.69 84.69 0 0084.69 84.7h48.79a17.55 17.55 0 019.58 2.89C182 465.87 225.34 480 272 480c7.45 0 14.19-.14 20.27-.38a8 8 0 006.2-12.68l-.1-.14C289.8 454.41 288 441 288 432a61.2 61.2 0 015.19-24.77 17.36 17.36 0 000-14.05 63.81 63.81 0 010-50.39 17.32 17.32 0 000-14 62.15 62.15 0 010-49.59 18.13 18.13 0 000-14.68A60.33 60.33 0 01288 239c0-8.2 2-21.3 8-31.19a15.63 15.63 0 001.14-13.64c-.38-1-.76-2.07-1.13-3.17a24.84 24.84 0 01-.86-11.58c3-19.34 9.67-36.29 16.74-54.16 3.08-7.78 6.27-15.82 9.22-24.26 6.14-17.57 4.3-35.2-5.05-48.38z" } }] })(e) } function bt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M432 144l-28.67 275.74A32 32 0 01371.55 448H140.46a32 32 0 01-31.78-28.26L80 144" } }, { tag: "rect", attr: { width: "448", height: "80", x: "32", y: "64", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", rx: "16", ry: "16" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M312 240L200 352m112 0L200 240" } }] })(e) } function _t(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M112 112l20 320c.95 18.49 14.4 32 32 32h184c17.67 0 30.87-13.51 32-32l20-320" } }, { tag: "path", attr: { strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "32", d: "M80 112h352" } }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M192 112V72h0a23.93 23.93 0 0124-24h80a23.93 23.93 0 0124 24h0v40m-64 64v224m-72-224l8 224m136-224l-8 224" } }] })(e) } function Tt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "rect", attr: { width: "448", height: "272", x: "32", y: "96", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "32.14", ry: "32.14" } }, { tag: "path", attr: { strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "32", d: "M128 416h256" } }] })(e) } function St(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M374.79 308.78L457.5 367a16 16 0 0022.5-14.62V159.62A16 16 0 00457.5 145l-82.71 58.22A16 16 0 00368 216.3v79.4a16 16 0 006.79 13.08z" } }, { tag: "path", attr: { fill: "none", strokeMiterlimit: "10", strokeWidth: "32", d: "M268 384H84a52.15 52.15 0 01-52-52V180a52.15 52.15 0 0152-52h184.48A51.68 51.68 0 01320 179.52V332a52.15 52.15 0 01-52 52z" } }] })(e) } function wt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M126 192H56a8 8 0 00-8 8v112a8 8 0 008 8h69.65a15.93 15.93 0 0110.14 3.54l91.47 74.89A8 8 0 00240 392V120a8 8 0 00-12.74-6.43l-91.47 74.89A15 15 0 01126 192zm194 128c9.74-19.38 16-40.84 16-64 0-23.48-6-44.42-16-64m48 176c19.48-33.92 32-64.06 32-112s-12-77.74-32-112m48 272c30-46 48-91.43 48-160s-18-113-48-160" } }] })(e) } function xt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M189.65 192H120a8 8 0 00-8 8v112a8 8 0 008 8h69.65a16 16 0 0110.14 3.63l91.47 75a8 8 0 0012.74-6.46V119.83a8 8 0 00-12.74-6.44l-91.47 75a16 16 0 01-10.14 3.61zM384 320c9.74-19.41 16-40.81 16-64 0-23.51-6-44.4-16-64" } }] })(e) } function kt(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M157.65 192H88a8 8 0 00-8 8v112a8 8 0 008 8h69.65a16 16 0 0110.14 3.63l91.47 75a8 8 0 0012.74-6.46V119.83a8 8 0 00-12.74-6.44l-91.47 75a16 16 0 01-10.14 3.61zM352 320c9.74-19.41 16-40.81 16-64 0-23.51-6-44.4-16-64m48 176c19.48-34 32-64 32-112s-12-77.7-32-112" } }] })(e) } function Et(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "32", d: "M416 432L64 80" } }, { tag: "path", attr: { d: "M224 136.92v33.8a4 4 0 001.17 2.82l24 24a4 4 0 006.83-2.82v-74.15a24.53 24.53 0 00-12.67-21.72 23.91 23.91 0 00-25.55 1.83 8.27 8.27 0 00-.66.51l-31.94 26.15a4 4 0 00-.29 5.92l17.05 17.06a4 4 0 005.37.26zm0 238.16l-78.07-63.92a32 32 0 00-20.28-7.16H64v-96h50.72a4 4 0 002.82-6.83l-24-24a4 4 0 00-2.82-1.17H56a24 24 0 00-24 24v112a24 24 0 0024 24h69.76l91.36 74.8a8.27 8.27 0 00.66.51 23.93 23.93 0 0025.85 1.69A24.49 24.49 0 00256 391.45v-50.17a4 4 0 00-1.17-2.82l-24-24a4 4 0 00-6.83 2.82zM125.82 336zM352 256c0-24.56-5.81-47.88-17.75-71.27a16 16 0 00-28.5 14.54C315.34 218.06 320 236.62 320 256q0 4-.31 8.13a8 8 0 002.32 6.25l19.66 19.67a4 4 0 006.75-2A146.89 146.89 0 00352 256zm64 0c0-51.19-13.08-83.89-34.18-120.06a16 16 0 00-27.64 16.12C373.07 184.44 384 211.83 384 256c0 23.83-3.29 42.88-9.37 60.65a8 8 0 001.9 8.26l16.77 16.76a4 4 0 006.52-1.27C410.09 315.88 416 289.91 416 256z" } }, { tag: "path", attr: { d: "M480 256c0-74.26-20.19-121.11-50.51-168.61a16 16 0 10-27 17.22C429.82 147.38 448 189.5 448 256c0 47.45-8.9 82.12-23.59 113a4 4 0 00.77 4.55L443 391.39a4 4 0 006.4-1C470.88 348.22 480 307 480 256z" } }] })(e) } var Ct = n(184); const Pt = { movies: (0, Ct.jsx)(nt, { className: "icon" }), series: (0, Ct.jsx)(St, { className: "icon" }), books: (0, Ct.jsx)(Ge, { className: "icon" }), consoles: (0, Ct.jsx)(it, { className: "icon" }), musics: (0, Ct.jsx)(rt, { className: "icon" }), tv: (0, Ct.jsx)(Tt, { className: "icon" }), others: (0, Ct.jsx)(et, { className: "icon" }) }; function It(e) { let { name: t, type: n } = e; return (0, Ct.jsxs)(Se, { to: "/".concat(n, "/").concat(t), className: "card", children: [Pt[n], (0, Ct.jsx)("p", { children: t })] }) } function Lt() { return (0, Ct.jsx)(Se, { to: "/settings", className: "settings", id: "settings", children: (0, Ct.jsx)(Ze, { className: "cog" }) }) } function Ot() { var e; return (0, Ct.jsx)("div", { className: "search_and_div", children: "admin" === (null === (e = localStorage.getItem("account_type")) || void 0 === e ? void 0 : e.toLowerCase()) ? (0, Ct.jsx)(Lt, {}) : null }) } const At = n.p + "static/media/loader.6886192470a544de0a02.gif"; function Nt() { return (0, Ct.jsx)("p", { className: "notFound", children: (0, Ct.jsx)("img", { src: At, alt: "loader", className: "loader" }) }) } function jt() { const { data: e } = je("".concat("", "/get_all_libraries")); return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(Ot, {}), (0, Ct.jsx)("div", { className: "cards", children: Array.isArray(e) ? e.map((e => (0, Ct.jsx)(It, { name: e.lib_name, type: e.lib_type }, "".concat(e.lib_type, "-").concat(e.lib_name)))) : (0, Ct.jsx)(Nt, {}) })] }) } var Dt = function (e, t) { return Dt = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]) }, Dt(e, t) }; var Mt = 50, Rt = 50; function Ut(e) { var n = e.className, i = e.counterClockwise, r = e.dashRatio, s = e.pathRadius, a = e.strokeWidth, o = e.style; return (0, t.createElement)("path", { className: n, style: Object.assign({}, o, Ft({ pathRadius: s, dashRatio: r, counterClockwise: i })), d: Bt({ pathRadius: s, counterClockwise: i }), strokeWidth: a, fillOpacity: 0 }) } function Bt(e) { var t = e.pathRadius, n = e.counterClockwise ? 1 : 0; return "\n      M " + Mt + "," + Rt + "\n      m 0,-" + t + "\n      a " + t + "," + t + " " + n + " 1 1 0," + 2 * t + "\n      a " + t + "," + t + " " + n + " 1 1 0,-" + 2 * t + "\n    " } function Ft(e) { var t = e.counterClockwise, n = e.dashRatio, i = e.pathRadius, r = 2 * Math.PI * i, s = (1 - n) * r; return { strokeDasharray: r + "px " + r + "px", strokeDashoffset: (t ? -s : s) + "px" } } var zt = function (e) { function n() { return null !== e && e.apply(this, arguments) || this } return function (e, t) { function n() { this.constructor = e } Dt(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) }(n, e), n.prototype.getBackgroundPadding = function () { return this.props.background ? this.props.backgroundPadding : 0 }, n.prototype.getPathRadius = function () { return 50 - this.props.strokeWidth / 2 - this.getBackgroundPadding() }, n.prototype.getPathRatio = function () { var e = this.props, t = e.value, n = e.minValue, i = e.maxValue; return (Math.min(Math.max(t, n), i) - n) / (i - n) }, n.prototype.render = function () { var e = this.props, n = e.circleRatio, i = e.className, r = e.classes, s = e.counterClockwise, a = e.styles, o = e.strokeWidth, l = e.text, c = this.getPathRadius(), u = this.getPathRatio(); return (0, t.createElement)("svg", { className: r.root + " " + i, style: a.root, viewBox: "0 0 100 100", "data-test-id": "CircularProgressbar" }, this.props.background ? (0, t.createElement)("circle", { className: r.background, style: a.background, cx: Mt, cy: Rt, r: 50 }) : null, (0, t.createElement)(Ut, { className: r.trail, counterClockwise: s, dashRatio: n, pathRadius: c, strokeWidth: o, style: a.trail }), (0, t.createElement)(Ut, { className: r.path, counterClockwise: s, dashRatio: u * n, pathRadius: c, strokeWidth: o, style: a.path }), l ? (0, t.createElement)("text", { className: r.text, style: a.text, x: Mt, y: Rt }, l) : null) }, n.defaultProps = { background: !1, backgroundPadding: 0, circleRatio: 1, classes: { root: "CircularProgressbar", trail: "CircularProgressbar-trail", path: "CircularProgressbar-path", text: "CircularProgressbar-text", background: "CircularProgressbar-background" }, counterClockwise: !1, className: "", maxValue: 100, minValue: 0, strokeWidth: 8, styles: { root: {}, trail: {}, path: {}, text: {}, background: {} }, text: "" }, n }(t.Component); function Ht(e) { var t = e.rotation, n = e.strokeLinecap, i = e.textColor, r = e.textSize, s = e.pathColor, a = e.pathTransition, o = e.pathTransitionDuration, l = e.trailColor, c = e.backgroundColor, u = null == t ? void 0 : "rotate(" + t + "turn)", d = null == t ? void 0 : "center center"; return { root: {}, path: Vt({ stroke: s, strokeLinecap: n, transform: u, transformOrigin: d, transition: a, transitionDuration: null == o ? void 0 : o + "s" }), trail: Vt({ stroke: l, strokeLinecap: n, transform: u, transformOrigin: d }), text: Vt({ fill: i, fontSize: r }), background: Vt({ fill: c }) } } function Vt(e) { return Object.keys(e).forEach((function (t) { null == e[t] && delete e[t] })), e } function Wt(e) { let { name: t, library: n, onClick: i, note: r, vues: s, duration: a, id: o, isAdmin: l } = e; const c = Y(), u = localStorage.getItem("username"); let d = 10 * (h = 1, +parseFloat(r).toFixed(h)); var h; let p; p = d < 50 ? 1.2 * d : 1.2 * (d - 50) + 60; let f = "hsl(".concat(p, "deg, 100%, 50%)"); s = [u]; let m = a.split(":")[0], g = a.split(":")[1], y = a.split(":")[2], v = 3600 * parseInt(m) + 60 * parseInt(g) + parseInt(y), b = 0; return s && (b = Math.round(s / v * 100)), (0, Ct.jsxs)("div", { className: "movie-card", onClick: i, "data-aos": "fade-up", children: [(0, Ct.jsx)(zt, { value: d, text: "".concat(d / 10, "/10"), styles: Ht({ pathColor: f, textColor: "#fff", trailColor: "transparent" }) }), l && (0, Ct.jsx)(lt, { className: "edit-icon", onClick: () => c("/edit_movie/".concat(o, "/").concat(n)) }), (0, Ct.jsx)("img", { src: "".concat("", "/movie_cover/").concat(o), alt: t, loading: "lazy", onError: e => { let { currentTarget: t } = e; t.onerror = null, t.src = "".concat("", "/static/img/broken.webp") } }), b > 0 && (0, Ct.jsx)("div", { className: "timeLineBackground", children: (0, Ct.jsx)("div", { className: "timeLine", style: { width: "".concat(b, "%") } }) })] }) } function qt(e) { let { icon: t, text: n, onClick: i, type: r = "", style: s = {} } = e; return (0, Ct.jsxs)("button", { className: "button ".concat(r), onClick: i, style: s, children: [t, (0, Ct.jsx)("p", { children: n })] }) } function Gt(e) { let { name: n, description: i, id: r, full_banner: s = !1 } = e; const [a, o] = (0, t.useState)(!1), { lib: l } = Q(), c = Y(), { handleSubmit: u } = De(); function d() { o(!a) } return (0, Ct.jsxs)("div", { className: "big-banner ".concat(s ? "full-banner" : ""), "data-aos": "fade-down", children: [(0, Ct.jsx)("div", { src: "".concat("", "/movie_banner/").concat(r), style: { backgroundImage: 'linear-gradient(transparent, rgb(29, 29, 29)), url("'.concat("", "/movie_banner/").concat(r, '")') }, className: "banner" }), (0, Ct.jsxs)("div", { className: "banner-data", children: [(0, Ct.jsx)("h1", { children: n }), function (e) { if (e && e.length > 200) { const t = e.slice(0, 200); return (0, Ct.jsxs)("p", { className: "banner-description", style: { overflowY: a ? "scroll" : "hidden" }, children: [a ? e : t, (0, Ct.jsx)("span", { className: "more", onClick: d, children: a ? "less" : "... more" })] }) } return (0, Ct.jsx)("p", { className: "banner-description", children: e }) }(i), (0, Ct.jsxs)("div", { className: "banner-buttons", children: [(0, Ct.jsxs)("div", { className: "banner-buttons-left", children: [(0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(ut, {}), text: "Watch now", onClick: () => c("/movie/" + r) }), (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(tt, {}), text: "Download", onClick: () => window.location.href = "".concat("", "/download_movie/").concat(r) })] }), (0, Ct.jsx)("div", { className: "banner-buttons-right", children: (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(pt, {}), text: "Refresh", onClick: function () { u({ url: "".concat("", "/rescan/").concat(l) }) } }) })] })] })] }) } function Xt(e) { let { id: t } = e; const { data: n } = je("".concat("", "/get_actor_data/").concat(t)); return (0, Ct.jsxs)(Se, { className: "castMember", to: "/actor/".concat(t), children: [(0, Ct.jsx)("img", { className: "castImage", src: "".concat("", "/actor_image/").concat(t), alt: t, onError: e => { let { currentTarget: t } = e; t.onerror = null, t.src = "".concat("", "/static/img/broken.webp") } }), (0, Ct.jsx)("p", { className: "castName", children: null === n || void 0 === n ? void 0 : n.actor_name })] }) } function Kt(e) { let { title: t, message: n } = e; ke.Store.addNotification({ title: null !== t && void 0 !== t ? t : "Error", message: null !== n && void 0 !== n ? n : "An error has occurred", type: "danger", insert: "top", container: "top-left", animationIn: ["animate__animated", "animate__fadeIn"], animationOut: ["animate__animated", "animate__fadeOut"], dismiss: { duration: 5e3, onScreen: !0 } }) } function $t(e) { let { title: t, message: n } = e; ke.Store.addNotification({ title: null !== t && void 0 !== t ? t : "Success", message: null !== n && void 0 !== n ? n : "Success", type: "success", insert: "top", container: "top-left", animationIn: ["animate__animated", "animate__fadeIn"], animationOut: ["animate__animated", "animate__fadeOut"], dismiss: { duration: 5e3, onScreen: !0 } }) } function Yt() { const [e, n] = (0, t.useState)(JSON.parse(localStorage.getItem("language"))); (0, t.useEffect)((() => { n(JSON.parse(localStorage.getItem("language"))) }), [localStorage.getItem("language")]); return { getLang: t => null === e || void 0 === e ? void 0 : e[t] } } function Qt(e) { let { onClose: t, id: n } = e; const i = Y(); const { data: r } = je("".concat("", "/get_movie_data/").concat(n)); return (0, Ct.jsxs)("div", { id: "popup", className: "popup", children: [(0, Ct.jsx)(Je, { className: "crossPopup", id: "crossPopup", onClick: t }), r ? (0, Ct.jsxs)("div", { className: "popupContent", children: [(0, Ct.jsx)("div", { className: "popup-left", children: (0, Ct.jsx)("img", { src: "".concat("", "/movie_cover/").concat(r.id), alt: r.real_title, className: "coverPopup", onError: e => { let { currentTarget: t } = e; t.onerror = null, t.src = "".concat("", "/static/img/broken.webp") } }) }), (0, Ct.jsxs)("div", { className: "popup-right", children: [(0, Ct.jsx)("p", { className: "titlePopup", children: r.real_title }), (0, Ct.jsx)("p", { className: "descriptionPopup", children: r.description }), (0, Ct.jsxs)("div", { className: "containerPopup", children: [(0, Ct.jsxs)("p", { className: "notePopup", children: ["Note: ", r.note] }), (0, Ct.jsxs)("p", { className: "yearPopup", children: ["Date: ", r.date] }), (0, Ct.jsxs)("p", { className: "genrePopup", children: ["Genres: ", r.genre] }), (0, Ct.jsxs)("p", { className: "durationPopup", children: ["Dur\xe9e: ", r.duration] })] }), (0, Ct.jsx)("div", { className: "containerCast", children: (0, Ct.jsx)("div", { className: "castPopup", id: "castPopup", children: r.cast.split(",").map(((e, t) => (0, Ct.jsx)(Xt, { id: e }, t))) }) }), (0, Ct.jsx)("div", { className: "containerSeasons" }), (0, Ct.jsx)("div", { className: "containerSimilar", children: r.similar && r.similar.map(((e, t) => (0, Ct.jsx)("img", { className: "similarPopup", src: "".concat("", "/").concat(e.cover), alt: e.title, title: e.title, onError: e => { let { currentTarget: t } = e; t.onerror = null, t.src = "".concat("", "/static/img/broken.webp") } }, t))) }), r.bande_annonce_url && (0, Ct.jsx)("div", { className: "containerTrailer", children: (0, Ct.jsx)("iframe", { className: "trailerPopup", src: r.bande_annonce_url, title: "YouTube video player", allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", allowFullScreen: !0 }) }), (0, Ct.jsxs)("div", { className: "popupButtons", children: [(0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(ut, {}), text: "Watch now", onClick: function () { i("/movie/" + n) } }), (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(tt, {}), text: "Download", onClick: function () { window.location.href = "".concat("", "/download_movie/").concat(n) } })] })] })] }) : (0, Ct.jsx)(Nt, {})] }) } function Jt(e) { let { onClose: t, id: n } = e; const { data: i } = je("".concat("", "/get_serie_data/").concat(n)), r = Y(); return (0, Ct.jsxs)("div", { id: "popup", className: "popup", children: [(0, Ct.jsx)(Je, { className: "crossPopup", id: "crossPopup", onClick: t }), i ? (0, Ct.jsxs)("div", { className: "popupContent", children: [(0, Ct.jsx)("div", { className: "popup-left", children: (0, Ct.jsx)("img", { src: "".concat("", "/serie_cover/").concat(n), alt: i.title, className: "coverPopup", onError: e => { let { currentTarget: t } = e; t.onerror = null, t.src = "".concat("", "/static/img/broken.webp") } }) }), (0, Ct.jsxs)("div", { className: "popup-right ".concat(i.latest_id ? "popup-serie-right" : ""), children: [(0, Ct.jsx)("p", { className: "titlePopup", children: i.name }), (0, Ct.jsx)("p", { className: "descriptionPopup", children: i.description }), (0, Ct.jsxs)("div", { className: "containerPopup", children: [(0, Ct.jsxs)("p", { className: "notePopup", children: ["Note: ", i.note] }), (0, Ct.jsxs)("p", { className: "yearPopup", children: ["Date: ", i.date] }), (0, Ct.jsxs)("p", { className: "genrePopup", children: ["Genres: ", i.genre] })] }), (0, Ct.jsx)("div", { className: "containerCast", children: (0, Ct.jsx)("div", { className: "castPopup", id: "castPopup", children: i.cast.split(",").map(((e, t) => (0, Ct.jsx)(Xt, { id: e }, t))) }) }), (0, Ct.jsx)("div", { className: "containerSeasons", style: { marginBottom: i.bande_annonce_url ? "auto" : "100px" }, children: i.seasons && Object.keys(i.seasons).map(((e, t) => (0, Ct.jsxs)(Se, { to: "/season/" + i.seasons[e].season_id, children: [(0, Ct.jsx)("img", { className: "seasonPopup", src: "".concat("", "/season_cover/").concat(i.seasons[e].season_id), alt: i.seasons[e].season_name, onError: e => { let { currentTarget: t } = e; t.onerror = null, t.src = "".concat("", "/static/img/broken.webp") } }), (0, Ct.jsx)("p", { className: "seasonNamePopup", children: i.seasons[e].season_name })] }, t))) }), i.bandeAnnonceUrl && (0, Ct.jsx)("div", { className: "containerTrailer", children: (0, Ct.jsx)("iframe", { className: "trailerPopup", src: i.bande_annonce_url, title: "YouTube video player", allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", allowFullScreen: !0 }) }), i.latest_id && (0, Ct.jsx)("div", { className: "popupButtons", children: (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(ut, {}), text: "Resume", onClick: () => r("/episode/" + i.latest_id) }) })] })] }) : (0, Ct.jsx)(Nt, {})] }) } function Zt(e) { let { onClose: n, refreshAllLibraries: i } = e; const { getLang: r } = Yt(), [s, a] = (0, t.useState)("movies"), [o, l] = (0, t.useState)(""), [c, u] = (0, t.useState)(""), [d, h] = (0, t.useState)([]), { handleSubmit: p } = De(), f = [{ value: "movies", text: r("movies") }, { value: "series", text: r("series") }, { value: "books", text: r("books") }, { value: "others", text: r("other") }, { value: "tv", text: r("tv_channels") }, { value: "consoles", text: r("consoles") }, { value: "musics", text: r("musics") }], { data: m } = je("".concat("", "/get_all_users")); return (0, Ct.jsxs)("div", { id: "popup", className: "popup", children: [(0, Ct.jsx)(Je, { className: "crossPopup", id: "crossPopup", onClick: n }), (0, Ct.jsxs)("div", { className: "popupContent popupContentSettings", children: [(0, Ct.jsx)("div", { className: "libraryTypeCheckbox", children: f.map(((e, t) => (0, Ct.jsx)("div", { onClick: () => a(e.value), className: "libraryTypeCheckboxContainer" + (s === e.value ? " libraryTypeCheckboxContainerActive" : ""), children: (0, Ct.jsxs)("div", { className: "libraryTypeCheckboxIcon", children: [Pt[e.value], e.text] }) }, t))) }), (0, Ct.jsxs)("div", { className: "libraryData", children: [(0, Ct.jsxs)("div", { className: "libraryDataContainer", children: [(0, Ct.jsxs)("div", { className: "libraryDataTitle", children: [(0, Ct.jsx)("label", { htmlFor: "title", children: "Title: " }), (0, Ct.jsx)("input", { type: "text", name: "title", id: "title", className: "input", placeholder: "Title", onChange: e => l(e.target.value) })] }), (0, Ct.jsxs)("div", { className: "libraryDataFolder", children: [(0, Ct.jsx)("label", { htmlFor: "folder", children: "Folder: " }), (0, Ct.jsx)("input", { type: "text", name: "folder", id: "folder", className: "input", placeholder: "C:/...", onChange: e => u(e.target.value) })] })] }), (0, Ct.jsxs)("div", { className: "libraryAllowedUsers", children: [(0, Ct.jsx)("label", { htmlFor: "allowedUsers", children: "Allowed users" }), (0, Ct.jsx)("div", { className: "libraryAllowedUsersContainer", children: m && m.map(((e, t) => (0, Ct.jsxs)("div", { className: "libraryAllowedUsersCheckbox", children: [(0, Ct.jsx)("input", { type: "checkbox", name: "allowedUsers", id: "allowedUsers" + t, value: e.id, onChange: t => (e => { d.includes(e) ? h(d.filter((t => t !== e))) : h([...d, e]) })(e.id) }), (0, Ct.jsx)("label", { htmlFor: "allowedUsers" + t, children: e.name })] }, t))) })] })] })] }), (0, Ct.jsx)(qt, { text: "Add", onClick: () => (async () => { const e = { lib_name: o, lib_path: c, lib_type: s, lib_users: d.join(",") }; await p({ url: "".concat("", "/create_library"), body: JSON.stringify(e) }), $t({ message: "Library ".concat(o, " created") }), n(), i() })(), style: { position: "absolute", bottom: "20px", right: "20px" } })] }) } function en(e) { let { setUrl: n, setNotFound: i, keys: r = [] } = e; const [s, a] = (0, t.useState)("text_input"), o = (0, t.useRef)(null), { lib: l } = Q(), c = K().pathname.split("/")[1], { getLang: u } = Yt(); function d(e) { if (e.preventDefault(), "" !== o.current.value) if (i("Nous n'avons pas trouv\xe9 de r\xe9sultat correspondant \xe0 votre recherche."), r.length > 0) { const e = {}; for (let t of r) e[t] = "".concat("", "/search_").concat(t, "/").concat(l, "/").concat(o.current.value); n(e) } else n("".concat("", "/search_").concat(c, "/").concat(l, "/").concat(o.current.value)) } return (0, Ct.jsxs)("form", { id: "search_form", onSubmit: d, children: [(0, Ct.jsx)("input", { placeholder: u("search_text"), type: "input", id: "search", className: s, ref: o, onChange: e => { e.target.value ? a("text_input text_input_active") : a("text_input") } }), (0, Ct.jsx)("button", { type: "submit", className: "button_search", id: "button_search", onClick: d, children: (0, Ct.jsx)(mt, { className: "search_icon" }) })] }) } function tn(e) { var t; let { setUrl: n, setNotFound: i, keys: r = [] } = e; return (0, Ct.jsxs)("div", { className: "search_and_div", children: [(0, Ct.jsx)(en, { setUrl: n, setNotFound: i, keys: r }), "admin" === (null === (t = localStorage.getItem("account_type")) || void 0 === t ? void 0 : t.toLowerCase()) ? (0, Ct.jsx)(Lt, {}) : null] }) } function nn() { var e; const { lib: n } = Q(), [i, r] = (0, t.useState)("".concat("", "/get_all_movies/").concat(n)), [s, a] = (0, t.useState)((0, Ct.jsx)(Nt, {})), { data: o } = je(i), [l, ...c] = o || [], u = "admin" === (null === (e = localStorage.getItem("account_type")) || void 0 === e ? void 0 : e.toLowerCase()), [d, h] = (0, t.useState)(!1), [p, f] = (0, t.useState)(null); return (0, t.useEffect)((() => { r("".concat("", "/get_all_movies/").concat(n)) }), [n]), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(tn, { setUrl: r, setNotFound: a }), d && (0, Ct.jsx)(Qt, { onClose: () => h(!1), id: p }), l ? (0, Ct.jsx)(Gt, { name: l.real_title, description: l.description, id: l.id, full_banner: 0 === c.length }) : s, c.length > 0 || l ? (0, Ct.jsx)("div", { className: "movies", children: Array.isArray(c) ? c.map(((e, t) => (0, Ct.jsx)(Wt, { isAdmin: u, name: e.real_title, onClick: () => { return t = e.id, h(!0), void f(t); var t }, id: e.id, library: n, note: e.note, vues: {}, duration: e.duration }, t))) : null }) : null] }) } function rn(e) { let { name: t, library: n, onClick: i, note: r, id: s } = e; const a = Y(); let o = (l = r, c = 1, console.log(l), console.log(+parseFloat(l).toFixed(c)), +parseFloat(l).toFixed(c)); var l, c; let u; u = 10 * o < 50 ? 10 * o * 1.2 : 1.2 * (10 * o - 50) + 60; let d = "hsl(".concat(u, "deg, 100%, 50%)"); return (0, Ct.jsxs)("div", { className: "serie-card", onClick: i, "data-aos": "fade-up", children: [(0, Ct.jsx)(zt, { value: 10 * o, text: "".concat(o, "/10"), styles: Ht({ pathColor: d, textColor: "#fff", trailColor: "transparent" }) }), (0, Ct.jsx)(lt, { className: "edit-icon", onClick: () => a("/edit_serie/".concat(s, "/").concat(n)) }), (0, Ct.jsx)("img", { src: "".concat("", "/serie_cover/").concat(s), alt: t, loading: "lazy", onError: e => { let { currentTarget: t } = e; t.onerror = null, t.src = "".concat("", "/static/img/broken.webp") } })] }) } function sn(e) { let { name: n, id: i, description: r, showPopup: s, full_banner: a = !1 } = e; const [o, l] = (0, t.useState)(!1), { handleSubmit: c } = De(), { lib: u } = Q(); function d() { l(!o) } return (0, Ct.jsxs)("div", { className: "big-banner ".concat(a ? "full-banner" : ""), "data-aos": "fade-down", children: [(0, Ct.jsx)("div", { style: { backgroundImage: 'linear-gradient(transparent, rgb(29, 29, 29)), url("'.concat("", "/serie_banner/").concat(i, '")') }, className: "banner" }), (0, Ct.jsxs)("div", { className: "banner-data", children: [(0, Ct.jsx)("h1", { children: n }), function (e) { if (e && e.length > 200) { const t = e.slice(0, 200); return (0, Ct.jsxs)("p", { className: "banner-description", style: { overflowY: o ? "scroll" : "hidden" }, children: [o ? e : t, (0, Ct.jsx)("span", { className: "more", onClick: d, children: o ? "less" : "... more" })] }) } return (0, Ct.jsx)("p", { className: "banner-description", children: e }) }(r), (0, Ct.jsxs)("div", { className: "banner-buttons", children: [(0, Ct.jsx)("div", { className: "banner-buttons-left", children: (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(ut, {}), text: "Watch now", onClick: s }) }), (0, Ct.jsx)("div", { className: "banner-buttons-right", children: (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(pt, {}), text: "Refresh", onClick: function () { c({ url: "".concat("", "/rescan/").concat(u) }) } }) })] })] })] }) } function an() { const { lib: e } = Q(), [n, i] = (0, t.useState)("".concat("", "/get_all_series/").concat(e)), [r, s] = (0, t.useState)((0, Ct.jsx)(Nt, {})), [a, o] = (0, t.useState)(!1), [l, c] = (0, t.useState)(null), { data: u } = je(n), [d, ...h] = u || []; function p(e) { o(!0), c(e) } return (0, t.useEffect)((() => { i("".concat("", "/get_all_series/").concat(e)) }), [e]), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(tn, { setUrl: i, setNotFound: s }), a && (0, Ct.jsx)(Jt, { onClose: () => o(!1), id: l }), d ? (0, Ct.jsx)(sn, { name: d.name, id: d.id, description: d.description, showPopup: () => p(d.id), full_banner: 0 === h.length }) : r, h.length > 0 || d ? (0, Ct.jsx)("div", { className: "series", children: Array.isArray(h) ? h.map((t => (0, Ct.jsx)(rn, { name: t.name, id: t.id, onClick: () => p(t.id), library: e, note: t.note }, t.id))) : null }) : null] }) } function on(e) { let { id: t, title: n, type: i, lib: r } = e; return (0, Ct.jsxs)(Se, { className: "book-card", to: "folder" === i ? "/books/".concat(r, "-").concat(n) : "/book/".concat(t), "data-aos": "fade-up", children: [(0, Ct.jsx)("img", { src: "".concat("", "/book_cover/").concat(t), alt: n, className: "bookCover", loading: "lazy" }), (0, Ct.jsx)("p", { children: n })] }) } function ln() { const { lib: e } = Q(), [n, i] = (0, t.useState)("".concat("", "/get_all_books/").concat(e)), [r, s] = (0, t.useState)((0, Ct.jsx)(Nt, {})), { data: a } = je(n); return (0, t.useEffect)((() => { i("".concat("", "/get_all_books/").concat(e)) }), [e]), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(tn, { setUrl: i, setNotFound: s }), (0, Ct.jsx)("div", { className: "books", children: Array.isArray(a) ? a.map((t => (0, Ct.jsx)(on, { id: t.id, title: t.title, url: "".concat("", "/").concat(t.cover), type: t.book_type, lib: e }))) : r })] }) } function cn(e) { let { name: t, url: n, hash: i } = e; const r = Y(), { handleSubmit: s } = De(), { lib: a } = Q(); return (0, Ct.jsxs)("div", { className: "big-banner", children: [(0, Ct.jsx)("div", { src: n, style: { backgroundImage: 'linear-gradient(transparent, rgb(29, 29, 29)), url("'.concat(n, '")') }, className: "banner" }), (0, Ct.jsxs)("div", { className: "banner-data", children: [(0, Ct.jsx)("h1", { children: t }), (0, Ct.jsxs)("div", { className: "banner-buttons", children: [(0, Ct.jsxs)("div", { className: "banner-buttons-left", children: [(0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(ut, {}), text: "Watch now", onClick: () => r("/other/" + i) }), (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(tt, {}), text: "Download", onClick: () => window.location.href = "".concat("", "/download_other/").concat(i) })] }), (0, Ct.jsx)("div", { className: "banner-buttons-right", children: (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(pt, {}), text: "Refresh", onClick: function () { s({ url: "".concat("", "/rescan/").concat(a) }) } }) })] })] })] }) } function un() { const { lib: e } = Q(), [n, i] = (0, t.useState)("".concat("", "/get_all_others/").concat(e)), [r, s] = (0, t.useState)((0, Ct.jsx)(Nt, {})), { data: a } = je(n), [o, ...l] = a || []; return (0, t.useEffect)((() => { i("".concat("", "/get_all_others/").concat(e)) }), [e]), (0, t.useEffect)((() => { console.log(a) }), [a]), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(tn, { setUrl: i, setNotFound: s }), o ? (0, Ct.jsx)(cn, { name: o.title, url: "".concat("", "/other_cover/").concat(o.video_hash), hash: o.video_hash }) : r, (0, Ct.jsx)("div", { className: "others", children: Array.isArray(l) ? l.map((e => (0, Ct.jsxs)(Se, { to: "/other/".concat(e.video_hash), className: "other-card", children: [(0, Ct.jsx)("img", { src: "".concat("", "/other_cover/").concat(e.video_hash), alt: e.title }), (0, Ct.jsx)("h3", { children: e.title })] }))) : null })] }) } function dn() { const { lib: e } = Q(), [n, i] = (0, t.useState)((0, Ct.jsx)(Nt, {})), [r, s] = (0, t.useState)("".concat("", "/get_channels/").concat(e)); (0, t.useEffect)((() => { s("".concat("", "/get_channels/").concat(e)) }), [e]); const { data: a } = je(r); return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(tn, { setNotFound: i, setUrl: s }), (0, Ct.jsx)("div", { className: "channels", children: Array.isArray(a) ? a.map((t => (0, Ct.jsxs)(Se, { to: "/channel/".concat(e, "/").concat(t.channelID), className: "channel-card", "data-aos": "fade-up", children: [(0, Ct.jsx)("img", { src: "".concat(t.logo), alt: t.name, onError: e => { let { currentTarget: t } = e; t.onerror = null, t.src = "".concat("", "/static/img/broken.webp") } }), (0, Ct.jsx)("p", { children: t.name })] }, t.id))) : n })] }) } function hn(e) { let { short_name: t, name: n, image: i, onClick: r } = e; return (0, Ct.jsxs)("div", { className: "consoles-card", onClick: r, "data-aos": "fade-up", children: [(0, Ct.jsx)("img", { src: i, alt: n, loading: "lazy", onError: e => { let { currentTarget: t } = e; t.onerror = null, t.src = "".concat("", "/static/img/broken.webp") } }), (0, Ct.jsx)("p", { children: n })] }) } function pn() { const { lib: e } = Q(), [n, i] = (0, t.useState)("".concat("", "/get_all_consoles/").concat(e)), [r, s] = (0, t.useState)((0, Ct.jsx)(Nt, {})), { data: a } = je(n), o = Y(); return console.log(a), (0, t.useEffect)((() => { i("".concat("", "/get_all_consoles/").concat(e)) }), [e]), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(tn, { setUrl: i, setNotFound: s }), (0, Ct.jsx)("div", { className: "consoles", children: Array.isArray(a) ? a.map((t => (0, Ct.jsx)(hn, { short_name: t.short_name, name: t.name, image: "".concat("", "/").concat(t.image), onClick: () => o("/console/".concat(e, "/").concat(t.short_name)) }, t.short_name))) : r })] }) } function fn(e) { let { playlists: n, lib: i } = e; const r = (0, t.useRef)(null), s = (0, t.useRef)(null), [a, o] = (0, t.useState)(0), [l, c] = (0, t.useState)(!1), [u, d] = (0, t.useState)(!1), [h, p] = (0, t.useState)(0), [f, m] = (0, t.useState)(0), [g, y] = (0, t.useState)(null), v = Y(), { getLang: b } = Yt(); (0, t.useEffect)((() => { const e = s.current, t = r.current; if (e) { let { width: n } = e.getBoundingClientRect(); n += parseInt(getComputedStyle(t).columnGap), o(2 * n) } }), []), (0, t.useEffect)((() => { const e = r.current; if (e) { const { width: t } = e.getBoundingClientRect(); m(t) } }), [r]), (0, t.useLayoutEffect)((() => { var e; r.current && r.current.scrollWidth > (null === (e = r.current) || void 0 === e ? void 0 : e.clientWidth) ? c(!0) : c(!1), r.current && r.current.scrollLeft > 0 ? d(!0) : d(!1) }), [r]), (0, t.useEffect)((() => { d(0 !== h) }), [h]), (0, t.useEffect)((() => { const e = r.current, t = () => { const t = (null === e || void 0 === e ? void 0 : e.scrollWidth) - (null === e || void 0 === e ? void 0 : e.clientWidth), n = null === e || void 0 === e ? void 0 : e.scrollLeft; c(n !== t) }, n = () => { const e = r.current.scrollLeft; if (e % a > .2 || e % a < -.2) { let t = Math.round(e / a) * a; r.current.scrollTo({ left: t, behavior: "smooth" }) } }; return null === e || void 0 === e || e.addEventListener("scroll", t), null === e || void 0 === e || e.addEventListener("scrollend", n), () => { null === e || void 0 === e || e.removeEventListener("scroll", t), null === e || void 0 === e || e.removeEventListener("scrollend", n) } }), []); return (0, Ct.jsxs)("div", { className: "main-carousel", "data-aos": "fade-up", children: [(0, Ct.jsxs)("div", { className: "carousel-header", children: [b("playlists"), ":"] }), u && (0, Ct.jsx)("div", { className: "carousel-arrow", onClick: () => { r.current.scrollBy({ left: -a, behavior: "smooth" }), p(h - 1) }, children: (0, Ct.jsx)(Ye, {}) }), (0, Ct.jsx)("div", { className: "carousel-container", ref: r, children: n.map(((e, t) => (0, Ct.jsxs)("div", { className: "carousel-item ".concat(g && g - 2 * h - 1 === t ? "carousel-item-hovered" : ""), ref: s, onClick: () => v("/playlist/".concat(i, "/").concat(e.id)), onMouseEnter: () => y(t + 1), onMouseLeave: () => y(null), children: [(0, Ct.jsx)("img", { src: "".concat("", "/playlist_cover/").concat(e.id), alt: e.name, className: "carousel-cover" }), (0, Ct.jsxs)("div", { className: "carousel-info", children: [(0, Ct.jsx)("div", { className: "carousel-name", children: e.name }), (0, Ct.jsx)("div", { className: "carousel-tracks", children: "".concat(e.tracks.split(",").length, " titre").concat(e.tracks.split(",").length > 1 ? "s" : "") })] })] }, t))) }), l && (0, Ct.jsx)("div", { className: "carousel-arrow", onClick: () => { r.current.scrollBy({ left: a, behavior: "smooth" }), p(h + 1) }, style: { marginLeft: "calc(".concat(f, "px - 4rem)") }, children: (0, Ct.jsx)(Qe, {}) })] }) } function mn(e) { let { albums: n, lib: i } = e; const r = (0, t.useRef)(null), s = (0, t.useRef)(null), [a, o] = (0, t.useState)(0), [l, c] = (0, t.useState)(!1), [u, d] = (0, t.useState)(!1), [h, p] = (0, t.useState)(0), [f, m] = (0, t.useState)(0), [g, y] = (0, t.useState)(null), v = Y(), { getLang: b } = Yt(); (0, t.useEffect)((() => { const e = s.current, t = r.current; if (e) { let { width: n } = e.getBoundingClientRect(); n += parseInt(getComputedStyle(t).columnGap), o(2 * n) } }), []), (0, t.useEffect)((() => { const e = r.current; if (e) { const { width: t } = e.getBoundingClientRect(); m(t) } }), [r]), (0, t.useLayoutEffect)((() => { var e; r.current && r.current.scrollWidth > (null === (e = r.current) || void 0 === e ? void 0 : e.clientWidth) ? c(!0) : c(!1), r.current && r.current.scrollLeft > 0 ? d(!0) : d(!1) }), [r]), (0, t.useEffect)((() => { d(0 !== h) }), [h]), (0, t.useEffect)((() => { const e = r.current; let t = (null === e || void 0 === e ? void 0 : e.scrollWidth) - (null === e || void 0 === e ? void 0 : e.clientWidth), n = null === e || void 0 === e ? void 0 : e.scrollLeft; console.log("containerElement?.scrollWidth: ".concat(null === e || void 0 === e ? void 0 : e.scrollWidth, ", containerElement?.clientWidth: ").concat(null === e || void 0 === e ? void 0 : e.clientWidth)); const i = () => { t = (null === e || void 0 === e ? void 0 : e.scrollWidth) - (null === e || void 0 === e ? void 0 : e.clientWidth), n = null === e || void 0 === e ? void 0 : e.scrollLeft, c(!(t <= n)) }, s = () => { const e = r.current.scrollLeft; if (e % a > .2 || e % a < -.2) { let t = Math.round(e / a) * a; r.current.scrollTo({ left: t, behavior: "smooth" }) } }; return null === e || void 0 === e || e.addEventListener("scroll", i), null === e || void 0 === e || e.addEventListener("scrollend", s), () => { null === e || void 0 === e || e.removeEventListener("scroll", i), null === e || void 0 === e || e.removeEventListener("scrollend", s) } }), [f, a, r]); return (0, Ct.jsxs)("div", { className: "main-carousel", "data-aos": "fade-up", children: [(0, Ct.jsxs)("div", { className: "carousel-header", children: [b("albums"), ":"] }), u && (0, Ct.jsx)("div", { className: "carousel-arrow", onClick: () => { r.current.scrollBy({ left: -a, behavior: "smooth" }), p(h - 1) }, children: (0, Ct.jsx)(Ye, {}) }), (0, Ct.jsx)("div", { className: "carousel-container", ref: r, children: n && n.map(((e, t) => { return (0, Ct.jsxs)("div", { className: "carousel-item ".concat(g && g - 2 * h - 1 === t ? "carousel-item-hovered" : ""), ref: s, onMouseEnter: () => y(t + 1), onMouseLeave: () => y(null), children: [(0, Ct.jsx)("img", { src: "".concat("", "/album_cover/").concat(e.id), alt: e.name, className: "carousel-cover", onClick: () => v("/album/".concat(i, "/").concat(e.id)) }), (0, Ct.jsxs)("div", { className: "carousel-info", onClick: () => v("/album/".concat(i, "/").concat(e.id)), children: [(0, Ct.jsx)("div", { className: "carousel-name", children: (n = e.name, n.length > 21 ? n.substring(0, 18) + "..." : n) }), (0, Ct.jsx)("div", { className: "carousel-tracks", children: "".concat(e.tracks.split(",").length, " titres") })] })] }, t); var n })) }), l && (0, Ct.jsx)("div", { className: "carousel-arrow", onClick: () => { r.current.scrollBy({ left: a, behavior: "smooth" }), p(h + 1) }, style: { marginLeft: "calc(".concat(f, "px - 4rem)") }, children: (0, Ct.jsx)(Qe, {}) })] }) } function gn(e) { let { artists: n, lib: i } = e; const r = (0, t.useRef)(null), s = (0, t.useRef)(null), [a, o] = (0, t.useState)(0), [l, c] = (0, t.useState)(!1), [u, d] = (0, t.useState)(!1), [h, p] = (0, t.useState)(0), [f, m] = (0, t.useState)(0), g = Y(), { getLang: y } = Yt(); (0, t.useEffect)((() => { const e = s.current, t = r.current; if (e) { let { width: n } = e.getBoundingClientRect(); n += parseInt(getComputedStyle(t).columnGap), o(2 * n) } }), []), (0, t.useEffect)((() => { const e = r.current; if (e) { const { width: t } = e.getBoundingClientRect(); m(t) } }), [r]), (0, t.useLayoutEffect)((() => { var e; r.current && r.current.scrollWidth > (null === (e = r.current) || void 0 === e ? void 0 : e.clientWidth) ? c(!0) : c(!1), r.current && r.current.scrollLeft > 0 ? d(!0) : d(!1) }), [r]), (0, t.useEffect)((() => { d(0 !== h) }), [h]), (0, t.useEffect)((() => { const e = r.current, t = () => { const t = (null === e || void 0 === e ? void 0 : e.scrollWidth) - (null === e || void 0 === e ? void 0 : e.clientWidth), n = null === e || void 0 === e ? void 0 : e.scrollLeft; c(n !== t) }, n = () => { const e = r.current.scrollLeft; if (e % a > .2 || e % a < -.2) { let t = Math.round(e / a) * a; r.current.scrollTo({ left: t, behavior: "smooth" }) } }; return null === e || void 0 === e || e.addEventListener("scroll", t), null === e || void 0 === e || e.addEventListener("scrollend", n), () => { null === e || void 0 === e || e.removeEventListener("scroll", t), null === e || void 0 === e || e.removeEventListener("scrollend", n) } }), []); return (0, Ct.jsxs)("div", { className: "main-carousel", "data-aos": "fade-up", children: [(0, Ct.jsxs)("div", { className: "carousel-header", children: [y("artists"), ":"] }), u && (0, Ct.jsx)("div", { className: "carousel-arrow", onClick: () => { r.current.scrollBy({ left: -a, behavior: "smooth" }), p(h - 1) }, children: (0, Ct.jsx)(Ye, {}) }), (0, Ct.jsx)("div", { className: "carousel-container", ref: r, children: n.map(((e, t) => { return (0, Ct.jsxs)("div", { className: "carousel-item", ref: s, onClick: () => g("/artist/".concat(i, "/").concat(e.id)), children: [(0, Ct.jsx)("img", { src: "".concat("", "/artist_image/").concat(e.id), alt: e.name, className: "carousel-cover artist-cover" }), (0, Ct.jsx)("div", { className: "carousel-info", children: (0, Ct.jsx)("div", { className: "carousel-name artist-name", children: (n = e.name, n.length > 21 ? n.substring(0, 18) + "..." : n) }) })] }, t); var n })) }), l && (0, Ct.jsx)("div", { className: "carousel-arrow", onClick: () => { r.current.scrollBy({ left: a, behavior: "smooth" }), p(h + 1) }, style: { marginLeft: "calc(".concat(f, "px - 4rem)") }, children: (0, Ct.jsx)(Qe, {}) })] }) } function yn(e) { let { tracks: n, lib: i } = e; const [r, s] = (0, t.useState)(0), [a, o] = (0, t.useState)(0), [l, c] = (0, t.useState)(!1), [u, d] = (0, t.useState)(!1), [h, p] = (0, t.useState)([[]]), { getLang: f } = Yt(); (0, t.useEffect)((() => { const e = []; for (let t = 0; t < n.length; t += 12)e.push(n.slice(t, t + 12)); p(e), o(e.length - 1) }), [n]), (0, t.useEffect)((() => { d(0 !== r), c(r !== a) }), [r, a]); if (!h || 0 === h.length) return null; const m = h[r] || null; return (0, Ct.jsxs)("div", { className: "main-carousel single-carousel", children: [(0, Ct.jsxs)("div", { className: "carousel-header", children: [f("singles"), ":"] }), u && (0, Ct.jsx)("div", { className: "carousel-arrow tracks-arrow-left", onClick: () => { s(r - 1) }, children: (0, Ct.jsx)(Ye, {}) }), (0, Ct.jsx)("div", { className: "carousel-container single-container", children: m && m.map(((e, t) => (0, Ct.jsx)(vn, { track: e }, t))) }), l && (0, Ct.jsx)("div", { className: "carousel-arrow tracks-arrow-right", onClick: () => { s(r + 1) }, children: (0, Ct.jsx)(Qe, {}) })] }) } const vn = e => { let { track: t } = e; const { setSources: n, setVisible: i, setIsPlaying: r, setSourceIndex: s } = Cm(); return (0, Ct.jsxs)("div", { className: "carousel-item single-item", onClick: function () { i(!0), r(!0), n([t]), s(0) }, children: [(0, Ct.jsx)("img", { src: "".concat("", "/track_cover/").concat(t.id), alt: t.name, className: "carousel-cover single-cover" }), (0, Ct.jsxs)("div", { className: "carousel-info", children: [(0, Ct.jsx)("div", { className: "carousel-name", children: (a = t.name, a.length > 21 ? a.substring(0, 18) + "..." : a) }), (0, Ct.jsxs)("div", { className: "carousel-info", children: [t.album_name, " \u2022 ", t.artist_name] })] })] }); var a }; function bn() { const { lib: e } = Q(), [n, i] = (0, t.useState)({ playlists: "".concat("", "/get_all_playlists/").concat(e), albums: "".concat("", "/get_all_albums/").concat(e), artists: "".concat("", "/get_all_artists/").concat(e), tracks: "".concat("", "/get_all_tracks/").concat(e) }), [r, s] = (0, t.useState)((0, Ct.jsx)(Nt, {})), { data: a } = je(n.playlists), { data: o } = je(n.albums), { data: l } = je(n.artists), { data: c } = je(n.tracks); return (0, t.useEffect)((() => { i({ playlists: "".concat("", "/get_all_playlists/").concat(e), albums: "".concat("", "/get_all_albums/").concat(e), artists: "".concat("", "/get_all_artists/").concat(e), tracks: "".concat("", "/get_all_tracks/").concat(e) }) }), [e]), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(tn, { setUrl: i, setNotFound: s, keys: ["playlists", "albums", "artists", "tracks"] }), (0, Ct.jsxs)("div", { className: "musics-carousels", children: [a || o || l || c ? null : r, a && a.length > 0 ? (0, Ct.jsx)(fn, { playlists: a, lib: e }) : null, o && o.length > 0 ? (0, Ct.jsx)(mn, { albums: o, lib: e }) : null, l && l.length > 0 ? (0, Ct.jsx)(gn, { artists: l, lib: e }) : null, c && c.length > 0 ? (0, Ct.jsx)(yn, { tracks: c, lib: e }) : null] })] }) } function _n() { const e = Y(), { data: n } = je("".concat("", "/is_admin")); (0, t.useEffect)((() => { null === n || n || e("/") }), [e, n]) } function Tn() { _n(); const { id: e, lib: n } = Q(), i = (0, t.useRef)(), r = Y(), { data: s } = je("".concat("", "/edit_movie/").concat(e, "/").concat(n)), { handleSubmit: a } = De(), o = (t, n) => { let i = "".concat("", "/edit_movie/").concat(e, "/").concat(n); console.log(i), a({ url: i, body: { new_id: t } }), r("/movies/".concat(n)) }; return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsxs)("h1", { children: ["Edit Movie ", (null === s || void 0 === s ? void 0 : s.file_title) || e, " from ", n] }), (0, Ct.jsxs)("div", { className: "movies edit-movies", children: [s && s.movies.length > 0 && s.movies.map(((e, t) => (0, Ct.jsxs)("div", { className: "edit-movie", onClick: () => o(e.id, n), children: [(0, Ct.jsx)("img", { src: "https://www.themoviedb.org/t/p/w600_and_h900_bestv2".concat(e.poster_path), alt: e.title, onError: e => { let { currentTarget: t } = e; t.onerror = null, t.src = "".concat("", "/static/img/broken.webp") } }), (0, Ct.jsxs)("h3", { children: [e.title, " ", e.release_date && "(".concat(e.release_date.slice(0, 4), ")")] })] }, t))), (0, Ct.jsxs)("div", { class: "edit-movie edit-movie-custom", children: [(0, Ct.jsx)("h3", { children: "Custom ID" }), (0, Ct.jsx)("input", { type: "text", placeholder: "New ID", ref: i, className: "input" }), (0, Ct.jsx)("button", { onClick: () => o(i.current.value, n), className: "button small", children: "Submit" })] })] })] }) } function Sn() { _n(); const { id: e, lib: n } = Q(), i = (0, t.useRef)(), r = Y(), { data: s } = je("".concat("", "/edit_serie/").concat(e, "/").concat(n)), { handleSubmit: a } = De(), o = (t, n) => { let i = "".concat("", "/edit_serie/").concat(e, "/").concat(n); console.log(i), a({ url: i, body: { new_id: t } }), r("/series/".concat(n)) }; return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsxs)("h1", { children: ["Edit Serie ", (null === s || void 0 === s ? void 0 : s.folder_title) || e, " from ", n] }), (0, Ct.jsxs)("div", { className: "series edit-series", children: [s && s.series.length > 0 && s.series.map(((e, t) => (0, Ct.jsxs)("div", { className: "edit-serie", onClick: () => o(e.id, n), children: [(0, Ct.jsx)("img", { src: "https://www.themoviedb.org/t/p/w600_and_h900_bestv2".concat(e.poster_path), alt: e.title, onError: e => { let { currentTarget: t } = e; t.onerror = null, t.src = "".concat("", "/static/img/broken.webp") } }), (0, Ct.jsxs)("h3", { children: [e.name, " ", e.first_air_date && "(".concat(e.first_air_date.slice(0, 4), ")")] })] }, t))), (0, Ct.jsxs)("div", { class: "edit-serie edit-serie-custom", children: [(0, Ct.jsx)("h3", { children: "Custom ID" }), (0, Ct.jsx)("input", { type: "text", placeholder: "New ID", ref: i, className: "input" }), (0, Ct.jsx)("button", { onClick: () => o(i.current.value, n), className: "button small", children: "Submit" })] })] })] }) } function wn(e) { let { name: n, description: i, id: r, number: s } = e; const [a, o] = (0, t.useState)(!1), l = Y(); function c() { o(!a) } return (0, Ct.jsxs)("div", { className: "big-banner", children: [(0, Ct.jsx)("div", { style: { backgroundImage: 'linear-gradient(transparent, rgb(29, 29, 29)), url("'.concat("", "/episode_cover/").concat(r, '"') }, className: "banner" }), (0, Ct.jsxs)("div", { className: "banner-data", children: [(0, Ct.jsx)("h1", { children: "EP".concat(s, " - ").concat(n) }), function (e) { if (e && e.length > 200) { const t = e.slice(0, 200); return (0, Ct.jsxs)("p", { className: "banner-description", style: { overflowY: a ? "scroll" : "hidden" }, children: [a ? e : t, (0, Ct.jsx)("span", { className: "more", onClick: c, children: a ? "less" : "... more" })] }) } return (0, Ct.jsx)("p", { className: "banner-description", children: e }) }(i), (0, Ct.jsxs)("div", { className: "banner-buttons", children: [(0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(ut, {}), text: "Watch now", onClick: () => l("/episode/" + r) }), (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(tt, {}), text: "Download", onClick: () => window.location.href = "".concat("", "/download_episode/").concat(r) })] })] })] }) } function xn(e) { let { name: t, description: n, id: i, number: r } = e; const s = Y(); return (0, Ct.jsxs)("div", { className: "episode-card", children: [(0, Ct.jsx)("img", { src: "".concat("", "/episode_cover/").concat(i), alt: t, loading: "lazy" }), (0, Ct.jsxs)("div", { className: "episode-card-left", children: [(0, Ct.jsx)("h1", { children: "EP".concat(r, " - ").concat(t) }), (0, Ct.jsx)("p", { children: n }), (0, Ct.jsxs)("div", { className: "episode-card-buttons", children: [(0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(ut, {}), text: "Watch now", onClick: () => s("/episode/" + i) }), (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(tt, {}), text: "Download", onClick: () => window.location.href = "".concat("", "/download_episode/").concat(i) })] })] })] }) } function kn(e) { let { path: t = -1 } = e, n = Y(); return (0, Ct.jsx)("div", { className: "go-back", onClick: () => n(t), children: (0, Ct.jsx)(qe, {}) }) } function En() { const { id: e } = Q(), [n, i] = (0, t.useState)((0, Ct.jsx)(Nt, {})), { data: r } = je("".concat("", "/get_episodes/").concat(e)), [s, ...a] = (null === r || void 0 === r ? void 0 : r.episodes) || []; return console.log(r), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(Ot, {}), (0, Ct.jsx)(kn, { path: "/series/".concat(null === r || void 0 === r ? void 0 : r.library) }), s ? (0, Ct.jsx)(wn, { name: s.episode_name, url: s.episode_cover_path, description: s.episode_description, id: s.episode_id, number: s.episode_number }) : n, (0, Ct.jsx)("div", { className: "episodes", children: Array.isArray(a) ? a.map((e => (0, Ct.jsx)(xn, { name: e.episode_name, description: e.episode_description, url: e.episode_cover_path, id: e.episode_id, number: e.episode_number }, e.id))) : (0, Ct.jsx)("p", { children: n }) })] }) } function Cn(e) { let { title: t, cover: n, onClick: i } = e; return (0, Ct.jsxs)("div", { className: "game-card", onClick: i, "data-aos": "fade-up", children: [(0, Ct.jsx)("img", { src: n, alt: t, onError: e => { let { currentTarget: t } = e; t.onerror = null, t.src = "".concat("", "/static/img/broken.webp") } }), (0, Ct.jsx)("p", { children: t })] }) } function Pn() { const { lib: e, console: n } = Q(), [i, r] = (0, t.useState)("".concat("", "/get_all_games/").concat(e, "/").concat(n)), [s, a] = (0, t.useState)((0, Ct.jsx)(Nt, {})), { data: o } = je(i), l = Y(); return (0, t.useEffect)((() => { r("".concat("", "/get_all_games/").concat(e, "/").concat(n)) }), [e, n]), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(tn, { setUrl: r, setNotFound: a }), (0, Ct.jsx)("div", { className: "games", children: Array.isArray(o) ? o.map((t => (0, Ct.jsx)(Cn, { title: t.title, cover: t.cover, onClick: () => l("/game/".concat(e, "/").concat(n, "/").concat(t.id)) }, t.id))) : s })] }) } function In(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { fill: "none", d: "M0 0h24v24H0z" } }, { tag: "path", attr: { d: "M14 10H3v2h11v-2zm0-4H3v2h11V6zm4 8v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zM3 16h7v-2H3v2z" } }] })(e) } function Ln(e) { let { setShowCreatePopup: t, trackId: n } = e; const { lib: i } = Q(), { handleSubmit: r } = De(); return (0, Ct.jsx)("div", { className: "playlist-create-popup-parent", children: (0, Ct.jsxs)("div", { className: "playlist-create-popup", children: [(0, Ct.jsx)("h1", { children: "Create a playlist" }), (0, Ct.jsxs)("div", { className: "playlist-create-input", children: [(0, Ct.jsx)("label", { htmlFor: "playlist-name", children: "Playlist name" }), (0, Ct.jsx)("input", { type: "text", name: "playlist-name", id: "playlist-name", className: "input" })] }), (0, Ct.jsx)("div", { className: "playlist-create-buttons", children: (0, Ct.jsx)(qt, { text: "Create", type: "playlist-create small", onClick: () => { r({ url: "".concat("", "/create_playlist"), body: { name: document.getElementById("playlist-name").value, user_id: localStorage.getItem("id"), track_id: n, library: i } }), t(!1) } }) })] }) }) } function On(e) { return ze({ tag: "svg", attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z", clipRule: "evenodd" } }] })(e) } function An(e) { let { trackId: n, hidePlaylistPopup: i } = e; const { lib: r } = Q(), [s, a] = (0, t.useState)(!1), [o, l] = (0, t.useState)("".concat("", "/get_all_playlists/").concat(r)), { handleSubmit: c } = De(), { data: u } = je(o); return (0, t.useEffect)((() => { s || l("".concat("", "/get_all_playlists/").concat(r)) }), [s, r]), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsxs)("div", { className: "playlist-popup", children: [(0, Ct.jsx)(Je, { className: "crossPopup", id: "crossPopup", onClick: i }), (0, Ct.jsxs)("div", { className: "playlist-popup-content", children: [(0, Ct.jsx)("h1", { children: "Playlists" }), (0, Ct.jsx)("div", { className: "playlist-popup-playlists", children: null === u || void 0 === u ? void 0 : u.filter((e => 0 !== e.id)).map(((e, t) => (0, Ct.jsxs)("div", { className: "playlist-popup-playlist", onClick: () => { return t = e.id, void c({ url: "".concat("", "/add_track_to_playlist"), body: { playlist_id: t, track_id: n } }); var t }, children: [(0, Ct.jsx)("img", { src: "".concat("", "/playlist_cover/").concat(e.id), alt: "playlist cover" }), (0, Ct.jsxs)("div", { className: "playlist-popup-playlist-infos", children: [(0, Ct.jsx)("h2", { children: e.name }), (0, Ct.jsxs)("p", { children: [e.tracks.split(",").length, " titre", e.tracks.split(",").length > 1 ? "s" : ""] })] })] }, t))) }), (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(On, {}), text: "Playlist", type: "playlist-create small", onClick: () => a(!0) })] })] }), s && (0, Ct.jsx)(Ln, { setShowCreatePopup: a, trackId: n })] }) } function Nn(e) { var n; let { track: i, index: r, tracks: s, album: a = {}, playlist: o } = e; const [l, c] = (0, t.useState)(!1), [u, d] = (0, t.useState)(!1), [h, p] = (0, t.useState)(null), [f, m] = (0, t.useState)(!1), g = (0, t.useRef)(null), { setSources: y, setVisible: v, setIsPlaying: b, setSourceIndex: _ } = Cm(); const { handleSubmit: T } = De(); function S(e) { e.stopPropagation(), d(!u), p(!u) } return (0, t.useEffect)((() => { i && d(i.liked) }), [i]), (0, t.useEffect)((() => { null !== h && T({ url: "".concat("", "/like_track/").concat(i.id, "/").concat(localStorage.getItem("id")) }) }), [h]), (0, Ct.jsxs)(Ct.Fragment, { children: [f && (0, Ct.jsx)(An, { trackId: i.id, hidePlaylistPopup: function (e) { m(!1) } }), (0, Ct.jsxs)("div", { className: "album-track", onMouseEnter: function () { c(!0) }, onMouseLeave: function () { c(!1) }, onClick: function () { v(!0), b(!0), y(s), _(r - 1) }, ref: g, children: [l && (0, Ct.jsxs)("div", { className: "track-row-hover", style: { width: "calc(".concat(null === (n = g.current) || void 0 === n ? void 0 : n.offsetWidth, "px - 4rem)") }, children: [(0, Ct.jsx)(ut, { className: "track-row-play" }), (0, Ct.jsxs)("div", { children: [u ? (0, Ct.jsx)(vt, { className: "track-row-like", onClick: S }) : (0, Ct.jsx)(yt, { className: "track-row-like", onClick: S }), (0, Ct.jsx)(In, { className: "track-row-playlist", onClick: function (e) { e.stopPropagation(), m(!0) } }), o ? (0, Ct.jsx)(bt, { className: "track-row-delete", onClick: function (e) { e.stopPropagation(), T({ url: "".concat("", "/remove_track_from_playlist"), body: { playlist_id: o, track_id: i.id } }) } }) : null] })] }), (0, Ct.jsx)("h3", { className: "track-id", children: r }), (0, Ct.jsx)("h3", { className: "track-name", children: i.name }), (0, Ct.jsx)("h3", { className: "track-artist", children: (null === a || void 0 === a ? void 0 : a.artist_name) || (null === i || void 0 === i ? void 0 : i.artist_name) }), (0, Ct.jsx)("h3", { className: "track-duration", children: function (e) { let t = Math.floor(e / 60), n = Math.round(e - 60 * t); return n < 10 && (n = "0" + n), "".concat(t, ":").concat(n) }(i.duration) })] }, i.id - s[0].id)] }) } function jn() { const { setSources: e, setVisible: n, setIsPlaying: i, setSourceIndex: r } = Cm(), { lib: s, id: a } = Q(), [o, l] = (0, t.useState)({ tracks: "".concat("", "/get_album_tracks/").concat(a), album: "".concat("", "/get_album/").concat(a) }), [c, u] = (0, t.useState)((0, Ct.jsx)(Nt, {})), { data: d } = je(o.tracks), { data: h } = je(o.album); return console.log(h), (0, t.useEffect)((() => { l({ tracks: "".concat("", "/get_album_tracks/").concat(a), album: "".concat("", "/get_album/").concat(a) }) }), [a]), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(tn, { setUrl: l, setNotFound: u, keys: ["tracks", "album"] }), (0, Ct.jsx)(kn, {}), !h && c, (0, Ct.jsxs)("div", { className: "album-div", children: [(0, Ct.jsxs)("div", { className: "album-data", children: [(0, Ct.jsx)("div", { className: "album-cover", children: (0, Ct.jsx)("img", { src: "".concat("", "/album_cover/").concat(null === h || void 0 === h ? void 0 : h.id), alt: "album cover" }) }), (0, Ct.jsxs)("div", { className: "album-infos", children: [(0, Ct.jsx)("h1", { children: null === h || void 0 === h ? void 0 : h.name }), (0, Ct.jsx)("h2", { children: (0, Ct.jsx)(Se, { to: "/artist/".concat(s, "/").concat(null === h || void 0 === h ? void 0 : h.artist_id), className: "link", children: null === h || void 0 === h ? void 0 : h.artist_name }) }), (0, Ct.jsxs)("h2", { children: [null === h || void 0 === h ? void 0 : h.tracks.split(",").length, " titre", (null === h || void 0 === h ? void 0 : h.tracks.split(",").length) > 1 ? "s" : ""] }), (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(ut, {}), text: "Lire", type: "album-play small", onClick: () => { e(d), r(0), n(!0), i(!0) } })] })] }), (0, Ct.jsx)("div", { className: "album-tracks", children: d && d.map(((e, t) => (0, Ct.jsx)(Nn, { track: e, index: t + 1, tracks: d, album: h }))) })] })] }) } function Dn() { const { setSources: e, setVisible: n, setIsPlaying: i, setSourceIndex: r } = Cm(), { id: s } = Q(), [a, o] = (0, t.useState)({ tracks: "".concat("", "/get_playlist_tracks/").concat(s), playlist: "".concat("", "/get_playlist/").concat(s) }), [l, c] = (0, t.useState)((0, Ct.jsx)(Nt, {})), [u, d] = (0, t.useState)(null), [h, p] = (0, t.useState)(!1), { data: f } = je(a.tracks), { data: m } = je(a.playlist); function g(e) { d(e), p(!0) } return (0, t.useEffect)((() => { o({ tracks: "".concat("", "/get_playlist_tracks/").concat(s), playlist: "".concat("", "/get_playlist/").concat(s) }) }), [s]), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(tn, { setUrl: o, setNotFound: c, keys: ["tracks", "playlist"] }), (0, Ct.jsx)(kn, {}), h && (0, Ct.jsx)(An, { trackId: u, hidePlaylistPopup: function (e) { p(!1) } }), (0, Ct.jsxs)("div", { className: "playlist-div", children: [(0, Ct.jsxs)("div", { className: "playlist-data", children: [(0, Ct.jsx)("div", { className: "playlist-cover", children: (0, Ct.jsx)("img", { src: "".concat("", "/playlist_cover/").concat(null === m || void 0 === m ? void 0 : m.id), alt: "playlist cover" }) }), (0, Ct.jsxs)("div", { className: "playlist-infos", children: [(0, Ct.jsx)("h1", { children: null === m || void 0 === m ? void 0 : m.name }), (0, Ct.jsx)("h2", { children: null === m || void 0 === m ? void 0 : m.artist_name }), (0, Ct.jsxs)("h2", { children: [null === m || void 0 === m ? void 0 : m.tracks.split(",").length, " titre", (null === m || void 0 === m ? void 0 : m.tracks.split(",").length) > 1 ? "s" : ""] }), (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(ut, {}), text: "Lire", type: "playlist-play", onClick: () => { e(f), r(0), n(!0), i(!0) } })] })] }), (0, Ct.jsx)("div", { className: "playlist-tracks", children: f ? f.map(((e, t) => (0, Ct.jsx)(Nn, { track: e, index: t + 1, tracks: f, showPlaylistPopup: g, playlist: s }))) : l })] })] }) } function Mn() { const { setSources: e, setVisible: n, setIsPlaying: i, setSourceIndex: r } = Cm(), { lib: s, id: a } = Q(), [o, l] = (0, t.useState)({ tracks: "".concat("", "/get_artist_tracks/").concat(a), albums: "".concat("", "/get_artist_albums/").concat(a), artist: "".concat("", "/get_artist/").concat(a) }), [c, u] = (0, t.useState)((0, Ct.jsx)(Nt, {})), { data: d } = je(o.tracks), { data: h } = je(o.albums), { data: p } = je(o.artist); return (0, t.useEffect)((() => { l({ tracks: "".concat("", "/get_artist_tracks/").concat(a), albums: "".concat("", "/get_artist_albums/").concat(a), artist: "".concat("", "/get_artist/").concat(a) }) }), [a]), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(tn, { setUrl: l, setNotFound: u, keys: ["tracks", "artist"] }), (0, Ct.jsx)(kn, {}), !d && !p && c, (0, Ct.jsxs)("div", { className: "artist-div", children: [(0, Ct.jsxs)("div", { className: "artist-data", children: [(0, Ct.jsx)("div", { className: "artist-cover", children: (0, Ct.jsx)("img", { src: "".concat("", "/artist_image/").concat(a), alt: "artist cover" }) }), (0, Ct.jsxs)("div", { className: "artist-infos", children: [(0, Ct.jsx)("h1", { children: null === p || void 0 === p ? void 0 : p.name }), (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(gt, {}), text: "Al\xe9atoire", type: "artist-play", onClick: function () { let t = [...d].sort((() => Math.random() - .5)); console.log(t), e(t), r(0), n(!0), i(!0) } })] })] }), h && h.length > 0 && (0, Ct.jsx)(mn, { albums: h, lib: s }), (0, Ct.jsx)("div", { className: "artist-tracks", children: d && d.map(((e, t) => (0, Ct.jsx)(Nn, { track: e, index: t + 1, tracks: d }))) })] })] }) } var Rn = n(9851), Un = n.n(Rn), Bn = n(7203), Fn = n.n(Bn), zn = n(7943), Hn = n.n(zn), Vn = n(4947), Wn = n.n(Vn), qn = n(6656), Gn = n.n(qn), Xn = n(566), Kn = n.n(Xn), $n = n(4556), Yn = n.n($n), Qn = "http://example.com"; const Jn = function (e, t) { if (/^[a-z]+:/i.test(t)) return t; /^data:/.test(e) && (e = Un().location && Un().location.href || ""); var n = "function" === typeof Un().URL, i = /^\/\//.test(e), r = !Un().location && !/\/\//i.test(e); if (n ? e = new (Un().URL)(e, Un().location || Qn) : /\/\//i.test(e) || (e = Yn().buildAbsoluteURL(Un().location && Un().location.href || "", e)), n) { var s = new URL(t, e); return r ? s.href.slice(18) : i ? s.href.slice(s.protocol.length) : s.href } return Yn().buildAbsoluteURL(e, t) }; function Zn() { return Zn = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, Zn.apply(this, arguments) } var ei = function () { function e() { this.listeners = {} } var t = e.prototype; return t.on = function (e, t) { this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t) }, t.off = function (e, t) { if (!this.listeners[e]) return !1; var n = this.listeners[e].indexOf(t); return this.listeners[e] = this.listeners[e].slice(0), this.listeners[e].splice(n, 1), n > -1 }, t.trigger = function (e) { var t = this.listeners[e]; if (t) if (2 === arguments.length) for (var n = t.length, i = 0; i < n; ++i)t[i].call(this, arguments[1]); else for (var r = Array.prototype.slice.call(arguments, 1), s = t.length, a = 0; a < s; ++a)t[a].apply(this, r) }, t.dispose = function () { this.listeners = {} }, t.pipe = function (e) { this.on("data", (function (t) { e.push(t) })) }, e }(); function ti(e) { for (var t, n = (t = e, Un().atob ? Un().atob(t) : Buffer.from(t, "base64").toString("binary")), i = new Uint8Array(n.length), r = 0; r < n.length; r++)i[r] = n.charCodeAt(r); return i } class ni extends ei { constructor() { super(), this.buffer = "" } push(e) { let t; for (this.buffer += e, t = this.buffer.indexOf("\n"); t > -1; t = this.buffer.indexOf("\n"))this.trigger("data", this.buffer.substring(0, t)), this.buffer = this.buffer.substring(t + 1) } } const ii = String.fromCharCode(9), ri = function (e) { const t = /([0-9.]*)?@?([0-9.]*)?/.exec(e || ""), n = {}; return t[1] && (n.length = parseInt(t[1], 10)), t[2] && (n.offset = parseInt(t[2], 10)), n }, si = function (e) { const t = {}; if (!e) return t; const n = e.split(new RegExp('(?:^|,)((?:[^=]*)=(?:"[^"]*"|[^,]*))')); let i, r = n.length; for (; r--;)"" !== n[r] && (i = /([^=]*)=(.*)/.exec(n[r]).slice(1), i[0] = i[0].replace(/^\s+|\s+$/g, ""), i[1] = i[1].replace(/^\s+|\s+$/g, ""), i[1] = i[1].replace(/^['"](.*)['"]$/g, "$1"), t[i[0]] = i[1]); return t }; class ai extends ei { constructor() { super(), this.customParsers = [], this.tagMappers = [] } push(e) { let t, n; if (0 === (e = e.trim()).length) return; if ("#" !== e[0]) return void this.trigger("data", { type: "uri", uri: e }); this.tagMappers.reduce(((t, n) => { const i = n(e); return i === e ? t : t.concat([i]) }), [e]).forEach((e => { for (let t = 0; t < this.customParsers.length; t++)if (this.customParsers[t].call(this, e)) return; if (0 === e.indexOf("#EXT")) if (e = e.replace("\r", ""), t = /^#EXTM3U/.exec(e), t) this.trigger("data", { type: "tag", tagType: "m3u" }); else { if (t = /^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(e), t) return n = { type: "tag", tagType: "inf" }, t[1] && (n.duration = parseFloat(t[1])), t[2] && (n.title = t[2]), void this.trigger("data", n); if (t = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(e), t) return n = { type: "tag", tagType: "targetduration" }, t[1] && (n.duration = parseInt(t[1], 10)), void this.trigger("data", n); if (t = /^#EXT-X-VERSION:([0-9.]*)?/.exec(e), t) return n = { type: "tag", tagType: "version" }, t[1] && (n.version = parseInt(t[1], 10)), void this.trigger("data", n); if (t = /^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(e), t) return n = { type: "tag", tagType: "media-sequence" }, t[1] && (n.number = parseInt(t[1], 10)), void this.trigger("data", n); if (t = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(e), t) return n = { type: "tag", tagType: "discontinuity-sequence" }, t[1] && (n.number = parseInt(t[1], 10)), void this.trigger("data", n); if (t = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(e), t) return n = { type: "tag", tagType: "playlist-type" }, t[1] && (n.playlistType = t[1]), void this.trigger("data", n); if (t = /^#EXT-X-BYTERANGE:(.*)?$/.exec(e), t) return n = Zn(ri(t[1]), { type: "tag", tagType: "byterange" }), void this.trigger("data", n); if (t = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(e), t) return n = { type: "tag", tagType: "allow-cache" }, t[1] && (n.allowed = !/NO/.test(t[1])), void this.trigger("data", n); if (t = /^#EXT-X-MAP:(.*)$/.exec(e), t) { if (n = { type: "tag", tagType: "map" }, t[1]) { const e = si(t[1]); e.URI && (n.uri = e.URI), e.BYTERANGE && (n.byterange = ri(e.BYTERANGE)) } this.trigger("data", n) } else if (t = /^#EXT-X-STREAM-INF:(.*)$/.exec(e), t) { if (n = { type: "tag", tagType: "stream-inf" }, t[1]) { if (n.attributes = si(t[1]), n.attributes.RESOLUTION) { const e = n.attributes.RESOLUTION.split("x"), t = {}; e[0] && (t.width = parseInt(e[0], 10)), e[1] && (t.height = parseInt(e[1], 10)), n.attributes.RESOLUTION = t } n.attributes.BANDWIDTH && (n.attributes.BANDWIDTH = parseInt(n.attributes.BANDWIDTH, 10)), n.attributes["FRAME-RATE"] && (n.attributes["FRAME-RATE"] = parseFloat(n.attributes["FRAME-RATE"])), n.attributes["PROGRAM-ID"] && (n.attributes["PROGRAM-ID"] = parseInt(n.attributes["PROGRAM-ID"], 10)) } this.trigger("data", n) } else { if (t = /^#EXT-X-MEDIA:(.*)$/.exec(e), t) return n = { type: "tag", tagType: "media" }, t[1] && (n.attributes = si(t[1])), void this.trigger("data", n); if (t = /^#EXT-X-ENDLIST/.exec(e), t) this.trigger("data", { type: "tag", tagType: "endlist" }); else if (t = /^#EXT-X-DISCONTINUITY/.exec(e), t) this.trigger("data", { type: "tag", tagType: "discontinuity" }); else { if (t = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(e), t) return n = { type: "tag", tagType: "program-date-time" }, t[1] && (n.dateTimeString = t[1], n.dateTimeObject = new Date(t[1])), void this.trigger("data", n); if (t = /^#EXT-X-KEY:(.*)$/.exec(e), t) return n = { type: "tag", tagType: "key" }, t[1] && (n.attributes = si(t[1]), n.attributes.IV && ("0x" === n.attributes.IV.substring(0, 2).toLowerCase() && (n.attributes.IV = n.attributes.IV.substring(2)), n.attributes.IV = n.attributes.IV.match(/.{8}/g), n.attributes.IV[0] = parseInt(n.attributes.IV[0], 16), n.attributes.IV[1] = parseInt(n.attributes.IV[1], 16), n.attributes.IV[2] = parseInt(n.attributes.IV[2], 16), n.attributes.IV[3] = parseInt(n.attributes.IV[3], 16), n.attributes.IV = new Uint32Array(n.attributes.IV))), void this.trigger("data", n); if (t = /^#EXT-X-START:(.*)$/.exec(e), t) return n = { type: "tag", tagType: "start" }, t[1] && (n.attributes = si(t[1]), n.attributes["TIME-OFFSET"] = parseFloat(n.attributes["TIME-OFFSET"]), n.attributes.PRECISE = /YES/.test(n.attributes.PRECISE)), void this.trigger("data", n); if (t = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(e), t) return n = { type: "tag", tagType: "cue-out-cont" }, t[1] ? n.data = t[1] : n.data = "", void this.trigger("data", n); if (t = /^#EXT-X-CUE-OUT:(.*)?$/.exec(e), t) return n = { type: "tag", tagType: "cue-out" }, t[1] ? n.data = t[1] : n.data = "", void this.trigger("data", n); if (t = /^#EXT-X-CUE-IN:(.*)?$/.exec(e), t) return n = { type: "tag", tagType: "cue-in" }, t[1] ? n.data = t[1] : n.data = "", void this.trigger("data", n); if (t = /^#EXT-X-SKIP:(.*)$/.exec(e), t && t[1]) return n = { type: "tag", tagType: "skip" }, n.attributes = si(t[1]), n.attributes.hasOwnProperty("SKIPPED-SEGMENTS") && (n.attributes["SKIPPED-SEGMENTS"] = parseInt(n.attributes["SKIPPED-SEGMENTS"], 10)), n.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES") && (n.attributes["RECENTLY-REMOVED-DATERANGES"] = n.attributes["RECENTLY-REMOVED-DATERANGES"].split(ii)), void this.trigger("data", n); if (t = /^#EXT-X-PART:(.*)$/.exec(e), t && t[1]) return n = { type: "tag", tagType: "part" }, n.attributes = si(t[1]), ["DURATION"].forEach((function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = parseFloat(n.attributes[e])) })), ["INDEPENDENT", "GAP"].forEach((function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = /YES/.test(n.attributes[e])) })), n.attributes.hasOwnProperty("BYTERANGE") && (n.attributes.byterange = ri(n.attributes.BYTERANGE)), void this.trigger("data", n); if (t = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(e), t && t[1]) return n = { type: "tag", tagType: "server-control" }, n.attributes = si(t[1]), ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach((function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = parseFloat(n.attributes[e])) })), ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach((function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = /YES/.test(n.attributes[e])) })), void this.trigger("data", n); if (t = /^#EXT-X-PART-INF:(.*)$/.exec(e), t && t[1]) return n = { type: "tag", tagType: "part-inf" }, n.attributes = si(t[1]), ["PART-TARGET"].forEach((function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = parseFloat(n.attributes[e])) })), void this.trigger("data", n); if (t = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(e), t && t[1]) return n = { type: "tag", tagType: "preload-hint" }, n.attributes = si(t[1]), ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach((function (e) { if (n.attributes.hasOwnProperty(e)) { n.attributes[e] = parseInt(n.attributes[e], 10); const t = "BYTERANGE-LENGTH" === e ? "length" : "offset"; n.attributes.byterange = n.attributes.byterange || {}, n.attributes.byterange[t] = n.attributes[e], delete n.attributes[e] } })), void this.trigger("data", n); if (t = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(e), t && t[1]) return n = { type: "tag", tagType: "rendition-report" }, n.attributes = si(t[1]), ["LAST-MSN", "LAST-PART"].forEach((function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = parseInt(n.attributes[e], 10)) })), void this.trigger("data", n); if (t = /^#EXT-X-DATERANGE:(.*)$/.exec(e), t && t[1]) { n = { type: "tag", tagType: "daterange" }, n.attributes = si(t[1]), ["ID", "CLASS"].forEach((function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = String(n.attributes[e])) })), ["START-DATE", "END-DATE"].forEach((function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = new Date(n.attributes[e])) })), ["DURATION", "PLANNED-DURATION"].forEach((function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = parseFloat(n.attributes[e])) })), ["END-ON-NEXT"].forEach((function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = /YES/i.test(n.attributes[e])) })), ["SCTE35-CMD", " SCTE35-OUT", "SCTE35-IN"].forEach((function (e) { n.attributes.hasOwnProperty(e) && (n.attributes[e] = n.attributes[e].toString(16)) })); const e = /^X-([A-Z]+-)+[A-Z]+$/; for (const t in n.attributes) { if (!e.test(t)) continue; const i = /[0-9A-Fa-f]{6}/g.test(n.attributes[t]), r = /^\d+(\.\d+)?$/.test(n.attributes[t]); n.attributes[t] = i ? n.attributes[t].toString(16) : r ? parseFloat(n.attributes[t]) : String(n.attributes[t]) } this.trigger("data", n) } else this.trigger("data", { type: "tag", data: e.slice(4) }) } } } else this.trigger("data", { type: "comment", text: e.slice(1) }) })) } addParser(e) { let { expression: t, customType: n, dataParser: i, segment: r } = e; "function" !== typeof i && (i = e => e), this.customParsers.push((e => { if (t.exec(e)) return this.trigger("data", { type: "custom", data: i(e), customType: n, segment: r }), !0 })) } addTagMapper(e) { let { expression: t, map: n } = e; this.tagMappers.push((e => t.test(e) ? n(e) : e)) } } const oi = function (e) { const t = {}; return Object.keys(e).forEach((function (n) { var i; t[(i = n, i.toLowerCase().replace(/-(\w)/g, (e => e[1].toUpperCase())))] = e[n] })), t }, li = function (e) { const { serverControl: t, targetDuration: n, partTargetDuration: i } = e; if (!t) return; const r = "#EXT-X-SERVER-CONTROL", s = "holdBack", a = "partHoldBack", o = n && 3 * n, l = i && 2 * i; n && !t.hasOwnProperty(s) && (t[s] = o, this.trigger("info", { message: "".concat(r, " defaulting HOLD-BACK to targetDuration * 3 (").concat(o, ").") })), o && t[s] < o && (this.trigger("warn", { message: "".concat(r, " clamping HOLD-BACK (").concat(t[s], ") to targetDuration * 3 (").concat(o, ")") }), t[s] = o), i && !t.hasOwnProperty(a) && (t[a] = 3 * i, this.trigger("info", { message: "".concat(r, " defaulting PART-HOLD-BACK to partTargetDuration * 3 (").concat(t[a], ").") })), i && t[a] < l && (this.trigger("warn", { message: "".concat(r, " clamping PART-HOLD-BACK (").concat(t[a], ") to partTargetDuration * 2 (").concat(l, ").") }), t[a] = l) }; class ci extends ei { constructor() { super(), this.lineStream = new ni, this.parseStream = new ai, this.lineStream.pipe(this.parseStream); const e = this, t = []; let n, i, r = {}, s = !1; const a = function () { }, o = { AUDIO: {}, VIDEO: {}, "CLOSED-CAPTIONS": {}, SUBTITLES: {} }; let l = 0; this.manifest = { allowCache: !0, discontinuityStarts: [], segments: [] }; let c = 0, u = 0; const d = {}; this.on("end", (() => { r.uri || !r.parts && !r.preloadHints || (!r.map && n && (r.map = n), !r.key && i && (r.key = i), r.timeline || "number" !== typeof l || (r.timeline = l), this.manifest.preloadSegment = r) })), this.parseStream.on("data", (function (h) { let p, f; ({ tag() { ({ version() { h.version && (this.manifest.version = h.version) }, "allow-cache"() { this.manifest.allowCache = h.allowed, "allowed" in h || (this.trigger("info", { message: "defaulting allowCache to YES" }), this.manifest.allowCache = !0) }, byterange() { const e = {}; "length" in h && (r.byterange = e, e.length = h.length, "offset" in h || (h.offset = c)), "offset" in h && (r.byterange = e, e.offset = h.offset), c = e.offset + e.length }, endlist() { this.manifest.endList = !0 }, inf() { "mediaSequence" in this.manifest || (this.manifest.mediaSequence = 0, this.trigger("info", { message: "defaulting media sequence to zero" })), "discontinuitySequence" in this.manifest || (this.manifest.discontinuitySequence = 0, this.trigger("info", { message: "defaulting discontinuity sequence to zero" })), h.duration > 0 && (r.duration = h.duration), 0 === h.duration && (r.duration = .01, this.trigger("info", { message: "updating zero segment duration to a small value" })), this.manifest.segments = t }, key() { if (h.attributes) if ("NONE" !== h.attributes.METHOD) if (h.attributes.URI) { if ("com.apple.streamingkeydelivery" === h.attributes.KEYFORMAT) return this.manifest.contentProtection = this.manifest.contentProtection || {}, void (this.manifest.contentProtection["com.apple.fps.1_0"] = { attributes: h.attributes }); if ("com.microsoft.playready" === h.attributes.KEYFORMAT) return this.manifest.contentProtection = this.manifest.contentProtection || {}, void (this.manifest.contentProtection["com.microsoft.playready"] = { uri: h.attributes.URI }); if ("urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed" === h.attributes.KEYFORMAT) { return -1 === ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"].indexOf(h.attributes.METHOD) ? void this.trigger("warn", { message: "invalid key method provided for Widevine" }) : ("SAMPLE-AES-CENC" === h.attributes.METHOD && this.trigger("warn", { message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead" }), "data:text/plain;base64," !== h.attributes.URI.substring(0, 23) ? void this.trigger("warn", { message: "invalid key URI provided for Widevine" }) : h.attributes.KEYID && "0x" === h.attributes.KEYID.substring(0, 2) ? (this.manifest.contentProtection = this.manifest.contentProtection || {}, void (this.manifest.contentProtection["com.widevine.alpha"] = { attributes: { schemeIdUri: h.attributes.KEYFORMAT, keyId: h.attributes.KEYID.substring(2) }, pssh: ti(h.attributes.URI.split(",")[1]) })) : void this.trigger("warn", { message: "invalid key ID provided for Widevine" })) } h.attributes.METHOD || this.trigger("warn", { message: "defaulting key method to AES-128" }), i = { method: h.attributes.METHOD || "AES-128", uri: h.attributes.URI }, "undefined" !== typeof h.attributes.IV && (i.iv = h.attributes.IV) } else this.trigger("warn", { message: "ignoring key declaration without URI" }); else i = null; else this.trigger("warn", { message: "ignoring key declaration without attribute list" }) }, "media-sequence"() { isFinite(h.number) ? this.manifest.mediaSequence = h.number : this.trigger("warn", { message: "ignoring invalid media sequence: " + h.number }) }, "discontinuity-sequence"() { isFinite(h.number) ? (this.manifest.discontinuitySequence = h.number, l = h.number) : this.trigger("warn", { message: "ignoring invalid discontinuity sequence: " + h.number }) }, "playlist-type"() { /VOD|EVENT/.test(h.playlistType) ? this.manifest.playlistType = h.playlistType : this.trigger("warn", { message: "ignoring unknown playlist type: " + h.playlist }) }, map() { n = {}, h.uri && (n.uri = h.uri), h.byterange && (n.byterange = h.byterange), i && (n.key = i) }, "stream-inf"() { this.manifest.playlists = t, this.manifest.mediaGroups = this.manifest.mediaGroups || o, h.attributes ? (r.attributes || (r.attributes = {}), Zn(r.attributes, h.attributes)) : this.trigger("warn", { message: "ignoring empty stream-inf attributes" }) }, media() { if (this.manifest.mediaGroups = this.manifest.mediaGroups || o, !(h.attributes && h.attributes.TYPE && h.attributes["GROUP-ID"] && h.attributes.NAME)) return void this.trigger("warn", { message: "ignoring incomplete or missing media group" }); const e = this.manifest.mediaGroups[h.attributes.TYPE]; e[h.attributes["GROUP-ID"]] = e[h.attributes["GROUP-ID"]] || {}, p = e[h.attributes["GROUP-ID"]], f = { default: /yes/i.test(h.attributes.DEFAULT) }, f.default ? f.autoselect = !0 : f.autoselect = /yes/i.test(h.attributes.AUTOSELECT), h.attributes.LANGUAGE && (f.language = h.attributes.LANGUAGE), h.attributes.URI && (f.uri = h.attributes.URI), h.attributes["INSTREAM-ID"] && (f.instreamId = h.attributes["INSTREAM-ID"]), h.attributes.CHARACTERISTICS && (f.characteristics = h.attributes.CHARACTERISTICS), h.attributes.FORCED && (f.forced = /yes/i.test(h.attributes.FORCED)), p[h.attributes.NAME] = f }, discontinuity() { l += 1, r.discontinuity = !0, this.manifest.discontinuityStarts.push(t.length) }, "program-date-time"() { "undefined" === typeof this.manifest.dateTimeString && (this.manifest.dateTimeString = h.dateTimeString, this.manifest.dateTimeObject = h.dateTimeObject), r.dateTimeString = h.dateTimeString, r.dateTimeObject = h.dateTimeObject }, targetduration() { !isFinite(h.duration) || h.duration < 0 ? this.trigger("warn", { message: "ignoring invalid target duration: " + h.duration }) : (this.manifest.targetDuration = h.duration, li.call(this, this.manifest)) }, start() { h.attributes && !isNaN(h.attributes["TIME-OFFSET"]) ? this.manifest.start = { timeOffset: h.attributes["TIME-OFFSET"], precise: h.attributes.PRECISE } : this.trigger("warn", { message: "ignoring start declaration without appropriate attribute list" }) }, "cue-out"() { r.cueOut = h.data }, "cue-out-cont"() { r.cueOutCont = h.data }, "cue-in"() { r.cueIn = h.data }, skip() { this.manifest.skip = oi(h.attributes), this.warnOnMissingAttributes_("#EXT-X-SKIP", h.attributes, ["SKIPPED-SEGMENTS"]) }, part() { s = !0; const e = this.manifest.segments.length, t = oi(h.attributes); r.parts = r.parts || [], r.parts.push(t), t.byterange && (t.byterange.hasOwnProperty("offset") || (t.byterange.offset = u), u = t.byterange.offset + t.byterange.length); const n = r.parts.length - 1; this.warnOnMissingAttributes_("#EXT-X-PART #".concat(n, " for segment #").concat(e), h.attributes, ["URI", "DURATION"]), this.manifest.renditionReports && this.manifest.renditionReports.forEach(((e, t) => { e.hasOwnProperty("lastPart") || this.trigger("warn", { message: "#EXT-X-RENDITION-REPORT #".concat(t, " lacks required attribute(s): LAST-PART") }) })) }, "server-control"() { const e = this.manifest.serverControl = oi(h.attributes); e.hasOwnProperty("canBlockReload") || (e.canBlockReload = !1, this.trigger("info", { message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false" })), li.call(this, this.manifest), e.canSkipDateranges && !e.hasOwnProperty("canSkipUntil") && this.trigger("warn", { message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set" }) }, "preload-hint"() { const e = this.manifest.segments.length, t = oi(h.attributes), n = t.type && "PART" === t.type; r.preloadHints = r.preloadHints || [], r.preloadHints.push(t), t.byterange && (t.byterange.hasOwnProperty("offset") || (t.byterange.offset = n ? u : 0, n && (u = t.byterange.offset + t.byterange.length))); const i = r.preloadHints.length - 1; if (this.warnOnMissingAttributes_("#EXT-X-PRELOAD-HINT #".concat(i, " for segment #").concat(e), h.attributes, ["TYPE", "URI"]), t.type) for (let s = 0; s < r.preloadHints.length - 1; s++) { const n = r.preloadHints[s]; n.type && (n.type === t.type && this.trigger("warn", { message: "#EXT-X-PRELOAD-HINT #".concat(i, " for segment #").concat(e, " has the same TYPE ").concat(t.type, " as preload hint #").concat(s) })) } }, "rendition-report"() { const e = oi(h.attributes); this.manifest.renditionReports = this.manifest.renditionReports || [], this.manifest.renditionReports.push(e); const t = this.manifest.renditionReports.length - 1, n = ["LAST-MSN", "URI"]; s && n.push("LAST-PART"), this.warnOnMissingAttributes_("#EXT-X-RENDITION-REPORT #".concat(t), h.attributes, n) }, "part-inf"() { this.manifest.partInf = oi(h.attributes), this.warnOnMissingAttributes_("#EXT-X-PART-INF", h.attributes, ["PART-TARGET"]), this.manifest.partInf.partTarget && (this.manifest.partTargetDuration = this.manifest.partInf.partTarget), li.call(this, this.manifest) }, daterange() { this.manifest.daterange = this.manifest.daterange || [], this.manifest.daterange.push(oi(h.attributes)); const e = this.manifest.daterange.length - 1; this.warnOnMissingAttributes_("#EXT-X-DATERANGE #".concat(e), h.attributes, ["ID", "START-DATE"]); const t = this.manifest.daterange[e]; t.endDate && t.startDate && new Date(t.endDate) < new Date(t.startDate) && this.trigger("warn", { message: "EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE" }), t.duration && t.duration < 0 && this.trigger("warn", { message: "EXT-X-DATERANGE DURATION must not be negative" }), t.plannedDuration && t.plannedDuration < 0 && this.trigger("warn", { message: "EXT-X-DATERANGE PLANNED-DURATION must not be negative" }); const n = !!t.endOnNext; if (n && !t.class && this.trigger("warn", { message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute" }), n && (t.duration || t.endDate) && this.trigger("warn", { message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes" }), t.duration && t.endDate) { const n = t.startDate, i = n.setSeconds(n.getSeconds() + t.duration); this.manifest.daterange[e].endDate = new Date(i) } if (t && !this.manifest.dateTimeString && this.trigger("warn", { message: "A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag" }), d[t.id]) { for (const i in d[t.id]) if (d[t.id][i] !== t[i]) { this.trigger("warn", { message: "EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes and same attribute values" }); break } } else d[t.id] = t } }[h.tagType] || a).call(e) }, uri() { r.uri = h.uri, t.push(r), this.manifest.targetDuration && !("duration" in r) && (this.trigger("warn", { message: "defaulting segment duration to the target duration" }), r.duration = this.manifest.targetDuration), i && (r.key = i), r.timeline = l, n && (r.map = n), u = 0, r = {} }, comment() { }, custom() { h.segment ? (r.custom = r.custom || {}, r.custom[h.customType] = h.data) : (this.manifest.custom = this.manifest.custom || {}, this.manifest.custom[h.customType] = h.data) } })[h.type].call(e) })) } warnOnMissingAttributes_(e, t, n) { const i = []; n.forEach((function (e) { t.hasOwnProperty(e) || i.push(e) })), i.length && this.trigger("warn", { message: "".concat(e, " lacks required attribute(s): ").concat(i.join(", ")) }) } push(e) { this.lineStream.push(e) } end() { this.lineStream.push("\n"), this.trigger("end") } addParser(e) { this.parseStream.addParser(e) } addTagMapper(e) { this.parseStream.addTagMapper(e) } } var ui = { mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/, webm: /^(vp0?[89]|av0?1|opus|vorbis)/, ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/, video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/, audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/, text: /^(stpp.ttml.im1t)/, muxerVideo: /^(avc0?1)/, muxerAudio: /^(mp4a)/, muxerText: /a^/ }, di = ["video", "audio", "text"], hi = ["Video", "Audio", "Text"], pi = function (e) { return e ? e.replace(/avc1\.(\d+)\.(\d+)/i, (function (e, t, n) { return "avc1." + ("00" + Number(t).toString(16)).slice(-2) + "00" + ("00" + Number(n).toString(16)).slice(-2) })) : e }, fi = function (e) { void 0 === e && (e = ""); var t = e.split(","), n = []; return t.forEach((function (e) { var t; e = e.trim(), di.forEach((function (i) { var r = ui[i].exec(e.toLowerCase()); if (r && !(r.length <= 1)) { t = i; var s = e.substring(0, r[1].length), a = e.replace(s, ""); n.push({ type: s, details: a, mediaType: i }) } })), t || n.push({ type: e, details: "", mediaType: "unknown" }) })), n }, mi = function (e) { return void 0 === e && (e = ""), ui.audio.test(e.trim().toLowerCase()) }, gi = function (e) { if (e && "string" === typeof e) { var t, n = e.toLowerCase().split(",").map((function (e) { return pi(e.trim()) })), i = "video"; 1 === n.length && mi(n[0]) ? i = "audio" : 1 === n.length && (void 0 === (t = n[0]) && (t = ""), ui.text.test(t.trim().toLowerCase())) && (i = "application"); var r = "mp4"; return n.every((function (e) { return ui.mp4.test(e) })) ? r = "mp4" : n.every((function (e) { return ui.webm.test(e) })) ? r = "webm" : n.every((function (e) { return ui.ogg.test(e) })) && (r = "ogg"), i + "/" + r + ';codecs="' + e + '"' } }, yi = function (e) { return void 0 === e && (e = ""), Un().MediaSource && Un().MediaSource.isTypeSupported && Un().MediaSource.isTypeSupported(gi(e)) || !1 }, vi = function (e) { return void 0 === e && (e = ""), e.toLowerCase().split(",").every((function (e) { e = e.trim(); for (var t = 0; t < hi.length; t++) { if (ui["muxer" + hi[t]].test(e)) return !0 } return !1 })) }, bi = "mp4a.40.2", _i = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i, Ti = /^application\/dash\+xml/i, Si = function (e) { return _i.test(e) ? "hls" : Ti.test(e) ? "dash" : "application/vnd.videojs.vhs+json" === e ? "vhs-json" : null }, wi = function (e) { return "function" === ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer }, xi = function (e) { return e instanceof Uint8Array ? e : (Array.isArray(e) || wi(e) || e instanceof ArrayBuffer || (e = "number" !== typeof e || "number" === typeof e && e !== e ? 0 : [e]), new Uint8Array(e && e.buffer || e, e && e.byteOffset || 0, e && e.byteLength || 0)) }, ki = Un().BigInt || Number, Ei = [ki("0x1"), ki("0x100"), ki("0x10000"), ki("0x1000000"), ki("0x100000000"), ki("0x10000000000"), ki("0x1000000000000"), ki("0x100000000000000"), ki("0x10000000000000000")], Ci = (function () { var e = new Uint16Array([65484]), t = new Uint8Array(e.buffer, e.byteOffset, e.byteLength); 255 === t[0] || t[0] }(), function (e, t) { var n = void 0 === t ? {} : t, i = n.signed, r = void 0 !== i && i, s = n.le, a = void 0 !== s && s; e = xi(e); var o = a ? "reduce" : "reduceRight", l = (e[o] ? e[o] : Array.prototype[o]).call(e, (function (t, n, i) { var r = a ? i : Math.abs(i + 1 - e.length); return t + ki(n) * Ei[r] }), ki(0)); if (r) { var c = Ei[e.length] / ki(2) - ki(1); (l = ki(l)) > c && (l -= c, l -= c, l -= ki(2)) } return Number(l) }), Pi = function (e, t) { var n = (void 0 === t ? {} : t).le, i = void 0 !== n && n; ("bigint" !== typeof e && "number" !== typeof e || "number" === typeof e && e !== e) && (e = 0), e = ki(e); for (var r, s = (r = e, Math.ceil(function (e) { return e.toString(2).length }(r) / 8)), a = new Uint8Array(new ArrayBuffer(s)), o = 0; o < s; o++) { var l = i ? o : Math.abs(o + 1 - a.length); a[l] = Number(e / Ei[o] & ki(255)), e < 0 && (a[l] = Math.abs(~a[l]), a[l] -= 0 === o ? 1 : 2) } return a }, Ii = function (e, t) { if ("string" !== typeof e && e && "function" === typeof e.toString && (e = e.toString()), "string" !== typeof e) return new Uint8Array; t || (e = unescape(encodeURIComponent(e))); for (var n = new Uint8Array(e.length), i = 0; i < e.length; i++)n[i] = e.charCodeAt(i); return n }, Li = function (e, t, n) { var i = void 0 === n ? {} : n, r = i.offset, s = void 0 === r ? 0 : r, a = i.mask, o = void 0 === a ? [] : a; e = xi(e); var l = (t = xi(t)).every ? t.every : Array.prototype.every; return t.length && e.length - s >= t.length && l.call(t, (function (t, n) { return t === (o[n] ? o[n] & e[s + n] : e[s + n]) })) }, Oi = "http://example.com"; const Ai = function (e, t) { if (/^[a-z]+:/i.test(t)) return t; /^data:/.test(e) && (e = Un().location && Un().location.href || ""); var n = "function" === typeof Un().URL, i = /^\/\//.test(e), r = !Un().location && !/\/\//i.test(e); if (n ? e = new (Un().URL)(e, Un().location || Oi) : /\/\//i.test(e) || (e = Yn().buildAbsoluteURL(Un().location && Un().location.href || "", e)), n) { var s = new URL(t, e); return r ? s.href.slice(18) : i ? s.href.slice(s.protocol.length) : s.href } return Yn().buildAbsoluteURL(e, t) }; function Ni(e) { for (var t, n = (t = e, Un().atob ? Un().atob(t) : Buffer.from(t, "base64").toString("binary")), i = new Uint8Array(n.length), r = 0; r < n.length; r++)i[r] = n.charCodeAt(r); return i } var ji = n(7542); const Di = e => !!e && "object" === typeof e, Mi = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return t.reduce(((e, t) => ("object" !== typeof t || Object.keys(t).forEach((n => { Array.isArray(e[n]) && Array.isArray(t[n]) ? e[n] = e[n].concat(t[n]) : Di(e[n]) && Di(t[n]) ? e[n] = Mi(e[n], t[n]) : e[n] = t[n] })), e)), {}) }, Ri = e => Object.keys(e).map((t => e[t])), Ui = e => e.reduce(((e, t) => e.concat(t)), []), Bi = e => { if (!e.length) return []; const t = []; for (let n = 0; n < e.length; n++)t.push(e[n]); return t }; var Fi = "INVALID_NUMBER_OF_PERIOD", zi = "DASH_EMPTY_MANIFEST", Hi = "DASH_INVALID_XML", Vi = "NO_BASE_URL", Wi = "SEGMENT_TIME_UNSPECIFIED", qi = "UNSUPPORTED_UTC_TIMING_SCHEME"; const Gi = e => { let { baseUrl: t = "", source: n = "", range: i = "", indexRange: r = "" } = e; const s = { uri: n, resolvedUri: Ai(t || "", n) }; if (i || r) { const e = (i || r).split("-"); let t, n = Un().BigInt ? Un().BigInt(e[0]) : parseInt(e[0], 10), a = Un().BigInt ? Un().BigInt(e[1]) : parseInt(e[1], 10); n < Number.MAX_SAFE_INTEGER && "bigint" === typeof n && (n = Number(n)), a < Number.MAX_SAFE_INTEGER && "bigint" === typeof a && (a = Number(a)), t = "bigint" === typeof a || "bigint" === typeof n ? Un().BigInt(a) - Un().BigInt(n) + Un().BigInt(1) : a - n + 1, "bigint" === typeof t && t < Number.MAX_SAFE_INTEGER && (t = Number(t)), s.byterange = { length: t, offset: n } } return s }, Xi = e => (e && "number" !== typeof e && (e = parseInt(e, 10)), isNaN(e) ? null : e), Ki = { static(e) { const { duration: t, timescale: n = 1, sourceDuration: i, periodDuration: r } = e, s = Xi(e.endNumber), a = t / n; return "number" === typeof s ? { start: 0, end: s } : "number" === typeof r ? { start: 0, end: r / a } : { start: 0, end: i / a } }, dynamic(e) { const { NOW: t, clientOffset: n, availabilityStartTime: i, timescale: r = 1, duration: s, periodStart: a = 0, minimumUpdatePeriod: o = 0, timeShiftBufferDepth: l = 1 / 0 } = e, c = Xi(e.endNumber), u = (t + n) / 1e3, d = i + a, h = u + o - d, p = Math.ceil(h * r / s), f = Math.floor((u - d - l) * r / s), m = Math.floor((u - d) * r / s); return { start: Math.max(0, f), end: "number" === typeof c ? c : Math.min(p, m) } } }, $i = e => { const { type: t, duration: n, timescale: i = 1, periodDuration: r, sourceDuration: s } = e, { start: a, end: o } = Ki[t](e), l = ((e, t) => { const n = []; for (let i = e; i < t; i++)n.push(i); return n })(a, o).map((e => t => { const { duration: n, timescale: i = 1, periodStart: r, startNumber: s = 1 } = e; return { number: s + t, duration: n / i, timeline: r, time: t * n } })(e)); if ("static" === t) { const e = l.length - 1, t = "number" === typeof r ? r : s; l[e].duration = t - n / i * e } return l }, Yi = e => { const { baseUrl: t, initialization: n = {}, sourceDuration: i, indexRange: r = "", periodStart: s, presentationTime: a, number: o = 0, duration: l } = e; if (!t) throw new Error(Vi); const c = Gi({ baseUrl: t, source: n.sourceURL, range: n.range }), u = Gi({ baseUrl: t, source: t, indexRange: r }); if (u.map = c, l) { const t = $i(e); t.length && (u.duration = t[0].duration, u.timeline = t[0].timeline) } else i && (u.duration = i, u.timeline = s); return u.presentationTime = a || s, u.number = o, [u] }, Qi = (e, t, n) => { const i = e.sidx.map ? e.sidx.map : null, r = e.sidx.duration, s = e.timeline || 0, a = e.sidx.byterange, o = a.offset + a.length, l = t.timescale, c = t.references.filter((e => 1 !== e.referenceType)), u = [], d = e.endList ? "static" : "dynamic", h = e.sidx.timeline; let p, f = h, m = e.mediaSequence || 0; p = "bigint" === typeof t.firstOffset ? Un().BigInt(o) + t.firstOffset : o + t.firstOffset; for (let g = 0; g < c.length; g++) { const e = t.references[g], a = e.referencedSize, o = e.subsegmentDuration; let c; c = "bigint" === typeof p ? p + Un().BigInt(a) - Un().BigInt(1) : p + a - 1; const y = "".concat(p, "-").concat(c), v = Yi({ baseUrl: n, timescale: l, timeline: s, periodStart: h, presentationTime: f, number: m, duration: o, sourceDuration: r, indexRange: y, type: d })[0]; i && (v.map = i), u.push(v), p += "bigint" === typeof p ? Un().BigInt(a) : a, f += o / l, m++ } return e.segments = u, e }, Ji = ["AUDIO", "SUBTITLES"], Zi = e => { return (t = e, n = e => { let { timeline: t } = e; return t }, Ri(t.reduce(((e, t) => (t.forEach((t => { e[n(t)] = t })), e)), {}))).sort(((e, t) => e.timeline > t.timeline ? 1 : -1)); var t, n }, er = e => { let t = []; var n, i; return n = e, i = (e, n, i, r) => { t = t.concat(e.playlists || []) }, Ji.forEach((function (e) { for (var t in n.mediaGroups[e]) for (var r in n.mediaGroups[e][t]) { var s = n.mediaGroups[e][t][r]; i(s, e, t, r) } })), t }, tr = e => { let { playlist: t, mediaSequence: n } = e; t.mediaSequence = n, t.segments.forEach(((e, n) => { e.number = t.mediaSequence + n })) }, nr = e => { let { oldManifest: t, newManifest: n } = e; const i = t.playlists.concat(er(t)), r = n.playlists.concat(er(n)); return n.timelineStarts = Zi([t.timelineStarts, n.timelineStarts]), (e => { let { oldPlaylists: t, newPlaylists: n, timelineStarts: i } = e; n.forEach((e => { e.discontinuitySequence = i.findIndex((function (t) { let { timeline: n } = t; return n === e.timeline })); const n = ((e, t) => { for (let n = 0; n < e.length; n++)if (e[n].attributes.NAME === t) return e[n]; return null })(t, e.attributes.NAME); if (!n) return; if (e.sidx) return; const r = e.segments[0], s = n.segments.findIndex((function (e) { return Math.abs(e.presentationTime - r.presentationTime) < .016666666666666666 })); if (-1 === s) return tr({ playlist: e, mediaSequence: n.mediaSequence + n.segments.length }), e.segments[0].discontinuity = !0, e.discontinuityStarts.unshift(0), void ((!n.segments.length && e.timeline > n.timeline || n.segments.length && e.timeline > n.segments[n.segments.length - 1].timeline) && e.discontinuitySequence--); n.segments[s].discontinuity && !r.discontinuity && (r.discontinuity = !0, e.discontinuityStarts.unshift(0), e.discontinuitySequence--), tr({ playlist: e, mediaSequence: n.segments[s].number }) })) })({ oldPlaylists: i, newPlaylists: r, timelineStarts: n.timelineStarts }), n }, ir = e => e && e.uri + "-" + (e => { let t; return t = "bigint" === typeof e.offset || "bigint" === typeof e.length ? Un().BigInt(e.offset) + Un().BigInt(e.length) - Un().BigInt(1) : e.offset + e.length - 1, "".concat(e.offset, "-").concat(t) })(e.byterange), rr = e => { const t = e.reduce((function (e, t) { return e[t.attributes.baseUrl] || (e[t.attributes.baseUrl] = []), e[t.attributes.baseUrl].push(t), e }), {}); let n = []; return Object.values(t).forEach((e => { const t = Ri(e.reduce(((e, t) => { const n = t.attributes.id + (t.attributes.lang || ""); return e[n] ? (t.segments && (t.segments[0] && (t.segments[0].discontinuity = !0), e[n].segments.push(...t.segments)), t.attributes.contentProtection && (e[n].attributes.contentProtection = t.attributes.contentProtection)) : (e[n] = t, e[n].attributes.timelineStarts = []), e[n].attributes.timelineStarts.push({ start: t.attributes.periodStart, timeline: t.attributes.periodStart }), e }), {})); n = n.concat(t) })), n.map((e => { var t, n; return e.discontinuityStarts = (t = e.segments || [], n = "discontinuity", t.reduce(((e, t, i) => (t[n] && e.push(i), e)), [])), e })) }, sr = (e, t) => { const n = ir(e.sidx), i = n && t[n] && t[n].sidx; return i && Qi(e, i, e.sidx.resolvedUri), e }, ar = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!Object.keys(t).length) return e; for (const n in e) e[n] = sr(e[n], t); return e }, or = e => { let { attributes: t, segments: n, sidx: i, discontinuityStarts: r } = e; const s = { attributes: { NAME: t.id, AUDIO: "audio", SUBTITLES: "subs", RESOLUTION: { width: t.width, height: t.height }, CODECS: t.codecs, BANDWIDTH: t.bandwidth, "PROGRAM-ID": 1 }, uri: "", endList: "static" === t.type, timeline: t.periodStart, resolvedUri: t.baseUrl || "", targetDuration: t.duration, discontinuityStarts: r, timelineStarts: t.timelineStarts, segments: n }; return t.frameRate && (s.attributes["FRAME-RATE"] = t.frameRate), t.contentProtection && (s.contentProtection = t.contentProtection), t.serviceLocation && (s.attributes.serviceLocation = t.serviceLocation), i && (s.sidx = i), s }, lr = e => { let { attributes: t } = e; return "video/mp4" === t.mimeType || "video/webm" === t.mimeType || "video" === t.contentType }, cr = e => { let { attributes: t } = e; return "audio/mp4" === t.mimeType || "audio/webm" === t.mimeType || "audio" === t.contentType }, ur = e => { let { attributes: t } = e; return "text/vtt" === t.mimeType || "text" === t.contentType }, dr = e => e ? Object.keys(e).reduce(((t, n) => { const i = e[n]; return t.concat(i.playlists) }), []) : [], hr = e => { let { dashPlaylists: t, locations: n, contentSteering: i, sidxMapping: r = {}, previousManifest: s, eventStream: a } = e; if (!t.length) return {}; const { sourceDuration: o, type: l, suggestedPresentationDelay: c, minimumUpdatePeriod: u } = t[0].attributes, d = rr(t.filter(lr)).map(or), h = rr(t.filter(cr)), p = rr(t.filter(ur)), f = t.map((e => e.attributes.captionServices)).filter(Boolean), m = { allowCache: !0, discontinuityStarts: [], segments: [], endList: !0, mediaGroups: { AUDIO: {}, VIDEO: {}, "CLOSED-CAPTIONS": {}, SUBTITLES: {} }, uri: "", duration: o, playlists: ar(d, r) }; u >= 0 && (m.minimumUpdatePeriod = 1e3 * u), n && (m.locations = n), i && (m.contentSteering = i), "dynamic" === l && (m.suggestedPresentationDelay = c), a && a.length > 0 && (m.eventStream = a); const g = 0 === m.playlists.length, y = h.length ? function (e) { let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const r = e.reduce(((e, r) => { const s = r.attributes.role && r.attributes.role.value || "", a = r.attributes.lang || ""; let o = r.attributes.label || "main"; if (a && !r.attributes.label) { const e = s ? " (".concat(s, ")") : ""; o = "".concat(r.attributes.lang).concat(e) } e[o] || (e[o] = { language: a, autoselect: !0, default: "main" === s, playlists: [], uri: "" }); const l = sr(((e, t) => { let { attributes: n, segments: i, sidx: r, mediaSequence: s, discontinuitySequence: a, discontinuityStarts: o } = e; const l = { attributes: { NAME: n.id, BANDWIDTH: n.bandwidth, CODECS: n.codecs, "PROGRAM-ID": 1 }, uri: "", endList: "static" === n.type, timeline: n.periodStart, resolvedUri: n.baseUrl || "", targetDuration: n.duration, discontinuitySequence: a, discontinuityStarts: o, timelineStarts: n.timelineStarts, mediaSequence: s, segments: i }; return n.contentProtection && (l.contentProtection = n.contentProtection), n.serviceLocation && (l.attributes.serviceLocation = n.serviceLocation), r && (l.sidx = r), t && (l.attributes.AUDIO = "audio", l.attributes.SUBTITLES = "subs"), l })(r, i), n); return e[o].playlists.push(l), "undefined" === typeof t && "main" === s && (t = r, t.default = !0), e }), {}); t || (r[Object.keys(r)[0]].default = !0); return r }(h, r, g) : null, v = p.length ? function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return e.reduce(((e, n) => { const i = n.attributes.label || n.attributes.lang || "text"; return e[i] || (e[i] = { language: i, default: !1, autoselect: !1, playlists: [], uri: "" }), e[i].playlists.push(sr((e => { let { attributes: t, segments: n, mediaSequence: i, discontinuityStarts: r, discontinuitySequence: s } = e; "undefined" === typeof n && (n = [{ uri: t.baseUrl, timeline: t.periodStart, resolvedUri: t.baseUrl || "", duration: t.sourceDuration, number: 0 }], t.duration = t.sourceDuration); const a = { NAME: t.id, BANDWIDTH: t.bandwidth, "PROGRAM-ID": 1 }; t.codecs && (a.CODECS = t.codecs); const o = { attributes: a, uri: "", endList: "static" === t.type, timeline: t.periodStart, resolvedUri: t.baseUrl || "", targetDuration: t.duration, timelineStarts: t.timelineStarts, discontinuityStarts: r, discontinuitySequence: s, mediaSequence: i, segments: n }; return t.serviceLocation && (o.attributes.serviceLocation = t.serviceLocation), o })(n), t)), e }), {}) }(p, r) : null, b = d.concat(dr(y), dr(v)), _ = b.map((e => { let { timelineStarts: t } = e; return t })); var T, S; return m.timelineStarts = Zi(_), T = b, S = m.timelineStarts, T.forEach((e => { e.mediaSequence = 0, e.discontinuitySequence = S.findIndex((function (t) { let { timeline: n } = t; return n === e.timeline })), e.segments && e.segments.forEach(((e, t) => { e.number = t })) })), y && (m.mediaGroups.AUDIO.audio = y), v && (m.mediaGroups.SUBTITLES.subs = v), f.length && (m.mediaGroups["CLOSED-CAPTIONS"].cc = f.reduce(((e, t) => t ? (t.forEach((t => { const { channel: n, language: i } = t; e[i] = { autoselect: !1, default: !1, instreamId: n, language: i }, t.hasOwnProperty("aspectRatio") && (e[i].aspectRatio = t.aspectRatio), t.hasOwnProperty("easyReader") && (e[i].easyReader = t.easyReader), t.hasOwnProperty("3D") && (e[i]["3D"] = t["3D"]) })), e) : e), {})), s ? nr({ oldManifest: s, newManifest: m }) : m }, pr = (e, t, n) => { const { NOW: i, clientOffset: r, availabilityStartTime: s, timescale: a = 1, periodStart: o = 0, minimumUpdatePeriod: l = 0 } = e, c = (i + r) / 1e3 + l - (s + o); return Math.ceil((c * a - t) / n) }, fr = (e, t) => { const { type: n, minimumUpdatePeriod: i = 0, media: r = "", sourceDuration: s, timescale: a = 1, startNumber: o = 1, periodStart: l } = e, c = []; let u = -1; for (let d = 0; d < t.length; d++) { const h = t[d], p = h.d, f = h.r || 0, m = h.t || 0; let g; if (u < 0 && (u = m), m && m > u && (u = m), f < 0) { const o = d + 1; g = o === t.length ? "dynamic" === n && i > 0 && r.indexOf("$Number$") > 0 ? pr(e, u, p) : (s * a - u) / p : (t[o].t - u) / p } else g = f + 1; const y = o + c.length + g; let v = o + c.length; for (; v < y;)c.push({ number: v, duration: p / a, time: u, timeline: l }), u += p, v++ } return c }, mr = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g, gr = (e, t) => e.replace(mr, (e => (t, n, i, r) => { if ("$$" === t) return "$"; if ("undefined" === typeof e[n]) return t; const s = "" + e[n]; return "RepresentationID" === n ? s : (r = i ? parseInt(r, 10) : 1, s.length >= r ? s : "".concat(new Array(r - s.length + 1).join("0")).concat(s)) })(t)), yr = (e, t) => { const n = { RepresentationID: e.id, Bandwidth: e.bandwidth || 0 }, { initialization: i = { sourceURL: "", range: "" } } = e, r = Gi({ baseUrl: e.baseUrl, source: gr(i.sourceURL, n), range: i.range }), s = ((e, t) => e.duration || t ? e.duration ? $i(e) : fr(e, t) : [{ number: e.startNumber || 1, duration: e.sourceDuration, time: 0, timeline: e.periodStart }])(e, t); return s.map((t => { n.Number = t.number, n.Time = t.time; const i = gr(e.media || "", n), s = e.timescale || 1, a = e.presentationTimeOffset || 0, o = e.periodStart + (t.time - a) / s; return { uri: i, timeline: t.timeline, duration: t.duration, resolvedUri: Ai(e.baseUrl || "", i), map: r, number: t.number, presentationTime: o } })) }, vr = (e, t) => { const { duration: n, segmentUrls: i = [], periodStart: r } = e; if (!n && !t || n && t) throw new Error(Wi); const s = i.map((t => ((e, t) => { const { baseUrl: n, initialization: i = {} } = e, r = Gi({ baseUrl: n, source: i.sourceURL, range: i.range }), s = Gi({ baseUrl: n, source: t.media, range: t.mediaRange }); return s.map = r, s })(e, t))); let a; n && (a = $i(e)), t && (a = fr(e, t)); return a.map(((t, n) => { if (s[n]) { const i = s[n], a = e.timescale || 1, o = e.presentationTimeOffset || 0; return i.timeline = t.timeline, i.duration = t.duration, i.number = t.number, i.presentationTime = r + (t.time - o) / a, i } })).filter((e => e)) }, br = e => { let t, n, { attributes: i, segmentInfo: r } = e; r.template ? (n = yr, t = Mi(i, r.template)) : r.base ? (n = Yi, t = Mi(i, r.base)) : r.list && (n = vr, t = Mi(i, r.list)); const s = { attributes: i }; if (!n) return s; const a = n(t, r.segmentTimeline); if (t.duration) { const { duration: e, timescale: n = 1 } = t; t.duration = e / n } else a.length ? t.duration = a.reduce(((e, t) => Math.max(e, Math.ceil(t.duration))), 0) : t.duration = 0; return s.attributes = t, s.segments = a, r.base && t.indexRange && (s.sidx = a[0], s.segments = []), s }, _r = (e, t) => Bi(e.childNodes).filter((e => { let { tagName: n } = e; return n === t })), Tr = e => e.textContent.trim(), Sr = e => { const t = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/.exec(e); if (!t) return 0; const [n, i, r, s, a, o] = t.slice(1); return 31536e3 * parseFloat(n || 0) + 2592e3 * parseFloat(i || 0) + 86400 * parseFloat(r || 0) + 3600 * parseFloat(s || 0) + 60 * parseFloat(a || 0) + parseFloat(o || 0) }, wr = { mediaPresentationDuration: e => Sr(e), availabilityStartTime(e) { return /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/.test(t = e) && (t += "Z"), Date.parse(t) / 1e3; var t }, minimumUpdatePeriod: e => Sr(e), suggestedPresentationDelay: e => Sr(e), type: e => e, timeShiftBufferDepth: e => Sr(e), start: e => Sr(e), width: e => parseInt(e, 10), height: e => parseInt(e, 10), bandwidth: e => parseInt(e, 10), frameRate: e => (e => parseFloat(e.split("/").reduce(((e, t) => e / t))))(e), startNumber: e => parseInt(e, 10), timescale: e => parseInt(e, 10), presentationTimeOffset: e => parseInt(e, 10), duration(e) { const t = parseInt(e, 10); return isNaN(t) ? Sr(e) : t }, d: e => parseInt(e, 10), t: e => parseInt(e, 10), r: e => parseInt(e, 10), presentationTime: e => parseInt(e, 10), DEFAULT: e => e }, xr = e => e && e.attributes ? Bi(e.attributes).reduce(((e, t) => { const n = wr[t.name] || wr.DEFAULT; return e[t.name] = n(t.value), e }), {}) : {}, kr = { "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey", "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha", "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready", "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime" }, Er = (e, t) => t.length ? Ui(e.map((function (e) { return t.map((function (t) { const n = Tr(t), i = Ai(e.baseUrl, n), r = Mi(xr(t), { baseUrl: i }); return i !== n && !r.serviceLocation && e.serviceLocation && (r.serviceLocation = e.serviceLocation), r })) }))) : e, Cr = e => { const t = _r(e, "SegmentTemplate")[0], n = _r(e, "SegmentList")[0], i = n && _r(n, "SegmentURL").map((e => Mi({ tag: "SegmentURL" }, xr(e)))), r = _r(e, "SegmentBase")[0], s = n || t, a = s && _r(s, "SegmentTimeline")[0], o = n || r || t, l = o && _r(o, "Initialization")[0], c = t && xr(t); c && l ? c.initialization = l && xr(l) : c && c.initialization && (c.initialization = { sourceURL: c.initialization }); const u = { template: c, segmentTimeline: a && _r(a, "S").map((e => xr(e))), list: n && Mi(xr(n), { segmentUrls: i, initialization: xr(l) }), base: r && Mi(xr(r), { initialization: xr(l) }) }; return Object.keys(u).forEach((e => { u[e] || delete u[e] })), u }, Pr = e => Ui(_r(e.node, "EventStream").map((t => { const n = xr(t), i = n.schemeIdUri; return _r(t, "Event").map((t => { const r = xr(t), s = r.presentationTime || 0, a = n.timescale || 1, o = r.duration || 0, l = s / a + e.attributes.start; return { schemeIdUri: i, value: n.value, id: r.id, start: l, end: l + o / a, messageData: Tr(t) || r.messageData, contentEncoding: n.contentEncoding, presentationTimeOffset: n.presentationTimeOffset || 0 } })) }))), Ir = (e, t, n) => i => { const r = xr(i), s = Er(t, _r(i, "BaseURL")), a = _r(i, "Role")[0], o = { role: xr(a) }; let l = Mi(e, r, o); const c = _r(i, "Accessibility")[0], u = (e => { if ("urn:scte:dash:cc:cea-608:2015" === e.schemeIdUri) return ("string" !== typeof e.value ? [] : e.value.split(";")).map((e => { let t, n; return n = e, /^CC\d=/.test(e) ? [t, n] = e.split("=") : /^CC\d$/.test(e) && (t = e), { channel: t, language: n } })); if ("urn:scte:dash:cc:cea-708:2015" === e.schemeIdUri) return ("string" !== typeof e.value ? [] : e.value.split(";")).map((e => { const t = { channel: void 0, language: void 0, aspectRatio: 1, easyReader: 0, "3D": 0 }; if (/=/.test(e)) { const [n, i = ""] = e.split("="); t.channel = n, t.language = e, i.split(",").forEach((e => { const [n, i] = e.split(":"); "lang" === n ? t.language = i : "er" === n ? t.easyReader = Number(i) : "war" === n ? t.aspectRatio = Number(i) : "3D" === n && (t["3D"] = Number(i)) })) } else t.language = e; return t.channel && (t.channel = "SERVICE" + t.channel), t })) })(xr(c)); u && (l = Mi(l, { captionServices: u })); const d = _r(i, "Label")[0]; if (d && d.childNodes.length) { const e = d.childNodes[0].nodeValue.trim(); l = Mi(l, { label: e }) } const h = _r(i, "ContentProtection").reduce(((e, t) => { const n = xr(t); n.schemeIdUri && (n.schemeIdUri = n.schemeIdUri.toLowerCase()); const i = kr[n.schemeIdUri]; if (i) { e[i] = { attributes: n }; const r = _r(t, "cenc:pssh")[0]; if (r) { const t = Tr(r); e[i].pssh = t && Ni(t) } } return e }), {}); Object.keys(h).length && (l = Mi(l, { contentProtection: h })); const p = Cr(i), f = _r(i, "Representation"), m = Mi(n, p); return Ui(f.map(((e, t, n) => i => { const r = _r(i, "BaseURL"), s = Er(t, r), a = Mi(e, xr(i)), o = Cr(i); return s.map((e => ({ segmentInfo: Mi(n, o), attributes: Mi(a, e) }))) })(l, s, m))) }, Lr = (e, t) => (n, i) => { const r = Er(t, _r(n.node, "BaseURL")), s = Mi(e, { periodStart: n.attributes.start }); "number" === typeof n.attributes.duration && (s.periodDuration = n.attributes.duration); const a = _r(n.node, "AdaptationSet"), o = Cr(n.node); return Ui(a.map(Ir(s, r, o))) }, Or = (e, t) => { if (e.length > 1 && t({ type: "warn", message: "The MPD manifest should contain no more than one ContentSteering tag" }), !e.length) return null; const n = Mi({ serverURL: Tr(e[0]) }, xr(e[0])); return n.queryBeforeStart = "true" === n.queryBeforeStart, n }, Ar = e => { if ("" === e) throw new Error(zi); const t = new ji.DOMParser; let n, i; try { n = t.parseFromString(e, "application/xml"), i = n && "MPD" === n.documentElement.tagName ? n.documentElement : null } catch (r) { } if (!i || i && i.getElementsByTagName("parsererror").length > 0) throw new Error(Hi); return i }, Nr = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const { manifestUri: n = "", NOW: i = Date.now(), clientOffset: r = 0, eventHandler: s = function () { } } = t, a = _r(e, "Period"); if (!a.length) throw new Error(Fi); const o = _r(e, "Location"), l = xr(e), c = Er([{ baseUrl: n }], _r(e, "BaseURL")), u = _r(e, "ContentSteering"); l.type = l.type || "static", l.sourceDuration = l.mediaPresentationDuration || 0, l.NOW = i, l.clientOffset = r, o.length && (l.locations = o.map(Tr)); const d = []; return a.forEach(((e, t) => { const n = xr(e), i = d[t - 1]; n.start = (e => { let { attributes: t, priorPeriodAttributes: n, mpdType: i } = e; return "number" === typeof t.start ? t.start : n && "number" === typeof n.start && "number" === typeof n.duration ? n.start + n.duration : n || "static" !== i ? null : 0 })({ attributes: n, priorPeriodAttributes: i ? i.attributes : null, mpdType: l.type }), d.push({ node: e, attributes: n }) })), { locations: l.locations, contentSteeringInfo: Or(u, s), representationInfo: Ui(d.map(Lr(l, c))), eventStream: Ui(d.map(Pr)) } }(Ar(e), t), i = n.representationInfo.map(br); return hr({ dashPlaylists: i, locations: n.locations, contentSteering: n.contentSteeringInfo, sidxMapping: t.sidxMapping, previousManifest: t.previousManifest, eventStream: n.eventStream }) }, jr = e => (e => { const t = _r(e, "UTCTiming")[0]; if (!t) return null; const n = xr(t); switch (n.schemeIdUri) { case "urn:mpeg:dash:utc:http-head:2014": case "urn:mpeg:dash:utc:http-head:2012": n.method = "HEAD"; break; case "urn:mpeg:dash:utc:http-xsdate:2014": case "urn:mpeg:dash:utc:http-iso:2014": case "urn:mpeg:dash:utc:http-xsdate:2012": case "urn:mpeg:dash:utc:http-iso:2012": n.method = "GET"; break; case "urn:mpeg:dash:utc:direct:2014": case "urn:mpeg:dash:utc:direct:2012": n.method = "DIRECT", n.value = Date.parse(n.value); break; default: throw new Error(qi) }return n })(Ar(e)); var Dr, Mr = n(8857), Rr = n.n(Mr), Ur = xi([73, 68, 51]), Br = function e(t, n) { return void 0 === n && (n = 0), (t = xi(t)).length - n < 10 || !Li(t, Ur, { offset: n }) ? n : (n += function (e, t) { void 0 === t && (t = 0); var n = (e = xi(e))[t + 5], i = e[t + 6] << 21 | e[t + 7] << 14 | e[t + 8] << 7 | e[t + 9]; return (16 & n) >> 4 ? i + 20 : i + 10 }(t, n), e(t, n)) }, Fr = (new Uint8Array([79, 112, 117, 115, 72, 101, 97, 100]), function (e) { return "string" === typeof e ? Ii(e) : e }), zr = function (e) { e = xi(e); for (var t = [], n = 0; e.length > n;) { var i = e[n], r = 0, s = 0, a = e[++s]; for (s++; 128 & a;)r = (127 & a) << 7, a = e[s], s++; r += 127 & a; for (var o = 0; o < Dr.length; o++) { var l = Dr[o], c = l.id, u = l.parser; if (i === c) { t.push(u(e.subarray(s, s + r))); break } } n += r + s } return t }; Dr = [{ id: 3, parser: function (e) { var t = { tag: 3, id: e[0] << 8 | e[1], flags: e[2], size: 3, dependsOnEsId: 0, ocrEsId: 0, descriptors: [], url: "" }; if (128 & t.flags && (t.dependsOnEsId = e[t.size] << 8 | e[t.size + 1], t.size += 2), 64 & t.flags) { var n = e[t.size]; t.url = function (e) { if (!e) return ""; e = Array.prototype.slice.call(e); var t = String.fromCharCode.apply(null, xi(e)); try { return decodeURIComponent(escape(t)) } catch (n) { } return t }(e.subarray(t.size + 1, t.size + 1 + n)), t.size += n } return 32 & t.flags && (t.ocrEsId = e[t.size] << 8 | e[t.size + 1], t.size += 2), t.descriptors = zr(e.subarray(t.size)) || [], t } }, { id: 4, parser: function (e) { return { tag: 4, oti: e[0], streamType: e[1], bufferSize: e[2] << 16 | e[3] << 8 | e[4], maxBitrate: e[5] << 24 | e[6] << 16 | e[7] << 8 | e[8], avgBitrate: e[9] << 24 | e[10] << 16 | e[11] << 8 | e[12], descriptors: zr(e.subarray(13)) } } }, { id: 5, parser: function (e) { return { tag: 5, bytes: e } } }, { id: 6, parser: function (e) { return { tag: 6, bytes: e } } }]; var Hr = function e(t, n, i) { void 0 === i && (i = !1), n = function (e) { return Array.isArray(e) ? e.map((function (e) { return Fr(e) })) : [Fr(e)] }(n), t = xi(t); var r = []; if (!n.length) return r; for (var s = 0; s < t.length;) { var a = (t[s] << 24 | t[s + 1] << 16 | t[s + 2] << 8 | t[s + 3]) >>> 0, o = t.subarray(s + 4, s + 8); if (0 === a) break; var l = s + a; if (l > t.length) { if (i) break; l = t.length } var c = t.subarray(s + 8, l); Li(o, n[0]) && (1 === n.length ? r.push(c) : r.push.apply(r, e(c, n.slice(1), i))), s = l } return r }, Vr = { EBML: xi([26, 69, 223, 163]), DocType: xi([66, 130]), Segment: xi([24, 83, 128, 103]), SegmentInfo: xi([21, 73, 169, 102]), Tracks: xi([22, 84, 174, 107]), Track: xi([174]), TrackNumber: xi([215]), DefaultDuration: xi([35, 227, 131]), TrackEntry: xi([174]), TrackType: xi([131]), FlagDefault: xi([136]), CodecID: xi([134]), CodecPrivate: xi([99, 162]), VideoTrack: xi([224]), AudioTrack: xi([225]), Cluster: xi([31, 67, 182, 117]), Timestamp: xi([231]), TimestampScale: xi([42, 215, 177]), BlockGroup: xi([160]), BlockDuration: xi([155]), Block: xi([161]), SimpleBlock: xi([163]) }, Wr = [128, 64, 32, 16, 8, 4, 2, 1], qr = function (e, t, n, i) { void 0 === n && (n = !0), void 0 === i && (i = !1); var r = function (e) { for (var t = 1, n = 0; n < Wr.length && !(e & Wr[n]); n++)t++; return t }(e[t]), s = e.subarray(t, t + r); return n && ((s = Array.prototype.slice.call(e, t, t + r))[0] ^= Wr[r - 1]), { length: r, value: Ci(s, { signed: i }), bytes: s } }, Gr = function e(t) { return "string" === typeof t ? t.match(/.{1,2}/g).map((function (t) { return e(t) })) : "number" === typeof t ? Pi(t) : t }, Xr = function e(t, n, i) { if (i >= n.length) return n.length; var r = qr(n, i, !1); if (Li(t.bytes, r.bytes)) return i; var s = qr(n, i + r.length); return e(t, n, i + s.length + s.value + r.length) }, Kr = function e(t, n) { n = function (e) { return Array.isArray(e) ? e.map((function (e) { return Gr(e) })) : [Gr(e)] }(n), t = xi(t); var i = []; if (!n.length) return i; for (var r = 0; r < t.length;) { var s = qr(t, r, !1), a = qr(t, r + s.length), o = r + s.length + a.length; 127 === a.value && (a.value = Xr(s, t, o), a.value !== t.length && (a.value -= o)); var l = o + a.value > t.length ? t.length : o + a.value, c = t.subarray(o, l); Li(n[0], s.bytes) && (1 === n.length ? i.push(c) : i = i.concat(e(c, n.slice(1)))), r += s.length + a.length + c.length } return i }, $r = xi([0, 0, 0, 1]), Yr = xi([0, 0, 1]), Qr = xi([0, 0, 3]), Jr = function (e) { for (var t = [], n = 1; n < e.length - 2;)Li(e.subarray(n, n + 3), Qr) && (t.push(n + 2), n++), n++; if (0 === t.length) return e; var i = e.length - t.length, r = new Uint8Array(i), s = 0; for (n = 0; n < i; s++, n++)s === t[0] && (s++, t.shift()), r[n] = e[s]; return r }, Zr = function (e, t, n, i) { void 0 === i && (i = 1 / 0), e = xi(e), n = [].concat(n); for (var r, s = 0, a = 0; s < e.length && (a < i || r);) { var o = void 0; if (Li(e.subarray(s), $r) ? o = 4 : Li(e.subarray(s), Yr) && (o = 3), o) { if (a++, r) return Jr(e.subarray(r, s)); var l = void 0; "h264" === t ? l = 31 & e[s + o] : "h265" === t && (l = e[s + o] >> 1 & 63), -1 !== n.indexOf(l) && (r = s + o), s += o + ("h264" === t ? 1 : 2) } else s++ } return e.subarray(0, 0) }, es = { webm: xi([119, 101, 98, 109]), matroska: xi([109, 97, 116, 114, 111, 115, 107, 97]), flac: xi([102, 76, 97, 67]), ogg: xi([79, 103, 103, 83]), ac3: xi([11, 119]), riff: xi([82, 73, 70, 70]), avi: xi([65, 86, 73]), wav: xi([87, 65, 86, 69]), "3gp": xi([102, 116, 121, 112, 51, 103]), mp4: xi([102, 116, 121, 112]), fmp4: xi([115, 116, 121, 112]), mov: xi([102, 116, 121, 112, 113, 116]), moov: xi([109, 111, 111, 118]), moof: xi([109, 111, 111, 102]) }, ts = { aac: function (e) { var t = Br(e); return Li(e, [255, 16], { offset: t, mask: [255, 22] }) }, mp3: function (e) { var t = Br(e); return Li(e, [255, 2], { offset: t, mask: [255, 6] }) }, webm: function (e) { var t = Kr(e, [Vr.EBML, Vr.DocType])[0]; return Li(t, es.webm) }, mkv: function (e) { var t = Kr(e, [Vr.EBML, Vr.DocType])[0]; return Li(t, es.matroska) }, mp4: function (e) { return !ts["3gp"](e) && !ts.mov(e) && (!(!Li(e, es.mp4, { offset: 4 }) && !Li(e, es.fmp4, { offset: 4 })) || (!(!Li(e, es.moof, { offset: 4 }) && !Li(e, es.moov, { offset: 4 })) || void 0)) }, mov: function (e) { return Li(e, es.mov, { offset: 4 }) }, "3gp": function (e) { return Li(e, es["3gp"], { offset: 4 }) }, ac3: function (e) { var t = Br(e); return Li(e, es.ac3, { offset: t }) }, ts: function (e) { if (e.length < 189 && e.length >= 1) return 71 === e[0]; for (var t = 0; t + 188 < e.length && t < 188;) { if (71 === e[t] && 71 === e[t + 188]) return !0; t += 1 } return !1 }, flac: function (e) { var t = Br(e); return Li(e, es.flac, { offset: t }) }, ogg: function (e) { return Li(e, es.ogg) }, avi: function (e) { return Li(e, es.riff) && Li(e, es.avi, { offset: 8 }) }, wav: function (e) { return Li(e, es.riff) && Li(e, es.wav, { offset: 8 }) }, h264: function (e) { return function (e, t, n) { return Zr(e, "h264", t, n) }(e, 7, 3).length }, h265: function (e) { return function (e, t, n) { return Zr(e, "h265", t, n) }(e, [32, 33], 3).length } }, ns = Object.keys(ts).filter((function (e) { return "ts" !== e && "h264" !== e && "h265" !== e })).concat(["ts", "h264", "h265"]); ns.forEach((function (e) { var t = ts[e]; ts[e] = function (e) { return t(xi(e)) } })); var is = ts, rs = function (e) { e = xi(e); for (var t = 0; t < ns.length; t++) { var n = ns[t]; if (is[n](e)) return n } return "" }, ss = n(3474), as = "8.2.0"; const os = {}, ls = function (e, t) { return os[e] = os[e] || [], t && (os[e] = os[e].concat(t)), os[e] }, cs = function (e, t) { const n = ls(e).indexOf(t); return !(n <= -1) && (os[e] = os[e].slice(), os[e].splice(n, 1), !0) }, us = { prefixed: !0 }, ds = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror", "-moz-full-screen"], ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError", "-ms-fullscreen"]], hs = ds[0]; let ps; for (let n = 0; n < ds.length; n++)if (ds[n][1] in Fn()) { ps = ds[n]; break } if (ps) { for (let e = 0; e < ps.length; e++)us[hs[e]] = ps[e]; us.prefixed = ps[0] !== hs[0] } let fs = []; const ms = function e(t) { let n, i = "info"; const r = function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; n("log", i, t) }; return n = ((e, t) => (n, i, r) => { const s = t.levels[i], a = new RegExp("^(".concat(s, ")$")); if ("log" !== n && r.unshift(n.toUpperCase() + ":"), r.unshift(e + ":"), fs) { fs.push([].concat(r)); const e = fs.length - 1e3; fs.splice(0, e > 0 ? e : 0) } if (!Un().console) return; let o = Un().console[n]; o || "debug" !== n || (o = Un().console.info || Un().console.log), o && s && a.test(n) && o[Array.isArray(r) ? "apply" : "call"](Un().console, r) })(t, r), r.createLogger = n => e(t + ": " + n), r.levels = { all: "debug|log|warn|error", off: "", debug: "debug|log|warn|error", info: "log|warn|error", warn: "warn|error", error: "error", DEFAULT: i }, r.level = e => { if ("string" === typeof e) { if (!r.levels.hasOwnProperty(e)) throw new Error('"'.concat(e, '" in not a valid log level')); i = e } return i }, (r.history = () => fs ? [].concat(fs) : []).filter = e => (fs || []).filter((t => new RegExp(".*".concat(e, ".*")).test(t[0]))), r.history.clear = () => { fs && (fs.length = 0) }, r.history.disable = () => { null !== fs && (fs.length = 0, fs = null) }, r.history.enable = () => { null === fs && (fs = []) }, r.error = function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return n("error", i, t) }, r.warn = function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return n("warn", i, t) }, r.debug = function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return n("debug", i, t) }, r }("VIDEOJS"), gs = ms.createLogger, ys = Object.prototype.toString, vs = function (e) { return Ts(e) ? Object.keys(e) : [] }; function bs(e, t) { vs(e).forEach((n => t(e[n], n))) } function _s(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; return vs(e).reduce(((n, i) => t(n, e[i], i)), n) } function Ts(e) { return !!e && "object" === typeof e } function Ss(e) { return Ts(e) && "[object Object]" === ys.call(e) && e.constructor === Object } function ws() { const e = {}; for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; return n.forEach((t => { t && bs(t, ((t, n) => { Ss(t) ? (Ss(e[n]) || (e[n] = {}), e[n] = ws(e[n], t)) : e[n] = t })) })), e } function xs(e, t, n) { const i = n => Object.defineProperty(e, t, { value: n, enumerable: !0, writable: !0 }), r = { configurable: !0, enumerable: !0, get() { const e = n(); return i(e), e } }; return (!(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]) && (r.set = i), Object.defineProperty(e, t, r) } var ks = Object.freeze({ __proto__: null, each: bs, reduce: _s, isObject: Ts, isPlain: Ss, merge: ws, defineLazyProperty: xs }); let Es, Cs = !1, Ps = null, Is = !1, Ls = !1, Os = !1, As = !1, Ns = !1, js = null, Ds = null, Ms = null, Rs = !1, Us = !1, Bs = !1, Fs = !1; const zs = Boolean(Xs() && ("ontouchstart" in Un() || Un().navigator.maxTouchPoints || Un().DocumentTouch && Un().document instanceof Un().DocumentTouch)), Hs = Un().navigator && Un().navigator.userAgentData; if (Hs && (Is = "Android" === Hs.platform, Os = Boolean(Hs.brands.find((e => "Microsoft Edge" === e.brand))), As = Boolean(Hs.brands.find((e => "Chromium" === e.brand))), Ns = !Os && As, js = Ds = (Hs.brands.find((e => "Chromium" === e.brand)) || {}).version || null, Us = "Windows" === Hs.platform), !As) { const e = Un().navigator && Un().navigator.userAgent || ""; Cs = /iPod/i.test(e), Ps = function () { const t = e.match(/OS (\d+)_/i); return t && t[1] ? t[1] : null }(), Is = /Android/i.test(e), Es = function () { const t = e.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i); if (!t) return null; const n = t[1] && parseFloat(t[1]), i = t[2] && parseFloat(t[2]); return n && i ? parseFloat(t[1] + "." + t[2]) : n || null }(), Ls = /Firefox/i.test(e), Os = /Edg/i.test(e), As = /Chrome/i.test(e) || /CriOS/i.test(e), Ns = !Os && As, js = Ds = function () { const t = e.match(/(Chrome|CriOS)\/(\d+)/); return t && t[2] ? parseFloat(t[2]) : null }(), Ms = function () { const t = /MSIE\s(\d+)\.\d/.exec(e); let n = t && parseFloat(t[1]); return !n && /Trident\/7.0/i.test(e) && /rv:11.0/.test(e) && (n = 11), n }(), Rs = /Safari/i.test(e) && !Ns && !Is && !Os, Us = /Windows/i.test(e), Bs = /iPad/i.test(e) || Rs && zs && !/iPhone/i.test(e), Fs = /iPhone/i.test(e) && !Bs } const Vs = Fs || Bs || Cs, Ws = (Rs || Vs) && !Ns; var qs = Object.freeze({ __proto__: null, get IS_IPOD() { return Cs }, get IOS_VERSION() { return Ps }, get IS_ANDROID() { return Is }, get ANDROID_VERSION() { return Es }, get IS_FIREFOX() { return Ls }, get IS_EDGE() { return Os }, get IS_CHROMIUM() { return As }, get IS_CHROME() { return Ns }, get CHROMIUM_VERSION() { return js }, get CHROME_VERSION() { return Ds }, get IE_VERSION() { return Ms }, get IS_SAFARI() { return Rs }, get IS_WINDOWS() { return Us }, get IS_IPAD() { return Bs }, get IS_IPHONE() { return Fs }, TOUCH_ENABLED: zs, IS_IOS: Vs, IS_ANY_SAFARI: Ws }); function Gs(e) { return "string" === typeof e && Boolean(e.trim()) } function Xs() { return Fn() === Un().document } function Ks(e) { return Ts(e) && 1 === e.nodeType } function $s() { try { return Un().parent !== Un().self } catch (e) { return !0 } } function Ys(e) { return function (t, n) { if (!Gs(t)) return Fn()[e](null); Gs(n) && (n = Fn().querySelector(n)); const i = Ks(n) ? n : Fn(); return i[e] && i[e](t) } } function Qs() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "div", t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = arguments.length > 3 ? arguments[3] : void 0; const r = Fn().createElement(e); return Object.getOwnPropertyNames(t).forEach((function (e) { const n = t[e]; "textContent" === e ? Js(r, n) : r[e] === n && "tabIndex" !== e || (r[e] = n) })), Object.getOwnPropertyNames(n).forEach((function (e) { r.setAttribute(e, n[e]) })), i && ya(r, i), r } function Js(e, t) { return "undefined" === typeof e.textContent ? e.innerText = t : e.textContent = t, e } function Zs(e, t) { t.firstChild ? t.insertBefore(e, t.firstChild) : t.appendChild(e) } function ea(e, t) { return function (e) { if (e.indexOf(" ") >= 0) throw new Error("class has illegal whitespace characters") }(t), e.classList.contains(t) } function ta(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; return e.classList.add(...n.reduce(((e, t) => e.concat(t.split(/\s+/))), [])), e } function na(e) { if (!e) return ms.warn("removeClass was called with an element that doesn't exist"), null; for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; return e.classList.remove(...n.reduce(((e, t) => e.concat(t.split(/\s+/))), [])), e } function ia(e, t, n) { return "function" === typeof n && (n = n(e, t)), "boolean" !== typeof n && (n = void 0), t.split(/\s+/).forEach((t => e.classList.toggle(t, n))), e } function ra(e, t) { Object.getOwnPropertyNames(t).forEach((function (n) { const i = t[n]; null === i || "undefined" === typeof i || !1 === i ? e.removeAttribute(n) : e.setAttribute(n, !0 === i ? "" : i) })) } function sa(e) { const t = {}, n = ",autoplay,controls,playsinline,loop,muted,default,defaultMuted,"; if (e && e.attributes && e.attributes.length > 0) { const i = e.attributes; for (let r = i.length - 1; r >= 0; r--) { const s = i[r].name; let a = i[r].value; "boolean" !== typeof e[s] && -1 === n.indexOf("," + s + ",") || (a = null !== a), t[s] = a } } return t } function aa(e, t) { return e.getAttribute(t) } function oa(e, t, n) { e.setAttribute(t, n) } function la(e, t) { e.removeAttribute(t) } function ca() { Fn().body.focus(), Fn().onselectstart = function () { return !1 } } function ua() { Fn().onselectstart = function () { return !0 } } function da(e) { if (e && e.getBoundingClientRect && e.parentNode) { const t = e.getBoundingClientRect(), n = {}; return ["bottom", "height", "left", "right", "top", "width"].forEach((e => { void 0 !== t[e] && (n[e] = t[e]) })), n.height || (n.height = parseFloat(Sa(e, "height"))), n.width || (n.width = parseFloat(Sa(e, "width"))), n } } function ha(e) { if (!e || e && !e.offsetParent) return { left: 0, top: 0, width: 0, height: 0 }; const t = e.offsetWidth, n = e.offsetHeight; let i = 0, r = 0; for (; e.offsetParent && e !== Fn()[us.fullscreenElement];)i += e.offsetLeft, r += e.offsetTop, e = e.offsetParent; return { left: i, top: r, width: t, height: n } } function pa(e, t) { const n = { x: 0, y: 0 }; if (Vs) { let t = e; for (; t && "html" !== t.nodeName.toLowerCase();) { const e = Sa(t, "transform"); if (/^matrix/.test(e)) { const t = e.slice(7, -1).split(/,\s/).map(Number); n.x += t[4], n.y += t[5] } else if (/^matrix3d/.test(e)) { const t = e.slice(9, -1).split(/,\s/).map(Number); n.x += t[12], n.y += t[13] } t = t.parentNode } } const i = {}, r = ha(t.target), s = ha(e), a = s.width, o = s.height; let l = t.offsetY - (s.top - r.top), c = t.offsetX - (s.left - r.left); return t.changedTouches && (c = t.changedTouches[0].pageX - s.left, l = t.changedTouches[0].pageY + s.top, Vs && (c -= n.x, l -= n.y)), i.y = 1 - Math.max(0, Math.min(1, l / o)), i.x = Math.max(0, Math.min(1, c / a)), i } function fa(e) { return Ts(e) && 3 === e.nodeType } function ma(e) { for (; e.firstChild;)e.removeChild(e.firstChild); return e } function ga(e) { return "function" === typeof e && (e = e()), (Array.isArray(e) ? e : [e]).map((e => ("function" === typeof e && (e = e()), Ks(e) || fa(e) ? e : "string" === typeof e && /\S/.test(e) ? Fn().createTextNode(e) : void 0))).filter((e => e)) } function ya(e, t) { return ga(t).forEach((t => e.appendChild(t))), e } function va(e, t) { return ya(ma(e), t) } function ba(e) { return void 0 === e.button && void 0 === e.buttons || (0 === e.button && void 0 === e.buttons || ("mouseup" === e.type && 0 === e.button && 0 === e.buttons || 0 === e.button && 1 === e.buttons)) } const _a = Ys("querySelector"), Ta = Ys("querySelectorAll"); function Sa(e, t) { if (!e || !t) return ""; if ("function" === typeof Un().getComputedStyle) { let i; try { i = Un().getComputedStyle(e) } catch (n) { return "" } return i ? i.getPropertyValue(t) || i[t] : "" } return "" } var wa = Object.freeze({ __proto__: null, isReal: Xs, isEl: Ks, isInFrame: $s, createEl: Qs, textContent: Js, prependTo: Zs, hasClass: ea, addClass: ta, removeClass: na, toggleClass: ia, setAttributes: ra, getAttributes: sa, getAttribute: aa, setAttribute: oa, removeAttribute: la, blockTextSelection: ca, unblockTextSelection: ua, getBoundingClientRect: da, findPosition: ha, getPointerPosition: pa, isTextNode: fa, emptyEl: ma, normalizeContent: ga, appendContent: ya, insertContent: va, isSingleLeftClick: ba, $: _a, $$: Ta, computedStyle: Sa }); let xa, ka = !1; const Ea = function () { if (!1 === xa.options.autoSetup) return; const e = Array.prototype.slice.call(Fn().getElementsByTagName("video")), t = Array.prototype.slice.call(Fn().getElementsByTagName("audio")), n = Array.prototype.slice.call(Fn().getElementsByTagName("video-js")), i = e.concat(t, n); if (i && i.length > 0) for (let r = 0, s = i.length; r < s; r++) { const e = i[r]; if (!e || !e.getAttribute) { Ca(1); break } if (void 0 === e.player) { null !== e.getAttribute("data-setup") && xa(e) } } else ka || Ca(1) }; function Ca(e, t) { Xs() && (t && (xa = t), Un().setTimeout(Ea, e)) } function Pa() { ka = !0, Un().removeEventListener("load", Pa) } Xs() && ("complete" === Fn().readyState ? Pa() : Un().addEventListener("load", Pa)); const Ia = function (e) { const t = Fn().createElement("style"); return t.className = e, t }, La = function (e, t) { e.styleSheet ? e.styleSheet.cssText = t : e.textContent = t }; var Oa = new WeakMap; let Aa, Na = 3; function ja() { return Na++ } function Da(e, t) { if (!Oa.has(e)) return; const n = Oa.get(e); 0 === n.handlers[t].length && (delete n.handlers[t], e.removeEventListener ? e.removeEventListener(t, n.dispatcher, !1) : e.detachEvent && e.detachEvent("on" + t, n.dispatcher)), Object.getOwnPropertyNames(n.handlers).length <= 0 && (delete n.handlers, delete n.dispatcher, delete n.disabled), 0 === Object.getOwnPropertyNames(n).length && Oa.delete(e) } function Ma(e, t, n, i) { n.forEach((function (n) { e(t, n, i) })) } function Ra(e) { if (e.fixed_) return e; function t() { return !0 } function n() { return !1 } if (!e || !e.isPropagationStopped || !e.isImmediatePropagationStopped) { const i = e || Un().event; e = {}; for (const t in i) "layerX" !== t && "layerY" !== t && "keyLocation" !== t && "webkitMovementX" !== t && "webkitMovementY" !== t && "path" !== t && ("returnValue" === t && i.preventDefault || (e[t] = i[t])); if (e.target || (e.target = e.srcElement || Fn()), e.relatedTarget || (e.relatedTarget = e.fromElement === e.target ? e.toElement : e.fromElement), e.preventDefault = function () { i.preventDefault && i.preventDefault(), e.returnValue = !1, i.returnValue = !1, e.defaultPrevented = !0 }, e.defaultPrevented = !1, e.stopPropagation = function () { i.stopPropagation && i.stopPropagation(), e.cancelBubble = !0, i.cancelBubble = !0, e.isPropagationStopped = t }, e.isPropagationStopped = n, e.stopImmediatePropagation = function () { i.stopImmediatePropagation && i.stopImmediatePropagation(), e.isImmediatePropagationStopped = t, e.stopPropagation() }, e.isImmediatePropagationStopped = n, null !== e.clientX && void 0 !== e.clientX) { const t = Fn().documentElement, n = Fn().body; e.pageX = e.clientX + (t && t.scrollLeft || n && n.scrollLeft || 0) - (t && t.clientLeft || n && n.clientLeft || 0), e.pageY = e.clientY + (t && t.scrollTop || n && n.scrollTop || 0) - (t && t.clientTop || n && n.clientTop || 0) } e.which = e.charCode || e.keyCode, null !== e.button && void 0 !== e.button && (e.button = 1 & e.button ? 0 : 4 & e.button ? 1 : 2 & e.button ? 2 : 0) } return e.fixed_ = !0, e } const Ua = function () { if ("boolean" !== typeof Aa) { Aa = !1; try { const e = Object.defineProperty({}, "passive", { get() { Aa = !0 } }); Un().addEventListener("test", null, e), Un().removeEventListener("test", null, e) } catch (e) { } } return Aa }, Ba = ["touchstart", "touchmove"]; function Fa(e, t, n) { if (Array.isArray(t)) return Ma(Fa, e, t, n); Oa.has(e) || Oa.set(e, {}); const i = Oa.get(e); if (i.handlers || (i.handlers = {}), i.handlers[t] || (i.handlers[t] = []), n.guid || (n.guid = ja()), i.handlers[t].push(n), i.dispatcher || (i.disabled = !1, i.dispatcher = function (t, n) { if (i.disabled) return; t = Ra(t); const r = i.handlers[t.type]; if (r) { const i = r.slice(0); for (let r = 0, a = i.length; r < a && !t.isImmediatePropagationStopped(); r++)try { i[r].call(e, t, n) } catch (s) { ms.error(s) } } }), 1 === i.handlers[t].length) if (e.addEventListener) { let n = !1; Ua() && Ba.indexOf(t) > -1 && (n = { passive: !0 }), e.addEventListener(t, i.dispatcher, n) } else e.attachEvent && e.attachEvent("on" + t, i.dispatcher) } function za(e, t, n) { if (!Oa.has(e)) return; const i = Oa.get(e); if (!i.handlers) return; if (Array.isArray(t)) return Ma(za, e, t, n); const r = function (e, t) { i.handlers[t] = [], Da(e, t) }; if (void 0 === t) { for (const t in i.handlers) Object.prototype.hasOwnProperty.call(i.handlers || {}, t) && r(e, t); return } const s = i.handlers[t]; if (s) if (n) { if (n.guid) for (let e = 0; e < s.length; e++)s[e].guid === n.guid && s.splice(e--, 1); Da(e, t) } else r(e, t) } function Ha(e, t, n) { const i = Oa.has(e) ? Oa.get(e) : {}, r = e.parentNode || e.ownerDocument; if ("string" === typeof t ? t = { type: t, target: e } : t.target || (t.target = e), t = Ra(t), i.dispatcher && i.dispatcher.call(e, t, n), r && !t.isPropagationStopped() && !0 === t.bubbles) Ha.call(null, r, t, n); else if (!r && !t.defaultPrevented && t.target && t.target[t.type]) { Oa.has(t.target) || Oa.set(t.target, {}); const e = Oa.get(t.target); t.target[t.type] && (e.disabled = !0, "function" === typeof t.target[t.type] && t.target[t.type](), e.disabled = !1) } return !t.defaultPrevented } function Va(e, t, n) { if (Array.isArray(t)) return Ma(Va, e, t, n); const i = function () { za(e, t, i), n.apply(this, arguments) }; i.guid = n.guid = n.guid || ja(), Fa(e, t, i) } function Wa(e, t, n) { const i = function () { za(e, t, i), n.apply(this, arguments) }; i.guid = n.guid = n.guid || ja(), Fa(e, t, i) } var qa = Object.freeze({ __proto__: null, fixEvent: Ra, on: Fa, off: za, trigger: Ha, one: Va, any: Wa }); const Ga = 30, Xa = function (e, t, n) { t.guid || (t.guid = ja()); const i = t.bind(e); return i.guid = n ? n + "_" + t.guid : t.guid, i }, Ka = function (e, t) { let n = Un().performance.now(); return function () { const i = Un().performance.now(); i - n >= t && (e(...arguments), n = i) } }, $a = function (e, t, n) { let i, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Un(); const s = function () { const s = this, a = arguments; let o = function () { i = null, o = null, n || e.apply(s, a) }; !i && n && e.apply(s, a), r.clearTimeout(i), i = r.setTimeout(o, t) }; return s.cancel = () => { r.clearTimeout(i), i = null }, s }; var Ya = Object.freeze({ __proto__: null, UPDATE_REFRESH_INTERVAL: Ga, bind_: Xa, throttle: Ka, debounce: $a }); let Qa; class Ja { on(e, t) { const n = this.addEventListener; this.addEventListener = () => { }, Fa(this, e, t), this.addEventListener = n } off(e, t) { za(this, e, t) } one(e, t) { const n = this.addEventListener; this.addEventListener = () => { }, Va(this, e, t), this.addEventListener = n } any(e, t) { const n = this.addEventListener; this.addEventListener = () => { }, Wa(this, e, t), this.addEventListener = n } trigger(e) { const t = e.type || e; "string" === typeof e && (e = { type: t }), e = Ra(e), this.allowedEvents_[t] && this["on" + t] && this["on" + t](e), Ha(this, e) } queueTrigger(e) { Qa || (Qa = new Map); const t = e.type || e; let n = Qa.get(this); n || (n = new Map, Qa.set(this, n)); const i = n.get(t); n.delete(t), Un().clearTimeout(i); const r = Un().setTimeout((() => { n.delete(t), 0 === n.size && (n = null, Qa.delete(this)), this.trigger(e) }), 0); n.set(t, r) } } Ja.prototype.allowedEvents_ = {}, Ja.prototype.addEventListener = Ja.prototype.on, Ja.prototype.removeEventListener = Ja.prototype.off, Ja.prototype.dispatchEvent = Ja.prototype.trigger; const Za = e => "function" === typeof e.name ? e.name() : "string" === typeof e.name ? e.name : e.name_ ? e.name_ : e.constructor && e.constructor.name ? e.constructor.name : typeof e, eo = e => e instanceof Ja || !!e.eventBusEl_ && ["on", "one", "off", "trigger"].every((t => "function" === typeof e[t])), to = e => "string" === typeof e && /\S/.test(e) || Array.isArray(e) && !!e.length, no = (e, t, n) => { if (!e || !e.nodeName && !eo(e)) throw new Error("Invalid target for ".concat(Za(t), "#").concat(n, "; must be a DOM node or evented object.")) }, io = (e, t, n) => { if (!to(e)) throw new Error("Invalid event type for ".concat(Za(t), "#").concat(n, "; must be a non-empty string or array.")) }, ro = (e, t, n) => { if ("function" !== typeof e) throw new Error("Invalid listener for ".concat(Za(t), "#").concat(n, "; must be a function.")) }, so = (e, t, n) => { const i = t.length < 3 || t[0] === e || t[0] === e.eventBusEl_; let r, s, a; return i ? (r = e.eventBusEl_, t.length >= 3 && t.shift(), [s, a] = t) : [r, s, a] = t, no(r, e, n), io(s, e, n), ro(a, e, n), a = Xa(e, a), { isTargetingSelf: i, target: r, type: s, listener: a } }, ao = (e, t, n, i) => { no(e, e, t), e.nodeName ? qa[t](e, n, i) : e[t](n, i) }, oo = { on() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; const { isTargetingSelf: i, target: r, type: s, listener: a } = so(this, t, "on"); if (ao(r, "on", s, a), !i) { const e = () => this.off(r, s, a); e.guid = a.guid; const t = () => this.off("dispose", e); t.guid = a.guid, ao(this, "on", "dispose", e), ao(r, "on", "dispose", t) } }, one() { for (var e = this, t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; const { isTargetingSelf: r, target: s, type: a, listener: o } = so(this, n, "one"); if (r) ao(s, "one", a, o); else { const t = function () { e.off(s, a, t); for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++)i[r] = arguments[r]; o.apply(null, i) }; t.guid = o.guid, ao(s, "one", a, t) } }, any() { for (var e = this, t = arguments.length, n = new Array(t), i = 0; i < t; i++)n[i] = arguments[i]; const { isTargetingSelf: r, target: s, type: a, listener: o } = so(this, n, "any"); if (r) ao(s, "any", a, o); else { const t = function () { e.off(s, a, t); for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++)i[r] = arguments[r]; o.apply(null, i) }; t.guid = o.guid, ao(s, "any", a, t) } }, off(e, t, n) { if (!e || to(e)) za(this.eventBusEl_, e, t); else { const i = e, r = t; no(i, this, "off"), io(r, this, "off"), ro(n, this, "off"), n = Xa(this, n), this.off("dispose", n), i.nodeName ? (za(i, r, n), za(i, "dispose", n)) : eo(i) && (i.off(r, n), i.off("dispose", n)) } }, trigger(e, t) { no(this.eventBusEl_, this, "trigger"); const n = e && "string" !== typeof e ? e.type : e; if (!to(n)) throw new Error("Invalid event type for ".concat(Za(this), "#trigger; ") + "must be a non-empty string or object with a type key that has a non-empty value."); return Ha(this.eventBusEl_, e, t) } }; function lo(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const { eventBusKey: n } = t; if (n) { if (!e[n].nodeName) throw new Error('The eventBusKey "'.concat(n, '" does not refer to an element.')); e.eventBusEl_ = e[n] } else e.eventBusEl_ = Qs("span", { className: "vjs-event-bus" }); return Object.assign(e, oo), e.eventedCallbacks && e.eventedCallbacks.forEach((e => { e() })), e.on("dispose", (() => { e.off(), [e, e.el_, e.eventBusEl_].forEach((function (e) { e && Oa.has(e) && Oa.delete(e) })), Un().setTimeout((() => { e.eventBusEl_ = null }), 0) })), e } const co = { state: {}, setState(e) { let t; return "function" === typeof e && (e = e()), bs(e, ((e, n) => { this.state[n] !== e && (t = t || {}, t[n] = { from: this.state[n], to: e }), this.state[n] = e })), t && eo(this) && this.trigger({ changes: t, type: "statechanged" }), t } }; function uo(e, t) { return Object.assign(e, co), e.state = Object.assign({}, e.state, t), "function" === typeof e.handleStateChanged && eo(e) && e.on("statechanged", e.handleStateChanged), e } const ho = function (e) { return "string" !== typeof e ? e : e.replace(/./, (e => e.toLowerCase())) }, po = function (e) { return "string" !== typeof e ? e : e.replace(/./, (e => e.toUpperCase())) }, fo = function (e, t) { return po(e) === po(t) }; var mo = Object.freeze({ __proto__: null, toLowerCase: ho, toTitleCase: po, titleCaseEquals: fo }); class go { constructor(e, t, n) { if (!e && this.play ? this.player_ = e = this : this.player_ = e, this.isDisposed_ = !1, this.parentComponent_ = null, this.options_ = ws({}, this.options_), t = this.options_ = ws(this.options_, t), this.id_ = t.id || t.el && t.el.id, !this.id_) { const t = e && e.id && e.id() || "no_player"; this.id_ = "".concat(t, "_component_").concat(ja()) } this.name_ = t.name || null, t.el ? this.el_ = t.el : !1 !== t.createEl && (this.el_ = this.createEl()), t.className && this.el_ && t.className.split(" ").forEach((e => this.addClass(e))), ["on", "off", "one", "any", "trigger"].forEach((e => { this[e] = void 0 })), !1 !== t.evented && (lo(this, { eventBusKey: this.el_ ? "el_" : null }), this.handleLanguagechange = this.handleLanguagechange.bind(this), this.on(this.player_, "languagechange", this.handleLanguagechange)), uo(this, this.constructor.defaultState), this.children_ = [], this.childIndex_ = {}, this.childNameIndex_ = {}, this.setTimeoutIds_ = new Set, this.setIntervalIds_ = new Set, this.rafIds_ = new Set, this.namedRafs_ = new Map, this.clearingTimersOnDispose_ = !1, !1 !== t.initChildren && this.initChildren(), this.ready(n), !1 !== t.reportTouchActivity && this.enableTouchActivity() } on(e, t) { } off(e, t) { } one(e, t) { } any(e, t) { } trigger(e) { } dispose() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (!this.isDisposed_) { if (this.readyQueue_ && (this.readyQueue_.length = 0), this.trigger({ type: "dispose", bubbles: !1 }), this.isDisposed_ = !0, this.children_) for (let e = this.children_.length - 1; e >= 0; e--)this.children_[e].dispose && this.children_[e].dispose(); this.children_ = null, this.childIndex_ = null, this.childNameIndex_ = null, this.parentComponent_ = null, this.el_ && (this.el_.parentNode && (e.restoreEl ? this.el_.parentNode.replaceChild(e.restoreEl, this.el_) : this.el_.parentNode.removeChild(this.el_)), this.el_ = null), this.player_ = null } } isDisposed() { return Boolean(this.isDisposed_) } player() { return this.player_ } options(e) { return e ? (this.options_ = ws(this.options_, e), this.options_) : this.options_ } el() { return this.el_ } createEl(e, t, n) { return Qs(e, t, n) } localize(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e; const i = this.player_.language && this.player_.language(), r = this.player_.languages && this.player_.languages(), s = r && r[i], a = i && i.split("-")[0], o = r && r[a]; let l = n; return s && s[e] ? l = s[e] : o && o[e] && (l = o[e]), t && (l = l.replace(/\{(\d+)\}/g, (function (e, n) { const i = t[n - 1]; let r = i; return "undefined" === typeof i && (r = e), r }))), l } handleLanguagechange() { } contentEl() { return this.contentEl_ || this.el_ } id() { return this.id_ } name() { return this.name_ } children() { return this.children_ } getChildById(e) { return this.childIndex_[e] } getChild(e) { if (e) return this.childNameIndex_[e] } getDescendant() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; t = t.reduce(((e, t) => e.concat(t)), []); let i = this; for (let r = 0; r < t.length; r++)if (i = i.getChild(t[r]), !i || !i.getChild) return; return i } addChild(e) { let t, n, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.children_.length; if ("string" === typeof e) { n = po(e); const r = i.componentClass || n; i.name = n; const s = go.getComponent(r); if (!s) throw new Error("Component ".concat(r, " does not exist")); if ("function" !== typeof s) return null; t = new s(this.player_ || this, i) } else t = e; if (t.parentComponent_ && t.parentComponent_.removeChild(t), this.children_.splice(r, 0, t), t.parentComponent_ = this, "function" === typeof t.id && (this.childIndex_[t.id()] = t), n = n || t.name && po(t.name()), n && (this.childNameIndex_[n] = t, this.childNameIndex_[ho(n)] = t), "function" === typeof t.el && t.el()) { let e = null; this.children_[r + 1] && (this.children_[r + 1].el_ ? e = this.children_[r + 1].el_ : Ks(this.children_[r + 1]) && (e = this.children_[r + 1])), this.contentEl().insertBefore(t.el(), e) } return t } removeChild(e) { if ("string" === typeof e && (e = this.getChild(e)), !e || !this.children_) return; let t = !1; for (let i = this.children_.length - 1; i >= 0; i--)if (this.children_[i] === e) { t = !0, this.children_.splice(i, 1); break } if (!t) return; e.parentComponent_ = null, this.childIndex_[e.id()] = null, this.childNameIndex_[po(e.name())] = null, this.childNameIndex_[ho(e.name())] = null; const n = e.el(); n && n.parentNode === this.contentEl() && this.contentEl().removeChild(e.el()) } initChildren() { const e = this.options_.children; if (e) { const t = this.options_, n = e => { const n = e.name; let i = e.opts; if (void 0 !== t[n] && (i = t[n]), !1 === i) return; !0 === i && (i = {}), i.playerOptions = this.options_.playerOptions; const r = this.addChild(n, i); r && (this[n] = r) }; let i; const r = go.getComponent("Tech"); i = Array.isArray(e) ? e : Object.keys(e), i.concat(Object.keys(this.options_).filter((function (e) { return !i.some((function (t) { return "string" === typeof t ? e === t : e === t.name })) }))).map((t => { let n, i; return "string" === typeof t ? (n = t, i = e[n] || this.options_[n] || {}) : (n = t.name, i = t), { name: n, opts: i } })).filter((e => { const t = go.getComponent(e.opts.componentClass || po(e.name)); return t && !r.isTech(t) })).forEach(n) } } buildCSSClass() { return "" } ready(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (e) return this.isReady_ ? void (t ? e.call(this) : this.setTimeout(e, 1)) : (this.readyQueue_ = this.readyQueue_ || [], void this.readyQueue_.push(e)) } triggerReady() { this.isReady_ = !0, this.setTimeout((function () { const e = this.readyQueue_; this.readyQueue_ = [], e && e.length > 0 && e.forEach((function (e) { e.call(this) }), this), this.trigger("ready") }), 1) } $(e, t) { return _a(e, t || this.contentEl()) } $$(e, t) { return Ta(e, t || this.contentEl()) } hasClass(e) { return ea(this.el_, e) } addClass() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; ta(this.el_, ...t) } removeClass() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; na(this.el_, ...t) } toggleClass(e, t) { ia(this.el_, e, t) } show() { this.removeClass("vjs-hidden") } hide() { this.addClass("vjs-hidden") } lockShowing() { this.addClass("vjs-lock-showing") } unlockShowing() { this.removeClass("vjs-lock-showing") } getAttribute(e) { return aa(this.el_, e) } setAttribute(e, t) { oa(this.el_, e, t) } removeAttribute(e) { la(this.el_, e) } width(e, t) { return this.dimension("width", e, t) } height(e, t) { return this.dimension("height", e, t) } dimensions(e, t) { this.width(e, !0), this.height(t) } dimension(e, t, n) { if (void 0 !== t) return null !== t && t === t || (t = 0), -1 !== ("" + t).indexOf("%") || -1 !== ("" + t).indexOf("px") ? this.el_.style[e] = t : this.el_.style[e] = "auto" === t ? "" : t + "px", void (n || this.trigger("componentresize")); if (!this.el_) return 0; const i = this.el_.style[e], r = i.indexOf("px"); return -1 !== r ? parseInt(i.slice(0, r), 10) : parseInt(this.el_["offset" + po(e)], 10) } currentDimension(e) { let t = 0; if ("width" !== e && "height" !== e) throw new Error("currentDimension only accepts width or height value"); if (t = Sa(this.el_, e), t = parseFloat(t), 0 === t || isNaN(t)) { const n = "offset".concat(po(e)); t = this.el_[n] } return t } currentDimensions() { return { width: this.currentDimension("width"), height: this.currentDimension("height") } } currentWidth() { return this.currentDimension("width") } currentHeight() { return this.currentDimension("height") } focus() { this.el_.focus() } blur() { this.el_.blur() } handleKeyDown(e) { this.player_ && (Hn().isEventKey(e, "Tab") || e.stopPropagation(), this.player_.handleKeyDown(e)) } handleKeyPress(e) { this.handleKeyDown(e) } emitTapEvents() { let e = 0, t = null; let n; this.on("touchstart", (function (i) { 1 === i.touches.length && (t = { pageX: i.touches[0].pageX, pageY: i.touches[0].pageY }, e = Un().performance.now(), n = !0) })), this.on("touchmove", (function (e) { if (e.touches.length > 1) n = !1; else if (t) { const i = e.touches[0].pageX - t.pageX, r = e.touches[0].pageY - t.pageY; Math.sqrt(i * i + r * r) > 10 && (n = !1) } })); const i = function () { n = !1 }; this.on("touchleave", i), this.on("touchcancel", i), this.on("touchend", (function (i) { if (t = null, !0 === n) { Un().performance.now() - e < 200 && (i.preventDefault(), this.trigger("tap")) } })) } enableTouchActivity() { if (!this.player() || !this.player().reportUserActivity) return; const e = Xa(this.player(), this.player().reportUserActivity); let t; this.on("touchstart", (function () { e(), this.clearInterval(t), t = this.setInterval(e, 250) })); const n = function (n) { e(), this.clearInterval(t) }; this.on("touchmove", e), this.on("touchend", n), this.on("touchcancel", n) } setTimeout(e, t) { var n; return e = Xa(this, e), this.clearTimersOnDispose_(), n = Un().setTimeout((() => { this.setTimeoutIds_.has(n) && this.setTimeoutIds_.delete(n), e() }), t), this.setTimeoutIds_.add(n), n } clearTimeout(e) { return this.setTimeoutIds_.has(e) && (this.setTimeoutIds_.delete(e), Un().clearTimeout(e)), e } setInterval(e, t) { e = Xa(this, e), this.clearTimersOnDispose_(); const n = Un().setInterval(e, t); return this.setIntervalIds_.add(n), n } clearInterval(e) { return this.setIntervalIds_.has(e) && (this.setIntervalIds_.delete(e), Un().clearInterval(e)), e } requestAnimationFrame(e) { var t; return this.clearTimersOnDispose_(), e = Xa(this, e), t = Un().requestAnimationFrame((() => { this.rafIds_.has(t) && this.rafIds_.delete(t), e() })), this.rafIds_.add(t), t } requestNamedAnimationFrame(e, t) { if (this.namedRafs_.has(e)) return; this.clearTimersOnDispose_(), t = Xa(this, t); const n = this.requestAnimationFrame((() => { t(), this.namedRafs_.has(e) && this.namedRafs_.delete(e) })); return this.namedRafs_.set(e, n), e } cancelNamedAnimationFrame(e) { this.namedRafs_.has(e) && (this.cancelAnimationFrame(this.namedRafs_.get(e)), this.namedRafs_.delete(e)) } cancelAnimationFrame(e) { return this.rafIds_.has(e) && (this.rafIds_.delete(e), Un().cancelAnimationFrame(e)), e } clearTimersOnDispose_() { this.clearingTimersOnDispose_ || (this.clearingTimersOnDispose_ = !0, this.one("dispose", (() => { [["namedRafs_", "cancelNamedAnimationFrame"], ["rafIds_", "cancelAnimationFrame"], ["setTimeoutIds_", "clearTimeout"], ["setIntervalIds_", "clearInterval"]].forEach((e => { let [t, n] = e; this[t].forEach(((e, t) => this[n](t))) })), this.clearingTimersOnDispose_ = !1 }))) } static registerComponent(e, t) { if ("string" !== typeof e || !e) throw new Error('Illegal component name, "'.concat(e, '"; must be a non-empty string.')); const n = go.getComponent("Tech"), i = n && n.isTech(t), r = go === t || go.prototype.isPrototypeOf(t.prototype); if (i || !r) { let t; throw t = i ? "techs must be registered using Tech.registerTech()" : "must be a Component subclass", new Error('Illegal component, "'.concat(e, '"; ').concat(t, ".")) } e = po(e), go.components_ || (go.components_ = {}); const s = go.getComponent("Player"); if ("Player" === e && s && s.players) { const e = s.players, t = Object.keys(e); if (e && t.length > 0 && t.map((t => e[t])).every(Boolean)) throw new Error("Can not register Player component after player has been created.") } return go.components_[e] = t, go.components_[ho(e)] = t, t } static getComponent(e) { if (e && go.components_) return go.components_[e] } } function yo(e, t, n, i) { return function (e, t, n) { if ("number" !== typeof t || t < 0 || t > n) throw new Error("Failed to execute '".concat(e, "' on 'TimeRanges': The index provided (").concat(t, ") is non-numeric or out of bounds (0-").concat(n, ").")) }(e, i, n.length - 1), n[i][t] } function vo(e) { let t; return t = void 0 === e || 0 === e.length ? { length: 0, start() { throw new Error("This TimeRanges object is empty") }, end() { throw new Error("This TimeRanges object is empty") } } : { length: e.length, start: yo.bind(null, "start", 0, e), end: yo.bind(null, "end", 1, e) }, Un().Symbol && Un().Symbol.iterator && (t[Un().Symbol.iterator] = () => (e || []).values()), t } function bo(e, t) { return Array.isArray(e) ? vo(e) : void 0 === e || void 0 === t ? vo() : vo([[e, t]]) } go.registerComponent("Component", go); const _o = function (e, t) { e = e < 0 ? 0 : e; let n = Math.floor(e % 60), i = Math.floor(e / 60 % 60), r = Math.floor(e / 3600); const s = Math.floor(t / 60 % 60), a = Math.floor(t / 3600); return (isNaN(e) || e === 1 / 0) && (r = i = n = "-"), r = r > 0 || a > 0 ? r + ":" : "", i = ((r || s >= 10) && i < 10 ? "0" + i : i) + ":", n = n < 10 ? "0" + n : n, r + i + n }; let To = _o; function So(e) { To = e } function wo() { To = _o } function xo(e) { return To(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e) } var ko = Object.freeze({ __proto__: null, createTimeRanges: bo, createTimeRange: bo, setFormatTime: So, resetFormatTime: wo, formatTime: xo }); function Eo(e, t) { let n, i, r = 0; if (!t) return 0; e && e.length || (e = bo(0, 0)); for (let s = 0; s < e.length; s++)n = e.start(s), i = e.end(s), i > t && (i = t), r += i - n; return r / t } function Co(e) { if (e instanceof Co) return e; "number" === typeof e ? this.code = e : "string" === typeof e ? this.message = e : Ts(e) && ("number" === typeof e.code && (this.code = e.code), Object.assign(this, e)), this.message || (this.message = Co.defaultMessages[this.code] || "") } Co.prototype.code = 0, Co.prototype.message = "", Co.prototype.status = null, Co.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"], Co.defaultMessages = { 1: "You aborted the media playback", 2: "A network error caused the media download to fail part-way.", 3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.", 4: "The media could not be loaded, either because the server or network failed or because the format is not supported.", 5: "The media is encrypted and we do not have the keys to decrypt it." }; for (let n = 0; n < Co.errorTypes.length; n++)Co[Co.errorTypes[n]] = n, Co.prototype[Co.errorTypes[n]] = n; function Po(e) { return void 0 !== e && null !== e && "function" === typeof e.then } function Io(e) { Po(e) && e.then(null, (e => { })) } const Lo = function (e) { return ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce(((t, n, i) => (e[n] && (t[n] = e[n]), t)), { cues: e.cues && Array.prototype.map.call(e.cues, (function (e) { return { startTime: e.startTime, endTime: e.endTime, text: e.text, id: e.id } })) }) }; var Oo = function (e) { const t = e.$$("track"), n = Array.prototype.map.call(t, (e => e.track)), i = Array.prototype.map.call(t, (function (e) { const t = Lo(e.track); return e.src && (t.src = e.src), t })); return i.concat(Array.prototype.filter.call(e.textTracks(), (function (e) { return -1 === n.indexOf(e) })).map(Lo)) }, Ao = function (e, t) { return e.forEach((function (e) { const n = t.addRemoteTextTrack(e).track; !e.src && e.cues && e.cues.forEach((e => n.addCue(e))) })), t.textTracks() }; const No = "vjs-modal-dialog"; class jo extends go { constructor(e, t) { super(e, t), this.handleKeyDown_ = e => this.handleKeyDown(e), this.close_ = e => this.close(e), this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = !1, this.closeable(!this.options_.uncloseable), this.content(this.options_.content), this.contentEl_ = Qs("div", { className: "".concat(No, "-content") }, { role: "document" }), this.descEl_ = Qs("p", { className: "".concat(No, "-description vjs-control-text"), id: this.el().getAttribute("aria-describedby") }), Js(this.descEl_, this.description()), this.el_.appendChild(this.descEl_), this.el_.appendChild(this.contentEl_) } createEl() { return super.createEl("div", { className: this.buildCSSClass(), tabIndex: -1 }, { "aria-describedby": "".concat(this.id(), "_description"), "aria-hidden": "true", "aria-label": this.label(), role: "dialog" }) } dispose() { this.contentEl_ = null, this.descEl_ = null, this.previouslyActiveEl_ = null, super.dispose() } buildCSSClass() { return "".concat(No, " vjs-hidden ").concat(super.buildCSSClass()) } label() { return this.localize(this.options_.label || "Modal Window") } description() { let e = this.options_.description || this.localize("This is a modal window."); return this.closeable() && (e += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.")), e } open() { if (!this.opened_) { const e = this.player(); this.trigger("beforemodalopen"), this.opened_ = !0, (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) && this.fill(), this.wasPlaying_ = !e.paused(), this.options_.pauseOnOpen && this.wasPlaying_ && e.pause(), this.on("keydown", this.handleKeyDown_), this.hadControls_ = e.controls(), e.controls(!1), this.show(), this.conditionalFocus_(), this.el().setAttribute("aria-hidden", "false"), this.trigger("modalopen"), this.hasBeenOpened_ = !0 } } opened(e) { return "boolean" === typeof e && this[e ? "open" : "close"](), this.opened_ } close() { if (!this.opened_) return; const e = this.player(); this.trigger("beforemodalclose"), this.opened_ = !1, this.wasPlaying_ && this.options_.pauseOnOpen && e.play(), this.off("keydown", this.handleKeyDown_), this.hadControls_ && e.controls(!0), this.hide(), this.el().setAttribute("aria-hidden", "true"), this.trigger("modalclose"), this.conditionalBlur_(), this.options_.temporary && this.dispose() } closeable(e) { if ("boolean" === typeof e) { const t = this.closeable_ = !!e; let n = this.getChild("closeButton"); if (t && !n) { const e = this.contentEl_; this.contentEl_ = this.el_, n = this.addChild("closeButton", { controlText: "Close Modal Dialog" }), this.contentEl_ = e, this.on(n, "close", this.close_) } !t && n && (this.off(n, "close", this.close_), this.removeChild(n), n.dispose()) } return this.closeable_ } fill() { this.fillWith(this.content()) } fillWith(e) { const t = this.contentEl(), n = t.parentNode, i = t.nextSibling; this.trigger("beforemodalfill"), this.hasBeenFilled_ = !0, n.removeChild(t), this.empty(), va(t, e), this.trigger("modalfill"), i ? n.insertBefore(t, i) : n.appendChild(t); const r = this.getChild("closeButton"); r && n.appendChild(r.el_) } empty() { this.trigger("beforemodalempty"), ma(this.contentEl()), this.trigger("modalempty") } content(e) { return "undefined" !== typeof e && (this.content_ = e), this.content_ } conditionalFocus_() { const e = Fn().activeElement, t = this.player_.el_; this.previouslyActiveEl_ = null, (t.contains(e) || t === e) && (this.previouslyActiveEl_ = e, this.focus()) } conditionalBlur_() { this.previouslyActiveEl_ && (this.previouslyActiveEl_.focus(), this.previouslyActiveEl_ = null) } handleKeyDown(e) { if (e.stopPropagation(), Hn().isEventKey(e, "Escape") && this.closeable()) return e.preventDefault(), void this.close(); if (!Hn().isEventKey(e, "Tab")) return; const t = this.focusableEls_(), n = this.el_.querySelector(":focus"); let i; for (let r = 0; r < t.length; r++)if (n === t[r]) { i = r; break } Fn().activeElement === this.el_ && (i = 0), e.shiftKey && 0 === i ? (t[t.length - 1].focus(), e.preventDefault()) : e.shiftKey || i !== t.length - 1 || (t[0].focus(), e.preventDefault()) } focusableEls_() { const e = this.el_.querySelectorAll("*"); return Array.prototype.filter.call(e, (e => (e instanceof Un().HTMLAnchorElement || e instanceof Un().HTMLAreaElement) && e.hasAttribute("href") || (e instanceof Un().HTMLInputElement || e instanceof Un().HTMLSelectElement || e instanceof Un().HTMLTextAreaElement || e instanceof Un().HTMLButtonElement) && !e.hasAttribute("disabled") || e instanceof Un().HTMLIFrameElement || e instanceof Un().HTMLObjectElement || e instanceof Un().HTMLEmbedElement || e.hasAttribute("tabindex") && -1 !== e.getAttribute("tabindex") || e.hasAttribute("contenteditable"))) } } jo.prototype.options_ = { pauseOnOpen: !0, temporary: !0 }, go.registerComponent("ModalDialog", jo); class Do extends Ja { constructor() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; super(), this.tracks_ = [], Object.defineProperty(this, "length", { get() { return this.tracks_.length } }); for (let t = 0; t < e.length; t++)this.addTrack(e[t]) } addTrack(e) { const t = this.tracks_.length; "" + t in this || Object.defineProperty(this, t, { get() { return this.tracks_[t] } }), -1 === this.tracks_.indexOf(e) && (this.tracks_.push(e), this.trigger({ track: e, type: "addtrack", target: this })), e.labelchange_ = () => { this.trigger({ track: e, type: "labelchange", target: this }) }, eo(e) && e.addEventListener("labelchange", e.labelchange_) } removeTrack(e) { let t; for (let n = 0, i = this.length; n < i; n++)if (this[n] === e) { t = this[n], t.off && t.off(), this.tracks_.splice(n, 1); break } t && this.trigger({ track: t, type: "removetrack", target: this }) } getTrackById(e) { let t = null; for (let n = 0, i = this.length; n < i; n++) { const i = this[n]; if (i.id === e) { t = i; break } } return t } } Do.prototype.allowedEvents_ = { change: "change", addtrack: "addtrack", removetrack: "removetrack", labelchange: "labelchange" }; for (const n in Do.prototype.allowedEvents_) Do.prototype["on" + n] = null; const Mo = function (e, t) { for (let n = 0; n < e.length; n++)Object.keys(e[n]).length && t.id !== e[n].id && (e[n].enabled = !1) }; const Ro = function (e, t) { for (let n = 0; n < e.length; n++)Object.keys(e[n]).length && t.id !== e[n].id && (e[n].selected = !1) }; class Uo extends Do { addTrack(e) { super.addTrack(e), this.queueChange_ || (this.queueChange_ = () => this.queueTrigger("change")), this.triggerSelectedlanguagechange || (this.triggerSelectedlanguagechange_ = () => this.trigger("selectedlanguagechange")), e.addEventListener("modechange", this.queueChange_); -1 === ["metadata", "chapters"].indexOf(e.kind) && e.addEventListener("modechange", this.triggerSelectedlanguagechange_) } removeTrack(e) { super.removeTrack(e), e.removeEventListener && (this.queueChange_ && e.removeEventListener("modechange", this.queueChange_), this.selectedlanguagechange_ && e.removeEventListener("modechange", this.triggerSelectedlanguagechange_)) } } class Bo { constructor(e) { Bo.prototype.setCues_.call(this, e), Object.defineProperty(this, "length", { get() { return this.length_ } }) } setCues_(e) { const t = this.length || 0; let n = 0; const i = e.length; this.cues_ = e, this.length_ = e.length; const r = function (e) { "" + e in this || Object.defineProperty(this, "" + e, { get() { return this.cues_[e] } }) }; if (t < i) for (n = t; n < i; n++)r.call(this, n) } getCueById(e) { let t = null; for (let n = 0, i = this.length; n < i; n++) { const i = this[n]; if (i.id === e) { t = i; break } } return t } } const Fo = { alternative: "alternative", captions: "captions", main: "main", sign: "sign", subtitles: "subtitles", commentary: "commentary" }, zo = { alternative: "alternative", descriptions: "descriptions", main: "main", "main-desc": "main-desc", translation: "translation", commentary: "commentary" }, Ho = { subtitles: "subtitles", captions: "captions", descriptions: "descriptions", chapters: "chapters", metadata: "metadata" }, Vo = { disabled: "disabled", hidden: "hidden", showing: "showing" }; class Wo extends Ja { constructor() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; super(); const t = { id: e.id || "vjs_track_" + ja(), kind: e.kind || "", language: e.language || "" }; let n = e.label || ""; for (const i in t) Object.defineProperty(this, i, { get: () => t[i], set() { } }); Object.defineProperty(this, "label", { get: () => n, set(e) { e !== n && (n = e, this.trigger("labelchange")) } }) } } const qo = function (e) { const t = ["protocol", "hostname", "port", "pathname", "search", "hash", "host"], n = Fn().createElement("a"); n.href = e; const i = {}; for (let r = 0; r < t.length; r++)i[t[r]] = n[t[r]]; return "http:" === i.protocol && (i.host = i.host.replace(/:80$/, "")), "https:" === i.protocol && (i.host = i.host.replace(/:443$/, "")), i.protocol || (i.protocol = Un().location.protocol), i.host || (i.host = Un().location.host), i }, Go = function (e) { if (!e.match(/^https?:\/\//)) { const t = Fn().createElement("a"); t.href = e, e = t.href } return e }, Xo = function (e) { if ("string" === typeof e) { const t = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/.exec(e); if (t) return t.pop().toLowerCase() } return "" }, Ko = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Un().location; const n = qo(e); return (":" === n.protocol ? t.protocol : n.protocol) + n.host !== t.protocol + t.host }; var $o = Object.freeze({ __proto__: null, parseUrl: qo, getAbsoluteURL: Go, getFileExtension: Xo, isCrossOrigin: Ko }); const Yo = function (e, t) { const n = new (Un().WebVTT.Parser)(Un(), Un().vttjs, Un().WebVTT.StringDecoder()), i = []; n.oncue = function (e) { t.addCue(e) }, n.onparsingerror = function (e) { i.push(e) }, n.onflush = function () { t.trigger({ type: "loadeddata", target: t }) }, n.parse(e), i.length > 0 && (Un().console && Un().console.groupCollapsed && Un().console.groupCollapsed("Text Track parsing errors for ".concat(t.src)), i.forEach((e => ms.error(e))), Un().console && Un().console.groupEnd && Un().console.groupEnd()), n.flush() }, Qo = function (e, t) { const n = { uri: e }, i = Ko(e); i && (n.cors = i); const r = "use-credentials" === t.tech_.crossOrigin(); r && (n.withCredentials = r), Gn()(n, Xa(this, (function (e, n, i) { if (e) return ms.error(e, n); t.loaded_ = !0, "function" !== typeof Un().WebVTT ? t.tech_ && t.tech_.any(["vttjsloaded", "vttjserror"], (e => { if ("vttjserror" !== e.type) return Yo(i, t); ms.error("vttjs failed to load, stopping trying to process ".concat(t.src)) })) : Yo(i, t) }))) }; class Jo extends Wo { constructor() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (!e.tech) throw new Error("A tech was not provided."); const t = ws(e, { kind: Ho[e.kind] || "subtitles", language: e.language || e.srclang || "" }); let n = Vo[t.mode] || "disabled"; const i = t.default; "metadata" !== t.kind && "chapters" !== t.kind || (n = "hidden"), super(t), this.tech_ = t.tech, this.cues_ = [], this.activeCues_ = [], this.preload_ = !1 !== this.tech_.preloadTextTracks; const r = new Bo(this.cues_), s = new Bo(this.activeCues_); let a = !1; this.timeupdateHandler = Xa(this, (function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.tech_.isDisposed() || (this.tech_.isReady_ ? (this.activeCues = this.activeCues, a && (this.trigger("cuechange"), a = !1), "timeupdate" !== e.type && (this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler))) : "timeupdate" !== e.type && (this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler))) })); this.tech_.one("dispose", (() => { this.stopTracking() })), "disabled" !== n && this.startTracking(), Object.defineProperties(this, { default: { get: () => i, set() { } }, mode: { get: () => n, set(e) { Vo[e] && n !== e && (n = e, this.preload_ || "disabled" === n || 0 !== this.cues.length || Qo(this.src, this), this.stopTracking(), "disabled" !== n && this.startTracking(), this.trigger("modechange")) } }, cues: { get() { return this.loaded_ ? r : null }, set() { } }, activeCues: { get() { if (!this.loaded_) return null; if (0 === this.cues.length) return s; const e = this.tech_.currentTime(), t = []; for (let n = 0, i = this.cues.length; n < i; n++) { const i = this.cues[n]; i.startTime <= e && i.endTime >= e && t.push(i) } if (a = !1, t.length !== this.activeCues_.length) a = !0; else for (let n = 0; n < t.length; n++)-1 === this.activeCues_.indexOf(t[n]) && (a = !0); return this.activeCues_ = t, s.setCues_(this.activeCues_), s }, set() { } } }), t.src ? (this.src = t.src, this.preload_ || (this.loaded_ = !0), (this.preload_ || "subtitles" !== t.kind && "captions" !== t.kind) && Qo(this.src, this)) : this.loaded_ = !0 } startTracking() { this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler), this.tech_.on("timeupdate", this.timeupdateHandler) } stopTracking() { this.rvf_ && (this.tech_.cancelVideoFrameCallback(this.rvf_), this.rvf_ = void 0), this.tech_.off("timeupdate", this.timeupdateHandler) } addCue(e) { let t = e; if (Un().vttjs && !(e instanceof Un().vttjs.VTTCue)) { t = new (Un().vttjs.VTTCue)(e.startTime, e.endTime, e.text); for (const n in e) n in t || (t[n] = e[n]); t.id = e.id, t.originalCue_ = e } const n = this.tech_.textTracks(); for (let i = 0; i < n.length; i++)n[i] !== this && n[i].removeCue(t); this.cues_.push(t), this.cues.setCues_(this.cues_) } removeCue(e) { let t = this.cues_.length; for (; t--;) { const n = this.cues_[t]; if (n === e || n.originalCue_ && n.originalCue_ === e) { this.cues_.splice(t, 1), this.cues.setCues_(this.cues_); break } } } } Jo.prototype.allowedEvents_ = { cuechange: "cuechange" }; class Zo extends Wo { constructor() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = ws(e, { kind: zo[e.kind] || "" }); super(t); let n = !1; Object.defineProperty(this, "enabled", { get: () => n, set(e) { "boolean" === typeof e && e !== n && (n = e, this.trigger("enabledchange")) } }), t.enabled && (this.enabled = t.enabled), this.loaded_ = !0 } } class el extends Wo { constructor() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = ws(e, { kind: Fo[e.kind] || "" }); super(t); let n = !1; Object.defineProperty(this, "selected", { get: () => n, set(e) { "boolean" === typeof e && e !== n && (n = e, this.trigger("selectedchange")) } }), t.selected && (this.selected = t.selected) } } class tl extends Ja { constructor() { let e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; super(); const n = new Jo(t); this.kind = n.kind, this.src = n.src, this.srclang = n.language, this.label = n.label, this.default = n.default, Object.defineProperties(this, { readyState: { get: () => e }, track: { get: () => n } }), e = tl.NONE, n.addEventListener("loadeddata", (() => { e = tl.LOADED, this.trigger({ type: "load", target: this }) })) } } tl.prototype.allowedEvents_ = { load: "load" }, tl.NONE = 0, tl.LOADING = 1, tl.LOADED = 2, tl.ERROR = 3; const nl = { audio: { ListClass: class extends Do { constructor() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; for (let t = e.length - 1; t >= 0; t--)if (e[t].enabled) { Mo(e, e[t]); break } super(e), this.changing_ = !1 } addTrack(e) { e.enabled && Mo(this, e), super.addTrack(e), e.addEventListener && (e.enabledChange_ = () => { this.changing_ || (this.changing_ = !0, Mo(this, e), this.changing_ = !1, this.trigger("change")) }, e.addEventListener("enabledchange", e.enabledChange_)) } removeTrack(e) { super.removeTrack(e), e.removeEventListener && e.enabledChange_ && (e.removeEventListener("enabledchange", e.enabledChange_), e.enabledChange_ = null) } }, TrackClass: Zo, capitalName: "Audio" }, video: { ListClass: class extends Do { constructor() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; for (let t = e.length - 1; t >= 0; t--)if (e[t].selected) { Ro(e, e[t]); break } super(e), this.changing_ = !1, Object.defineProperty(this, "selectedIndex", { get() { for (let e = 0; e < this.length; e++)if (this[e].selected) return e; return -1 }, set() { } }) } addTrack(e) { e.selected && Ro(this, e), super.addTrack(e), e.addEventListener && (e.selectedChange_ = () => { this.changing_ || (this.changing_ = !0, Ro(this, e), this.changing_ = !1, this.trigger("change")) }, e.addEventListener("selectedchange", e.selectedChange_)) } removeTrack(e) { super.removeTrack(e), e.removeEventListener && e.selectedChange_ && (e.removeEventListener("selectedchange", e.selectedChange_), e.selectedChange_ = null) } }, TrackClass: el, capitalName: "Video" }, text: { ListClass: Uo, TrackClass: Jo, capitalName: "Text" } }; Object.keys(nl).forEach((function (e) { nl[e].getterName = "".concat(e, "Tracks"), nl[e].privateName = "".concat(e, "Tracks_") })); const il = { remoteText: { ListClass: Uo, TrackClass: Jo, capitalName: "RemoteText", getterName: "remoteTextTracks", privateName: "remoteTextTracks_" }, remoteTextEl: { ListClass: class { constructor() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; this.trackElements_ = [], Object.defineProperty(this, "length", { get() { return this.trackElements_.length } }); for (let t = 0, n = e.length; t < n; t++)this.addTrackElement_(e[t]) } addTrackElement_(e) { const t = this.trackElements_.length; "" + t in this || Object.defineProperty(this, t, { get() { return this.trackElements_[t] } }), -1 === this.trackElements_.indexOf(e) && this.trackElements_.push(e) } getTrackElementByTrack_(e) { let t; for (let n = 0, i = this.trackElements_.length; n < i; n++)if (e === this.trackElements_[n].track) { t = this.trackElements_[n]; break } return t } removeTrackElement_(e) { for (let t = 0, n = this.trackElements_.length; t < n; t++)if (e === this.trackElements_[t]) { this.trackElements_[t].track && "function" === typeof this.trackElements_[t].track.off && this.trackElements_[t].track.off(), "function" === typeof this.trackElements_[t].off && this.trackElements_[t].off(), this.trackElements_.splice(t, 1); break } } }, TrackClass: tl, capitalName: "RemoteTextTrackEls", getterName: "remoteTextTrackEls", privateName: "remoteTextTrackEls_" } }, rl = Object.assign({}, nl, il); il.names = Object.keys(il), nl.names = Object.keys(nl), rl.names = [].concat(il.names).concat(nl.names); class sl extends go { constructor() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function () { }; e.reportTouchActivity = !1, super(null, e, t), this.onDurationChange_ = e => this.onDurationChange(e), this.trackProgress_ = e => this.trackProgress(e), this.trackCurrentTime_ = e => this.trackCurrentTime(e), this.stopTrackingCurrentTime_ = e => this.stopTrackingCurrentTime(e), this.disposeSourceHandler_ = e => this.disposeSourceHandler(e), this.queuedHanders_ = new Set, this.hasStarted_ = !1, this.on("playing", (function () { this.hasStarted_ = !0 })), this.on("loadstart", (function () { this.hasStarted_ = !1 })), rl.names.forEach((t => { const n = rl[t]; e && e[n.getterName] && (this[n.privateName] = e[n.getterName]) })), this.featuresProgressEvents || this.manualProgressOn(), this.featuresTimeupdateEvents || this.manualTimeUpdatesOn(), ["Text", "Audio", "Video"].forEach((t => { !1 === e["native".concat(t, "Tracks")] && (this["featuresNative".concat(t, "Tracks")] = !1) })), !1 === e.nativeCaptions || !1 === e.nativeTextTracks ? this.featuresNativeTextTracks = !1 : !0 !== e.nativeCaptions && !0 !== e.nativeTextTracks || (this.featuresNativeTextTracks = !0), this.featuresNativeTextTracks || this.emulateTextTracks(), this.preloadTextTracks = !1 !== e.preloadTextTracks, this.autoRemoteTextTracks_ = new rl.text.ListClass, this.initTrackListeners(), e.nativeControlsForTouch || this.emitTapEvents(), this.constructor && (this.name_ = this.constructor.name || "Unknown Tech") } triggerSourceset(e) { this.isReady_ || this.one("ready", (() => this.setTimeout((() => this.triggerSourceset(e)), 1))), this.trigger({ src: e, type: "sourceset" }) } manualProgressOn() { this.on("durationchange", this.onDurationChange_), this.manualProgress = !0, this.one("ready", this.trackProgress_) } manualProgressOff() { this.manualProgress = !1, this.stopTrackingProgress(), this.off("durationchange", this.onDurationChange_) } trackProgress(e) { this.stopTrackingProgress(), this.progressInterval = this.setInterval(Xa(this, (function () { const e = this.bufferedPercent(); this.bufferedPercent_ !== e && this.trigger("progress"), this.bufferedPercent_ = e, 1 === e && this.stopTrackingProgress() })), 500) } onDurationChange(e) { this.duration_ = this.duration() } buffered() { return bo(0, 0) } bufferedPercent() { return Eo(this.buffered(), this.duration_) } stopTrackingProgress() { this.clearInterval(this.progressInterval) } manualTimeUpdatesOn() { this.manualTimeUpdates = !0, this.on("play", this.trackCurrentTime_), this.on("pause", this.stopTrackingCurrentTime_) } manualTimeUpdatesOff() { this.manualTimeUpdates = !1, this.stopTrackingCurrentTime(), this.off("play", this.trackCurrentTime_), this.off("pause", this.stopTrackingCurrentTime_) } trackCurrentTime() { this.currentTimeInterval && this.stopTrackingCurrentTime(), this.currentTimeInterval = this.setInterval((function () { this.trigger({ type: "timeupdate", target: this, manuallyTriggered: !0 }) }), 250) } stopTrackingCurrentTime() { this.clearInterval(this.currentTimeInterval), this.trigger({ type: "timeupdate", target: this, manuallyTriggered: !0 }) } dispose() { this.clearTracks(nl.names), this.manualProgress && this.manualProgressOff(), this.manualTimeUpdates && this.manualTimeUpdatesOff(), super.dispose() } clearTracks(e) { (e = [].concat(e)).forEach((e => { const t = this["".concat(e, "Tracks")]() || []; let n = t.length; for (; n--;) { const i = t[n]; "text" === e && this.removeRemoteTextTrack(i), t.removeTrack(i) } })) } cleanupAutoTextTracks() { const e = this.autoRemoteTextTracks_ || []; let t = e.length; for (; t--;) { const n = e[t]; this.removeRemoteTextTrack(n) } } reset() { } crossOrigin() { } setCrossOrigin() { } error(e) { return void 0 !== e && (this.error_ = new Co(e), this.trigger("error")), this.error_ } played() { return this.hasStarted_ ? bo(0, 0) : bo() } play() { } setScrubbing(e) { } scrubbing() { } setCurrentTime(e) { this.manualTimeUpdates && this.trigger({ type: "timeupdate", target: this, manuallyTriggered: !0 }) } initTrackListeners() { nl.names.forEach((e => { const t = nl[e], n = () => { this.trigger("".concat(e, "trackchange")) }, i = this[t.getterName](); i.addEventListener("removetrack", n), i.addEventListener("addtrack", n), this.on("dispose", (() => { i.removeEventListener("removetrack", n), i.removeEventListener("addtrack", n) })) })) } addWebVttScript_() { if (!Un().WebVTT) if (Fn().body.contains(this.el())) { if (!this.options_["vtt.js"] && Ss(Kn()) && Object.keys(Kn()).length > 0) return void this.trigger("vttjsloaded"); const e = Fn().createElement("script"); e.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js", e.onload = () => { this.trigger("vttjsloaded") }, e.onerror = () => { this.trigger("vttjserror") }, this.on("dispose", (() => { e.onload = null, e.onerror = null })), Un().WebVTT = !0, this.el().parentNode.appendChild(e) } else this.ready(this.addWebVttScript_) } emulateTextTracks() { const e = this.textTracks(), t = this.remoteTextTracks(), n = t => e.addTrack(t.track), i = t => e.removeTrack(t.track); t.on("addtrack", n), t.on("removetrack", i), this.addWebVttScript_(); const r = () => this.trigger("texttrackchange"), s = () => { r(); for (let t = 0; t < e.length; t++) { const n = e[t]; n.removeEventListener("cuechange", r), "showing" === n.mode && n.addEventListener("cuechange", r) } }; s(), e.addEventListener("change", s), e.addEventListener("addtrack", s), e.addEventListener("removetrack", s), this.on("dispose", (function () { t.off("addtrack", n), t.off("removetrack", i), e.removeEventListener("change", s), e.removeEventListener("addtrack", s), e.removeEventListener("removetrack", s); for (let t = 0; t < e.length; t++) { e[t].removeEventListener("cuechange", r) } })) } addTextTrack(e, t, n) { if (!e) throw new Error("TextTrack kind is required but was not provided"); return function (e, t, n, i) { let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}; const s = e.textTracks(); r.kind = t, n && (r.label = n), i && (r.language = i), r.tech = e; const a = new rl.text.TrackClass(r); return s.addTrack(a), a }(this, e, t, n) } createRemoteTextTrack(e) { const t = ws(e, { tech: this }); return new il.remoteTextEl.TrackClass(t) } addRemoteTextTrack() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0; const n = this.createRemoteTextTrack(e); return "boolean" !== typeof t && (t = !1), this.remoteTextTrackEls().addTrackElement_(n), this.remoteTextTracks().addTrack(n.track), !1 === t && this.ready((() => this.autoRemoteTextTracks_.addTrack(n.track))), n } removeRemoteTextTrack(e) { const t = this.remoteTextTrackEls().getTrackElementByTrack_(e); this.remoteTextTrackEls().removeTrackElement_(t), this.remoteTextTracks().removeTrack(e), this.autoRemoteTextTracks_.removeTrack(e) } getVideoPlaybackQuality() { return {} } requestPictureInPicture() { return Promise.reject() } disablePictureInPicture() { return !0 } setDisablePictureInPicture() { } requestVideoFrameCallback(e) { const t = ja(); return !this.isReady_ || this.paused() ? (this.queuedHanders_.add(t), this.one("playing", (() => { this.queuedHanders_.has(t) && (this.queuedHanders_.delete(t), e()) }))) : this.requestNamedAnimationFrame(t, e), t } cancelVideoFrameCallback(e) { this.queuedHanders_.has(e) ? this.queuedHanders_.delete(e) : this.cancelNamedAnimationFrame(e) } setPoster() { } playsinline() { } setPlaysinline() { } overrideNativeAudioTracks(e) { } overrideNativeVideoTracks(e) { } canPlayType(e) { return "" } static canPlayType(e) { return "" } static canPlaySource(e, t) { return sl.canPlayType(e.type) } static isTech(e) { return e.prototype instanceof sl || e instanceof sl || e === sl } static registerTech(e, t) { if (sl.techs_ || (sl.techs_ = {}), !sl.isTech(t)) throw new Error("Tech ".concat(e, " must be a Tech")); if (!sl.canPlayType) throw new Error("Techs must have a static canPlayType method on them"); if (!sl.canPlaySource) throw new Error("Techs must have a static canPlaySource method on them"); return e = po(e), sl.techs_[e] = t, sl.techs_[ho(e)] = t, "Tech" !== e && sl.defaultTechOrder_.push(e), t } static getTech(e) { if (e) return sl.techs_ && sl.techs_[e] ? sl.techs_[e] : (e = po(e), Un() && Un().videojs && Un().videojs[e] ? (ms.warn("The ".concat(e, " tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)")), Un().videojs[e]) : void 0) } } rl.names.forEach((function (e) { const t = rl[e]; sl.prototype[t.getterName] = function () { return this[t.privateName] = this[t.privateName] || new t.ListClass, this[t.privateName] } })), sl.prototype.featuresVolumeControl = !0, sl.prototype.featuresMuteControl = !0, sl.prototype.featuresFullscreenResize = !1, sl.prototype.featuresPlaybackRate = !1, sl.prototype.featuresProgressEvents = !1, sl.prototype.featuresSourceset = !1, sl.prototype.featuresTimeupdateEvents = !1, sl.prototype.featuresNativeTextTracks = !1, sl.prototype.featuresVideoFrameCallback = !1, sl.withSourceHandlers = function (e) { e.registerSourceHandler = function (t, n) { let i = e.sourceHandlers; i || (i = e.sourceHandlers = []), void 0 === n && (n = i.length), i.splice(n, 0, t) }, e.canPlayType = function (t) { const n = e.sourceHandlers || []; let i; for (let e = 0; e < n.length; e++)if (i = n[e].canPlayType(t), i) return i; return "" }, e.selectSourceHandler = function (t, n) { const i = e.sourceHandlers || []; let r; for (let e = 0; e < i.length; e++)if (r = i[e].canHandleSource(t, n), r) return i[e]; return null }, e.canPlaySource = function (t, n) { const i = e.selectSourceHandler(t, n); return i ? i.canHandleSource(t, n) : "" };["seekable", "seeking", "duration"].forEach((function (e) { const t = this[e]; "function" === typeof t && (this[e] = function () { return this.sourceHandler_ && this.sourceHandler_[e] ? this.sourceHandler_[e].apply(this.sourceHandler_, arguments) : t.apply(this, arguments) }) }), e.prototype), e.prototype.setSource = function (t) { let n = e.selectSourceHandler(t, this.options_); n || (e.nativeSourceHandler ? n = e.nativeSourceHandler : ms.error("No source handler found for the current source.")), this.disposeSourceHandler(), this.off("dispose", this.disposeSourceHandler_), n !== e.nativeSourceHandler && (this.currentSource_ = t), this.sourceHandler_ = n.handleSource(t, this, this.options_), this.one("dispose", this.disposeSourceHandler_) }, e.prototype.disposeSourceHandler = function () { this.currentSource_ && (this.clearTracks(["audio", "video"]), this.currentSource_ = null), this.cleanupAutoTextTracks(), this.sourceHandler_ && (this.sourceHandler_.dispose && this.sourceHandler_.dispose(), this.sourceHandler_ = null) } }, go.registerComponent("Tech", sl), sl.registerTech("Tech", sl), sl.defaultTechOrder_ = []; const al = {}, ol = {}, ll = {}; function cl(e, t, n) { e.setTimeout((() => ml(t, al[t.type], n, e)), 1) } function ul(e, t, n) { let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; const r = "call" + po(n), s = e.reduce(fl(r), i), a = s === ll, o = a ? null : t[n](s); return function (e, t, n, i) { for (let r = e.length - 1; r >= 0; r--) { const s = e[r]; s[t] && s[t](i, n) } }(e, n, o, a), o } const dl = { buffered: 1, currentTime: 1, duration: 1, muted: 1, played: 1, paused: 1, seekable: 1, volume: 1, ended: 1 }, hl = { setCurrentTime: 1, setMuted: 1, setVolume: 1 }, pl = { play: 1, pause: 1 }; function fl(e) { return (t, n) => t === ll ? ll : n[e] ? n[e](t) : t } function ml() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n = arguments.length > 2 ? arguments[2] : void 0, i = arguments.length > 3 ? arguments[3] : void 0, r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], s = arguments.length > 5 && void 0 !== arguments[5] && arguments[5]; const [a, ...o] = t; if ("string" === typeof a) ml(e, al[a], n, i, r, s); else if (a) { const t = function (e, t) { const n = ol[e.id()]; let i = null; if (void 0 === n || null === n) return i = t(e), ol[e.id()] = [[t, i]], i; for (let r = 0; r < n.length; r++) { const [e, s] = n[r]; e === t && (i = s) } return null === i && (i = t(e), n.push([t, i])), i }(i, a); if (!t.setSource) return r.push(t), ml(e, o, n, i, r, s); t.setSource(Object.assign({}, e), (function (a, l) { if (a) return ml(e, o, n, i, r, s); r.push(t), ml(l, e.type === l.type ? o : al[l.type], n, i, r, s) })) } else o.length ? ml(e, o, n, i, r, s) : s ? n(e, r) : ml(e, al["*"], n, i, r, !0) } const gl = { opus: "video/ogg", ogv: "video/ogg", mp4: "video/mp4", mov: "video/mp4", m4v: "video/mp4", mkv: "video/x-matroska", m4a: "audio/mp4", mp3: "audio/mpeg", aac: "audio/aac", caf: "audio/x-caf", flac: "audio/flac", oga: "audio/ogg", wav: "audio/wav", m3u8: "application/x-mpegURL", mpd: "application/dash+xml", jpg: "image/jpeg", jpeg: "image/jpeg", gif: "image/gif", png: "image/png", svg: "image/svg+xml", webp: "image/webp" }, yl = function () { const e = Xo(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""); return gl[e.toLowerCase()] || "" }, vl = function (e) { if (Array.isArray(e)) { let t = []; e.forEach((function (e) { e = vl(e), Array.isArray(e) ? t = t.concat(e) : Ts(e) && t.push(e) })), e = t } else e = "string" === typeof e && e.trim() ? [bl({ src: e })] : Ts(e) && "string" === typeof e.src && e.src && e.src.trim() ? [bl(e)] : []; return e }; function bl(e) { if (!e.type) { const t = yl(e.src); t && (e.type = t) } return e } go.registerComponent("MediaLoader", class extends go { constructor(e, t, n) { if (super(e, ws({ createEl: !1 }, t), n), t.playerOptions.sources && 0 !== t.playerOptions.sources.length) e.src(t.playerOptions.sources); else for (let i = 0, r = t.playerOptions.techOrder; i < r.length; i++) { const t = po(r[i]); let n = sl.getTech(t); if (t || (n = go.getComponent(t)), n && n.isSupported()) { e.loadTech_(t); break } } } }); class _l extends go { constructor(e, t) { super(e, t), this.options_.controlText && this.controlText(this.options_.controlText), this.handleMouseOver_ = e => this.handleMouseOver(e), this.handleMouseOut_ = e => this.handleMouseOut(e), this.handleClick_ = e => this.handleClick(e), this.handleKeyDown_ = e => this.handleKeyDown(e), this.emitTapEvents(), this.enable() } createEl() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "div", t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; t = Object.assign({ className: this.buildCSSClass(), tabIndex: 0 }, t), "button" === e && ms.error("Creating a ClickableComponent with an HTML element of ".concat(e, " is not supported; use a Button instead.")), n = Object.assign({ role: "button" }, n), this.tabIndex_ = t.tabIndex; const i = Qs(e, t, n); return i.appendChild(Qs("span", { className: "vjs-icon-placeholder" }, { "aria-hidden": !0 })), this.createControlTextEl(i), i } dispose() { this.controlTextEl_ = null, super.dispose() } createControlTextEl(e) { return this.controlTextEl_ = Qs("span", { className: "vjs-control-text" }, { "aria-live": "polite" }), e && e.appendChild(this.controlTextEl_), this.controlText(this.controlText_, e), this.controlTextEl_ } controlText(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.el(); if (void 0 === e) return this.controlText_ || "Need Text"; const n = this.localize(e); this.controlText_ = e, Js(this.controlTextEl_, n), this.nonIconControl || this.player_.options_.noUITitleAttributes || t.setAttribute("title", n) } buildCSSClass() { return "vjs-control vjs-button ".concat(super.buildCSSClass()) } enable() { this.enabled_ || (this.enabled_ = !0, this.removeClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "false"), "undefined" !== typeof this.tabIndex_ && this.el_.setAttribute("tabIndex", this.tabIndex_), this.on(["tap", "click"], this.handleClick_), this.on("keydown", this.handleKeyDown_)) } disable() { this.enabled_ = !1, this.addClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "true"), "undefined" !== typeof this.tabIndex_ && this.el_.removeAttribute("tabIndex"), this.off("mouseover", this.handleMouseOver_), this.off("mouseout", this.handleMouseOut_), this.off(["tap", "click"], this.handleClick_), this.off("keydown", this.handleKeyDown_) } handleLanguagechange() { this.controlText(this.controlText_) } handleClick(e) { this.options_.clickHandler && this.options_.clickHandler.call(this, arguments) } handleKeyDown(e) { Hn().isEventKey(e, "Space") || Hn().isEventKey(e, "Enter") ? (e.preventDefault(), e.stopPropagation(), this.trigger("click")) : super.handleKeyDown(e) } } go.registerComponent("ClickableComponent", _l); class Tl extends _l { constructor(e, t) { super(e, t), this.update(), this.update_ = e => this.update(e), e.on("posterchange", this.update_) } dispose() { this.player().off("posterchange", this.update_), super.dispose() } createEl() { return Qs("div", { className: "vjs-poster" }) } crossOrigin(e) { if ("undefined" === typeof e) return this.$("img") ? this.$("img").crossOrigin : this.player_.tech_ && this.player_.tech_.isReady_ ? this.player_.crossOrigin() : this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null; null === e || "anonymous" === e || "use-credentials" === e ? this.$("img") && (this.$("img").crossOrigin = e) : this.player_.log.warn('crossOrigin must be null,  "anonymous" or "use-credentials", given "'.concat(e, '"')) } update(e) { const t = this.player().poster(); this.setSrc(t), t ? this.show() : this.hide() } setSrc(e) { e ? (this.$("img") || this.el_.appendChild(Qs("picture", { className: "vjs-poster", tabIndex: -1 }, {}, Qs("img", { loading: "lazy", crossOrigin: this.crossOrigin() }, { alt: "" }))), this.$("img").src = e) : this.el_.textContent = "" } handleClick(e) { this.player_.controls() && (this.player_.tech(!0) && this.player_.tech(!0).focus(), this.player_.paused() ? Io(this.player_.play()) : this.player_.pause()) } } Tl.prototype.crossorigin = Tl.prototype.crossOrigin, go.registerComponent("PosterImage", Tl); const Sl = "#222", wl = "#ccc", xl = { monospace: "monospace", sansSerif: "sans-serif", serif: "serif", monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace', monospaceSerif: '"Courier New", monospace', proportionalSansSerif: "sans-serif", proportionalSerif: "serif", casual: '"Comic Sans MS", Impact, fantasy', script: '"Monotype Corsiva", cursive', smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif' }; function kl(e, t) { let n; if (4 === e.length) n = e[1] + e[1] + e[2] + e[2] + e[3] + e[3]; else { if (7 !== e.length) throw new Error("Invalid color code provided, " + e + "; must be formatted as e.g. #f0e or #f604e2."); n = e.slice(1) } return "rgba(" + parseInt(n.slice(0, 2), 16) + "," + parseInt(n.slice(2, 4), 16) + "," + parseInt(n.slice(4, 6), 16) + "," + t + ")" } function El(e, t, n) { try { e.style[t] = n } catch (i) { return } } go.registerComponent("TextTrackDisplay", class extends go { constructor(e, t, n) { super(e, t, n); const i = e => this.updateDisplay(e); e.on("loadstart", (e => this.toggleDisplay(e))), e.on("texttrackchange", i), e.on("loadedmetadata", (e => this.preselectTrack(e))), e.ready(Xa(this, (function () { if (e.tech_ && e.tech_.featuresNativeTextTracks) return void this.hide(); e.on("fullscreenchange", i), e.on("playerresize", i); const t = Un().screen.orientation || Un(), n = Un().screen.orientation ? "change" : "orientationchange"; t.addEventListener(n, i), e.on("dispose", (() => t.removeEventListener(n, i))); const r = this.options_.playerOptions.tracks || []; for (let e = 0; e < r.length; e++)this.player_.addRemoteTextTrack(r[e], !0); this.preselectTrack() }))) } preselectTrack() { const e = { captions: 1, subtitles: 1 }, t = this.player_.textTracks(), n = this.player_.cache_.selectedLanguage; let i, r, s; for (let a = 0; a < t.length; a++) { const o = t[a]; n && n.enabled && n.language && n.language === o.language && o.kind in e ? o.kind === n.kind ? s = o : s || (s = o) : n && !n.enabled ? (s = null, i = null, r = null) : o.default && ("descriptions" !== o.kind || i ? o.kind in e && !r && (r = o) : i = o) } s ? s.mode = "showing" : r ? r.mode = "showing" : i && (i.mode = "showing") } toggleDisplay() { this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks ? this.hide() : this.show() } createEl() { return super.createEl("div", { className: "vjs-text-track-display" }, { translate: "yes", "aria-live": "off", "aria-atomic": "true" }) } clearDisplay() { "function" === typeof Un().WebVTT && Un().WebVTT.processCues(Un(), [], this.el_) } updateDisplay() { const e = this.player_.textTracks(), t = this.options_.allowMultipleShowingTracks; if (this.clearDisplay(), t) { const t = []; for (let n = 0; n < e.length; ++n) { const i = e[n]; "showing" === i.mode && t.push(i) } return void this.updateForTrack(t) } let n = null, i = null, r = e.length; for (; r--;) { const t = e[r]; "showing" === t.mode && ("descriptions" === t.kind ? n = t : i = t) } i ? ("off" !== this.getAttribute("aria-live") && this.setAttribute("aria-live", "off"), this.updateForTrack(i)) : n && ("assertive" !== this.getAttribute("aria-live") && this.setAttribute("aria-live", "assertive"), this.updateForTrack(n)) } updateDisplayState(e) { const t = this.player_.textTrackSettings.getValues(), n = e.activeCues; let i = n.length; for (; i--;) { const e = n[i]; if (!e) continue; const r = e.displayState; if (t.color && (r.firstChild.style.color = t.color), t.textOpacity && El(r.firstChild, "color", kl(t.color || "#fff", t.textOpacity)), t.backgroundColor && (r.firstChild.style.backgroundColor = t.backgroundColor), t.backgroundOpacity && El(r.firstChild, "backgroundColor", kl(t.backgroundColor || "#000", t.backgroundOpacity)), t.windowColor && (t.windowOpacity ? El(r, "backgroundColor", kl(t.windowColor, t.windowOpacity)) : r.style.backgroundColor = t.windowColor), t.edgeStyle && ("dropshadow" === t.edgeStyle ? r.firstChild.style.textShadow = "2px 2px 3px ".concat(Sl, ", 2px 2px 4px ").concat(Sl, ", 2px 2px 5px ").concat(Sl) : "raised" === t.edgeStyle ? r.firstChild.style.textShadow = "1px 1px ".concat(Sl, ", 2px 2px ").concat(Sl, ", 3px 3px ").concat(Sl) : "depressed" === t.edgeStyle ? r.firstChild.style.textShadow = "1px 1px ".concat(wl, ", 0 1px ").concat(wl, ", -1px -1px ").concat(Sl, ", 0 -1px ").concat(Sl) : "uniform" === t.edgeStyle && (r.firstChild.style.textShadow = "0 0 4px ".concat(Sl, ", 0 0 4px ").concat(Sl, ", 0 0 4px ").concat(Sl, ", 0 0 4px ").concat(Sl))), t.fontPercent && 1 !== t.fontPercent) { const e = Un().parseFloat(r.style.fontSize); r.style.fontSize = e * t.fontPercent + "px", r.style.height = "auto", r.style.top = "auto" } t.fontFamily && "default" !== t.fontFamily && ("small-caps" === t.fontFamily ? r.firstChild.style.fontVariant = "small-caps" : r.firstChild.style.fontFamily = xl[t.fontFamily]) } } updateForTrack(e) { if (Array.isArray(e) || (e = [e]), "function" !== typeof Un().WebVTT || e.every((e => !e.activeCues))) return; const t = []; for (let n = 0; n < e.length; ++n) { const i = e[n]; for (let e = 0; e < i.activeCues.length; ++e)t.push(i.activeCues[e]) } Un().WebVTT.processCues(Un(), t, this.el_); for (let n = 0; n < e.length; ++n) { const t = e[n]; for (let e = 0; e < t.activeCues.length; ++e) { const i = t.activeCues[e].displayState; ta(i, "vjs-text-track-cue", "vjs-text-track-cue-" + (t.language ? t.language : n)), t.language && oa(i, "lang", t.language) } this.player_.textTrackSettings && this.updateDisplayState(t) } } }); go.registerComponent("LoadingSpinner", class extends go { createEl() { const e = this.player_.isAudio(), t = this.localize(e ? "Audio Player" : "Video Player"), n = Qs("span", { className: "vjs-control-text", textContent: this.localize("{1} is loading.", [t]) }), i = super.createEl("div", { className: "vjs-loading-spinner", dir: "ltr" }); return i.appendChild(n), i } }); class Cl extends _l { createEl(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; e = "button", t = Object.assign({ className: this.buildCSSClass() }, t), n = Object.assign({ type: "button" }, n); const i = Qs(e, t, n); return i.appendChild(Qs("span", { className: "vjs-icon-placeholder" }, { "aria-hidden": !0 })), this.createControlTextEl(i), i } addChild(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = this.constructor.name; return ms.warn("Adding an actionable (user controllable) child to a Button (".concat(n, ") is not supported; use a ClickableComponent instead.")), go.prototype.addChild.call(this, e, t) } enable() { super.enable(), this.el_.removeAttribute("disabled") } disable() { super.disable(), this.el_.setAttribute("disabled", "disabled") } handleKeyDown(e) { Hn().isEventKey(e, "Space") || Hn().isEventKey(e, "Enter") ? e.stopPropagation() : super.handleKeyDown(e) } } go.registerComponent("Button", Cl); class Pl extends Cl { constructor(e, t) { super(e, t), this.mouseused_ = !1, this.on("mousedown", (e => this.handleMouseDown(e))) } buildCSSClass() { return "vjs-big-play-button" } handleClick(e) { const t = this.player_.play(); if (this.mouseused_ && e.clientX && e.clientY) return Io(t), void (this.player_.tech(!0) && this.player_.tech(!0).focus()); const n = this.player_.getChild("controlBar"), i = n && n.getChild("playToggle"); if (!i) return void this.player_.tech(!0).focus(); const r = () => i.focus(); Po(t) ? t.then(r, (() => { })) : this.setTimeout(r, 1) } handleKeyDown(e) { this.mouseused_ = !1, super.handleKeyDown(e) } handleMouseDown(e) { this.mouseused_ = !0 } } Pl.prototype.controlText_ = "Play Video", go.registerComponent("BigPlayButton", Pl); go.registerComponent("CloseButton", class extends Cl { constructor(e, t) { super(e, t), this.controlText(t && t.controlText || this.localize("Close")) } buildCSSClass() { return "vjs-close-button ".concat(super.buildCSSClass()) } handleClick(e) { this.trigger({ type: "close", bubbles: !1 }) } handleKeyDown(e) { Hn().isEventKey(e, "Esc") ? (e.preventDefault(), e.stopPropagation(), this.trigger("click")) : super.handleKeyDown(e) } }); class Il extends Cl { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; super(e, t), t.replay = void 0 === t.replay || t.replay, this.on(e, "play", (e => this.handlePlay(e))), this.on(e, "pause", (e => this.handlePause(e))), t.replay && this.on(e, "ended", (e => this.handleEnded(e))) } buildCSSClass() { return "vjs-play-control ".concat(super.buildCSSClass()) } handleClick(e) { this.player_.paused() ? Io(this.player_.play()) : this.player_.pause() } handleSeeked(e) { this.removeClass("vjs-ended"), this.player_.paused() ? this.handlePause(e) : this.handlePlay(e) } handlePlay(e) { this.removeClass("vjs-ended", "vjs-paused"), this.addClass("vjs-playing"), this.controlText("Pause") } handlePause(e) { this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.controlText("Play") } handleEnded(e) { this.removeClass("vjs-playing"), this.addClass("vjs-ended"), this.controlText("Replay"), this.one(this.player_, "seeked", (e => this.handleSeeked(e))) } } Il.prototype.controlText_ = "Play", go.registerComponent("PlayToggle", Il); class Ll extends go { constructor(e, t) { super(e, t), this.on(e, ["timeupdate", "ended"], (e => this.updateContent(e))), this.updateTextNode_() } createEl() { const e = this.buildCSSClass(), t = super.createEl("div", { className: "".concat(e, " vjs-time-control vjs-control") }), n = Qs("span", { className: "vjs-control-text", textContent: "".concat(this.localize(this.labelText_), "\xa0") }, { role: "presentation" }); return t.appendChild(n), this.contentEl_ = Qs("span", { className: "".concat(e, "-display") }, { "aria-live": "off", role: "presentation" }), t.appendChild(this.contentEl_), t } dispose() { this.contentEl_ = null, this.textNode_ = null, super.dispose() } updateTextNode_() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; e = xo(e), this.formattedTime_ !== e && (this.formattedTime_ = e, this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", (() => { if (!this.contentEl_) return; let e = this.textNode_; e && this.contentEl_.firstChild !== e && (e = null, ms.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.")), this.textNode_ = Fn().createTextNode(this.formattedTime_), this.textNode_ && (e ? this.contentEl_.replaceChild(this.textNode_, e) : this.contentEl_.appendChild(this.textNode_)) }))) } updateContent(e) { } } Ll.prototype.labelText_ = "Time", Ll.prototype.controlText_ = "Time", go.registerComponent("TimeDisplay", Ll); class Ol extends Ll { buildCSSClass() { return "vjs-current-time" } updateContent(e) { let t; t = this.player_.ended() ? this.player_.duration() : this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime(), this.updateTextNode_(t) } } Ol.prototype.labelText_ = "Current Time", Ol.prototype.controlText_ = "Current Time", go.registerComponent("CurrentTimeDisplay", Ol); class Al extends Ll { constructor(e, t) { super(e, t); const n = e => this.updateContent(e); this.on(e, "durationchange", n), this.on(e, "loadstart", n), this.on(e, "loadedmetadata", n) } buildCSSClass() { return "vjs-duration" } updateContent(e) { const t = this.player_.duration(); this.updateTextNode_(t) } } Al.prototype.labelText_ = "Duration", Al.prototype.controlText_ = "Duration", go.registerComponent("DurationDisplay", Al); go.registerComponent("TimeDivider", class extends go { createEl() { const e = super.createEl("div", { className: "vjs-time-control vjs-time-divider" }, { "aria-hidden": !0 }), t = super.createEl("div"), n = super.createEl("span", { textContent: "/" }); return t.appendChild(n), e.appendChild(t), e } }); class Nl extends Ll { constructor(e, t) { super(e, t), this.on(e, "durationchange", (e => this.updateContent(e))) } buildCSSClass() { return "vjs-remaining-time" } createEl() { const e = super.createEl(); return !1 !== this.options_.displayNegative && e.insertBefore(Qs("span", {}, { "aria-hidden": !0 }, "-"), this.contentEl_), e } updateContent(e) { if ("number" !== typeof this.player_.duration()) return; let t; t = this.player_.ended() ? 0 : this.player_.remainingTimeDisplay ? this.player_.remainingTimeDisplay() : this.player_.remainingTime(), this.updateTextNode_(t) } } Nl.prototype.labelText_ = "Remaining Time", Nl.prototype.controlText_ = "Remaining Time", go.registerComponent("RemainingTimeDisplay", Nl); go.registerComponent("LiveDisplay", class extends go { constructor(e, t) { super(e, t), this.updateShowing(), this.on(this.player(), "durationchange", (e => this.updateShowing(e))) } createEl() { const e = super.createEl("div", { className: "vjs-live-control vjs-control" }); return this.contentEl_ = Qs("div", { className: "vjs-live-display" }, { "aria-live": "off" }), this.contentEl_.appendChild(Qs("span", { className: "vjs-control-text", textContent: "".concat(this.localize("Stream Type"), "\xa0") })), this.contentEl_.appendChild(Fn().createTextNode(this.localize("LIVE"))), e.appendChild(this.contentEl_), e } dispose() { this.contentEl_ = null, super.dispose() } updateShowing(e) { this.player().duration() === 1 / 0 ? this.show() : this.hide() } }); class jl extends Cl { constructor(e, t) { super(e, t), this.updateLiveEdgeStatus(), this.player_.liveTracker && (this.updateLiveEdgeStatusHandler_ = e => this.updateLiveEdgeStatus(e), this.on(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_)) } createEl() { const e = super.createEl("button", { className: "vjs-seek-to-live-control vjs-control" }); return this.textEl_ = Qs("span", { className: "vjs-seek-to-live-text", textContent: this.localize("LIVE") }, { "aria-hidden": "true" }), e.appendChild(this.textEl_), e } updateLiveEdgeStatus() { !this.player_.liveTracker || this.player_.liveTracker.atLiveEdge() ? (this.setAttribute("aria-disabled", !0), this.addClass("vjs-at-live-edge"), this.controlText("Seek to live, currently playing live")) : (this.setAttribute("aria-disabled", !1), this.removeClass("vjs-at-live-edge"), this.controlText("Seek to live, currently behind live")) } handleClick() { this.player_.liveTracker.seekToLiveEdge() } dispose() { this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_), this.textEl_ = null, super.dispose() } } function Dl(e, t, n) { return e = Number(e), Math.min(n, Math.max(t, isNaN(e) ? t : e)) } jl.prototype.controlText_ = "Seek to live, currently playing live", go.registerComponent("SeekToLive", jl); var Ml = Object.freeze({ __proto__: null, clamp: Dl }); class Rl extends go { constructor(e, t) { super(e, t), this.handleMouseDown_ = e => this.handleMouseDown(e), this.handleMouseUp_ = e => this.handleMouseUp(e), this.handleKeyDown_ = e => this.handleKeyDown(e), this.handleClick_ = e => this.handleClick(e), this.handleMouseMove_ = e => this.handleMouseMove(e), this.update_ = e => this.update(e), this.bar = this.getChild(this.options_.barName), this.vertical(!!this.options_.vertical), this.enable() } enabled() { return this.enabled_ } enable() { this.enabled() || (this.on("mousedown", this.handleMouseDown_), this.on("touchstart", this.handleMouseDown_), this.on("keydown", this.handleKeyDown_), this.on("click", this.handleClick_), this.on(this.player_, "controlsvisible", this.update), this.playerEvent && this.on(this.player_, this.playerEvent, this.update), this.removeClass("disabled"), this.setAttribute("tabindex", 0), this.enabled_ = !0) } disable() { if (!this.enabled()) return; const e = this.bar.el_.ownerDocument; this.off("mousedown", this.handleMouseDown_), this.off("touchstart", this.handleMouseDown_), this.off("keydown", this.handleKeyDown_), this.off("click", this.handleClick_), this.off(this.player_, "controlsvisible", this.update_), this.off(e, "mousemove", this.handleMouseMove_), this.off(e, "mouseup", this.handleMouseUp_), this.off(e, "touchmove", this.handleMouseMove_), this.off(e, "touchend", this.handleMouseUp_), this.removeAttribute("tabindex"), this.addClass("disabled"), this.playerEvent && this.off(this.player_, this.playerEvent, this.update), this.enabled_ = !1 } createEl(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return t.className = t.className + " vjs-slider", t = Object.assign({ tabIndex: 0 }, t), n = Object.assign({ role: "slider", "aria-valuenow": 0, "aria-valuemin": 0, "aria-valuemax": 100 }, n), super.createEl(e, t, n) } handleMouseDown(e) { const t = this.bar.el_.ownerDocument; "mousedown" === e.type && e.preventDefault(), "touchstart" !== e.type || Ns || e.preventDefault(), ca(), this.addClass("vjs-sliding"), this.trigger("slideractive"), this.on(t, "mousemove", this.handleMouseMove_), this.on(t, "mouseup", this.handleMouseUp_), this.on(t, "touchmove", this.handleMouseMove_), this.on(t, "touchend", this.handleMouseUp_), this.handleMouseMove(e, !0) } handleMouseMove(e) { } handleMouseUp(e) { const t = this.bar.el_.ownerDocument; ua(), this.removeClass("vjs-sliding"), this.trigger("sliderinactive"), this.off(t, "mousemove", this.handleMouseMove_), this.off(t, "mouseup", this.handleMouseUp_), this.off(t, "touchmove", this.handleMouseMove_), this.off(t, "touchend", this.handleMouseUp_), this.update() } update() { if (!this.el_ || !this.bar) return; const e = this.getProgress(); return e === this.progress_ || (this.progress_ = e, this.requestNamedAnimationFrame("Slider#update", (() => { const t = this.vertical() ? "height" : "width"; this.bar.el().style[t] = (100 * e).toFixed(2) + "%" }))), e } getProgress() { return Number(Dl(this.getPercent(), 0, 1).toFixed(4)) } calculateDistance(e) { const t = pa(this.el_, e); return this.vertical() ? t.y : t.x } handleKeyDown(e) { Hn().isEventKey(e, "Left") || Hn().isEventKey(e, "Down") ? (e.preventDefault(), e.stopPropagation(), this.stepBack()) : Hn().isEventKey(e, "Right") || Hn().isEventKey(e, "Up") ? (e.preventDefault(), e.stopPropagation(), this.stepForward()) : super.handleKeyDown(e) } handleClick(e) { e.stopPropagation(), e.preventDefault() } vertical(e) { if (void 0 === e) return this.vertical_ || !1; this.vertical_ = !!e, this.vertical_ ? this.addClass("vjs-slider-vertical") : this.addClass("vjs-slider-horizontal") } } go.registerComponent("Slider", Rl); const Ul = (e, t) => Dl(e / t * 100, 0, 100).toFixed(2) + "%"; go.registerComponent("LoadProgressBar", class extends go { constructor(e, t) { super(e, t), this.partEls_ = [], this.on(e, "progress", (e => this.update(e))) } createEl() { const e = super.createEl("div", { className: "vjs-load-progress" }), t = Qs("span", { className: "vjs-control-text" }), n = Qs("span", { textContent: this.localize("Loaded") }), i = Fn().createTextNode(": "); return this.percentageEl_ = Qs("span", { className: "vjs-control-text-loaded-percentage", textContent: "0%" }), e.appendChild(t), t.appendChild(n), t.appendChild(i), t.appendChild(this.percentageEl_), e } dispose() { this.partEls_ = null, this.percentageEl_ = null, super.dispose() } update(e) { this.requestNamedAnimationFrame("LoadProgressBar#update", (() => { const e = this.player_.liveTracker, t = this.player_.buffered(), n = e && e.isLive() ? e.seekableEnd() : this.player_.duration(), i = this.player_.bufferedEnd(), r = this.partEls_, s = Ul(i, n); this.percent_ !== s && (this.el_.style.width = s, Js(this.percentageEl_, s), this.percent_ = s); for (let a = 0; a < t.length; a++) { const e = t.start(a), n = t.end(a); let s = r[a]; s || (s = this.el_.appendChild(Qs()), r[a] = s), s.dataset.start === e && s.dataset.end === n || (s.dataset.start = e, s.dataset.end = n, s.style.left = Ul(e, i), s.style.width = Ul(n - e, i)) } for (let a = r.length; a > t.length; a--)this.el_.removeChild(r[a - 1]); r.length = t.length })) } }); go.registerComponent("TimeTooltip", class extends go { constructor(e, t) { super(e, t), this.update = Ka(Xa(this, this.update), Ga) } createEl() { return super.createEl("div", { className: "vjs-time-tooltip" }, { "aria-hidden": "true" }) } update(e, t, n) { const i = ha(this.el_), r = da(this.player_.el()), s = e.width * t; if (!r || !i) return; const a = e.left - r.left + s, o = e.width - s + (r.right - e.right); let l = i.width / 2; a < l ? l += l - a : o < l && (l = o), l < 0 ? l = 0 : l > i.width && (l = i.width), l = Math.round(l), this.el_.style.right = "-".concat(l, "px"), this.write(n) } write(e) { Js(this.el_, e) } updateTime(e, t, n, i) { this.requestNamedAnimationFrame("TimeTooltip#updateTime", (() => { let r; const s = this.player_.duration(); if (this.player_.liveTracker && this.player_.liveTracker.isLive()) { const e = this.player_.liveTracker.liveWindow(), n = e - t * e; r = (n < 1 ? "" : "-") + xo(n, e) } else r = xo(n, s); this.update(e, t, r), i && i() })) } }); class Bl extends go { constructor(e, t) { super(e, t), this.update = Ka(Xa(this, this.update), Ga) } createEl() { return super.createEl("div", { className: "vjs-play-progress vjs-slider-bar" }, { "aria-hidden": "true" }) } update(e, t) { const n = this.getChild("timeTooltip"); if (!n) return; const i = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime(); n.updateTime(e, t, i) } } Bl.prototype.options_ = { children: [] }, Vs || Is || Bl.prototype.options_.children.push("timeTooltip"), go.registerComponent("PlayProgressBar", Bl); class Fl extends go { constructor(e, t) { super(e, t), this.update = Ka(Xa(this, this.update), Ga) } createEl() { return super.createEl("div", { className: "vjs-mouse-display" }) } update(e, t) { const n = t * this.player_.duration(); this.getChild("timeTooltip").updateTime(e, t, n, (() => { this.el_.style.left = "".concat(e.width * t, "px") })) } } Fl.prototype.options_ = { children: ["timeTooltip"] }, go.registerComponent("MouseTimeDisplay", Fl); class zl extends Rl { constructor(e, t) { super(e, t), this.setEventHandlers_() } setEventHandlers_() { this.update_ = Xa(this, this.update), this.update = Ka(this.update_, Ga), this.on(this.player_, ["ended", "durationchange", "timeupdate"], this.update), this.player_.liveTracker && this.on(this.player_.liveTracker, "liveedgechange", this.update), this.updateInterval = null, this.enableIntervalHandler_ = e => this.enableInterval_(e), this.disableIntervalHandler_ = e => this.disableInterval_(e), this.on(this.player_, ["playing"], this.enableIntervalHandler_), this.on(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_), "hidden" in Fn() && "visibilityState" in Fn() && this.on(Fn(), "visibilitychange", this.toggleVisibility_) } toggleVisibility_(e) { "hidden" === Fn().visibilityState ? (this.cancelNamedAnimationFrame("SeekBar#update"), this.cancelNamedAnimationFrame("Slider#update"), this.disableInterval_(e)) : (this.player_.ended() || this.player_.paused() || this.enableInterval_(), this.update()) } enableInterval_() { this.updateInterval || (this.updateInterval = this.setInterval(this.update, Ga)) } disableInterval_(e) { this.player_.liveTracker && this.player_.liveTracker.isLive() && e && "ended" !== e.type || this.updateInterval && (this.clearInterval(this.updateInterval), this.updateInterval = null) } createEl() { return super.createEl("div", { className: "vjs-progress-holder" }, { "aria-label": this.localize("Progress Bar") }) } update(e) { if ("hidden" === Fn().visibilityState) return; const t = super.update(); return this.requestNamedAnimationFrame("SeekBar#update", (() => { const e = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_(), n = this.player_.liveTracker; let i = this.player_.duration(); n && n.isLive() && (i = this.player_.liveTracker.liveCurrentTime()), this.percent_ !== t && (this.el_.setAttribute("aria-valuenow", (100 * t).toFixed(2)), this.percent_ = t), this.currentTime_ === e && this.duration_ === i || (this.el_.setAttribute("aria-valuetext", this.localize("progress bar timing: currentTime={1} duration={2}", [xo(e, i), xo(i, i)], "{1} of {2}")), this.currentTime_ = e, this.duration_ = i), this.bar && this.bar.update(da(this.el()), this.getProgress()) })), t } userSeek_(e) { this.player_.liveTracker && this.player_.liveTracker.isLive() && this.player_.liveTracker.nextSeekedFromUser(), this.player_.currentTime(e) } getCurrentTime_() { return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime() } getPercent() { const e = this.getCurrentTime_(); let t; const n = this.player_.liveTracker; return n && n.isLive() ? (t = (e - n.seekableStart()) / n.liveWindow(), n.atLiveEdge() && (t = 1)) : t = e / this.player_.duration(), t } handleMouseDown(e) { ba(e) && (e.stopPropagation(), this.videoWasPlaying = !this.player_.paused(), this.player_.pause(), super.handleMouseDown(e)) } handleMouseMove(e) { let t, n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (!ba(e)) return; n || this.player_.scrubbing() || this.player_.scrubbing(!0); const i = this.calculateDistance(e), r = this.player_.liveTracker; if (r && r.isLive()) { if (i >= .99) return void r.seekToLiveEdge(); const e = r.seekableStart(), n = r.liveCurrentTime(); if (t = e + i * r.liveWindow(), t >= n && (t = n), t <= e && (t = e + .1), t === 1 / 0) return } else t = i * this.player_.duration(), t === this.player_.duration() && (t -= .1); this.userSeek_(t) } enable() { super.enable(); const e = this.getChild("mouseTimeDisplay"); e && e.show() } disable() { super.disable(); const e = this.getChild("mouseTimeDisplay"); e && e.hide() } handleMouseUp(e) { super.handleMouseUp(e), e && e.stopPropagation(), this.player_.scrubbing(!1), this.player_.trigger({ type: "timeupdate", target: this, manuallyTriggered: !0 }), this.videoWasPlaying ? Io(this.player_.play()) : this.update_() } stepForward() { this.userSeek_(this.player_.currentTime() + 5) } stepBack() { this.userSeek_(this.player_.currentTime() - 5) } handleAction(e) { this.player_.paused() ? this.player_.play() : this.player_.pause() } handleKeyDown(e) { const t = this.player_.liveTracker; if (Hn().isEventKey(e, "Space") || Hn().isEventKey(e, "Enter")) e.preventDefault(), e.stopPropagation(), this.handleAction(e); else if (Hn().isEventKey(e, "Home")) e.preventDefault(), e.stopPropagation(), this.userSeek_(0); else if (Hn().isEventKey(e, "End")) e.preventDefault(), e.stopPropagation(), t && t.isLive() ? this.userSeek_(t.liveCurrentTime()) : this.userSeek_(this.player_.duration()); else if (/^[0-9]$/.test(Hn()(e))) { e.preventDefault(), e.stopPropagation(); const n = 10 * (Hn().codes[Hn()(e)] - Hn().codes[0]) / 100; t && t.isLive() ? this.userSeek_(t.seekableStart() + t.liveWindow() * n) : this.userSeek_(this.player_.duration() * n) } else Hn().isEventKey(e, "PgDn") ? (e.preventDefault(), e.stopPropagation(), this.userSeek_(this.player_.currentTime() - 60)) : Hn().isEventKey(e, "PgUp") ? (e.preventDefault(), e.stopPropagation(), this.userSeek_(this.player_.currentTime() + 60)) : super.handleKeyDown(e) } dispose() { this.disableInterval_(), this.off(this.player_, ["ended", "durationchange", "timeupdate"], this.update), this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.update), this.off(this.player_, ["playing"], this.enableIntervalHandler_), this.off(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_), "hidden" in Fn() && "visibilityState" in Fn() && this.off(Fn(), "visibilitychange", this.toggleVisibility_), super.dispose() } } zl.prototype.options_ = { children: ["loadProgressBar", "playProgressBar"], barName: "playProgressBar" }, Vs || Is || zl.prototype.options_.children.splice(1, 0, "mouseTimeDisplay"), go.registerComponent("SeekBar", zl); class Hl extends go { constructor(e, t) { super(e, t), this.handleMouseMove = Ka(Xa(this, this.handleMouseMove), Ga), this.throttledHandleMouseSeek = Ka(Xa(this, this.handleMouseSeek), Ga), this.handleMouseUpHandler_ = e => this.handleMouseUp(e), this.handleMouseDownHandler_ = e => this.handleMouseDown(e), this.enable() } createEl() { return super.createEl("div", { className: "vjs-progress-control vjs-control" }) } handleMouseMove(e) { const t = this.getChild("seekBar"); if (!t) return; const n = t.getChild("playProgressBar"), i = t.getChild("mouseTimeDisplay"); if (!n && !i) return; const r = t.el(), s = ha(r); let a = pa(r, e).x; a = Dl(a, 0, 1), i && i.update(s, a), n && n.update(s, t.getProgress()) } handleMouseSeek(e) { const t = this.getChild("seekBar"); t && t.handleMouseMove(e) } enabled() { return this.enabled_ } disable() { if (this.children().forEach((e => e.disable && e.disable())), this.enabled() && (this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.off(this.el_, "mousemove", this.handleMouseMove), this.removeListenersAddedOnMousedownAndTouchstart(), this.addClass("disabled"), this.enabled_ = !1, this.player_.scrubbing())) { const e = this.getChild("seekBar"); this.player_.scrubbing(!1), e.videoWasPlaying && Io(this.player_.play()) } } enable() { this.children().forEach((e => e.enable && e.enable())), this.enabled() || (this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.on(this.el_, "mousemove", this.handleMouseMove), this.removeClass("disabled"), this.enabled_ = !0) } removeListenersAddedOnMousedownAndTouchstart() { const e = this.el_.ownerDocument; this.off(e, "mousemove", this.throttledHandleMouseSeek), this.off(e, "touchmove", this.throttledHandleMouseSeek), this.off(e, "mouseup", this.handleMouseUpHandler_), this.off(e, "touchend", this.handleMouseUpHandler_) } handleMouseDown(e) { const t = this.el_.ownerDocument, n = this.getChild("seekBar"); n && n.handleMouseDown(e), this.on(t, "mousemove", this.throttledHandleMouseSeek), this.on(t, "touchmove", this.throttledHandleMouseSeek), this.on(t, "mouseup", this.handleMouseUpHandler_), this.on(t, "touchend", this.handleMouseUpHandler_) } handleMouseUp(e) { const t = this.getChild("seekBar"); t && t.handleMouseUp(e), this.removeListenersAddedOnMousedownAndTouchstart() } } Hl.prototype.options_ = { children: ["seekBar"] }, go.registerComponent("ProgressControl", Hl); class Vl extends Cl { constructor(e, t) { super(e, t), this.on(e, ["enterpictureinpicture", "leavepictureinpicture"], (e => this.handlePictureInPictureChange(e))), this.on(e, ["disablepictureinpicturechanged", "loadedmetadata"], (e => this.handlePictureInPictureEnabledChange(e))), this.on(e, ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"], (() => { "audio" === e.currentType().substring(0, 5) || e.audioPosterMode() || e.audioOnlyMode() ? (e.isInPictureInPicture() && e.exitPictureInPicture(), this.hide()) : this.show() })), this.disable() } buildCSSClass() { return "vjs-picture-in-picture-control ".concat(super.buildCSSClass()) } handlePictureInPictureEnabledChange() { Fn().pictureInPictureEnabled && !1 === this.player_.disablePictureInPicture() ? this.enable() : this.disable() } handlePictureInPictureChange(e) { this.player_.isInPictureInPicture() ? this.controlText("Exit Picture-in-Picture") : this.controlText("Picture-in-Picture"), this.handlePictureInPictureEnabledChange() } handleClick(e) { this.player_.isInPictureInPicture() ? this.player_.exitPictureInPicture() : this.player_.requestPictureInPicture() } } Vl.prototype.controlText_ = "Picture-in-Picture", go.registerComponent("PictureInPictureToggle", Vl); class Wl extends Cl { constructor(e, t) { super(e, t), this.on(e, "fullscreenchange", (e => this.handleFullscreenChange(e))), !1 === Fn()[e.fsApi_.fullscreenEnabled] && this.disable() } buildCSSClass() { return "vjs-fullscreen-control ".concat(super.buildCSSClass()) } handleFullscreenChange(e) { this.player_.isFullscreen() ? this.controlText("Exit Fullscreen") : this.controlText("Fullscreen") } handleClick(e) { this.player_.isFullscreen() ? this.player_.exitFullscreen() : this.player_.requestFullscreen() } } Wl.prototype.controlText_ = "Fullscreen", go.registerComponent("FullscreenToggle", Wl); go.registerComponent("VolumeLevel", class extends go { createEl() { const e = super.createEl("div", { className: "vjs-volume-level" }); return e.appendChild(super.createEl("span", { className: "vjs-control-text" })), e } }); go.registerComponent("VolumeLevelTooltip", class extends go { constructor(e, t) { super(e, t), this.update = Ka(Xa(this, this.update), Ga) } createEl() { return super.createEl("div", { className: "vjs-volume-tooltip" }, { "aria-hidden": "true" }) } update(e, t, n, i) { if (!n) { const n = da(this.el_), i = da(this.player_.el()), r = e.width * t; if (!i || !n) return; const s = e.left - i.left + r, a = e.width - r + (i.right - e.right); let o = n.width / 2; s < o ? o += o - s : a < o && (o = a), o < 0 ? o = 0 : o > n.width && (o = n.width), this.el_.style.right = "-".concat(o, "px") } this.write("".concat(i, "%")) } write(e) { Js(this.el_, e) } updateVolume(e, t, n, i, r) { this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", (() => { this.update(e, t, n, i.toFixed(0)), r && r() })) } }); class ql extends go { constructor(e, t) { super(e, t), this.update = Ka(Xa(this, this.update), Ga) } createEl() { return super.createEl("div", { className: "vjs-mouse-display" }) } update(e, t, n) { const i = 100 * t; this.getChild("volumeLevelTooltip").updateVolume(e, t, n, i, (() => { n ? this.el_.style.bottom = "".concat(e.height * t, "px") : this.el_.style.left = "".concat(e.width * t, "px") })) } } ql.prototype.options_ = { children: ["volumeLevelTooltip"] }, go.registerComponent("MouseVolumeLevelDisplay", ql); class Gl extends Rl { constructor(e, t) { super(e, t), this.on("slideractive", (e => this.updateLastVolume_(e))), this.on(e, "volumechange", (e => this.updateARIAAttributes(e))), e.ready((() => this.updateARIAAttributes())) } createEl() { return super.createEl("div", { className: "vjs-volume-bar vjs-slider-bar" }, { "aria-label": this.localize("Volume Level"), "aria-live": "polite" }) } handleMouseDown(e) { ba(e) && super.handleMouseDown(e) } handleMouseMove(e) { const t = this.getChild("mouseVolumeLevelDisplay"); if (t) { const n = this.el(), i = da(n), r = this.vertical(); let s = pa(n, e); s = r ? s.y : s.x, s = Dl(s, 0, 1), t.update(i, s, r) } ba(e) && (this.checkMuted(), this.player_.volume(this.calculateDistance(e))) } checkMuted() { this.player_.muted() && this.player_.muted(!1) } getPercent() { return this.player_.muted() ? 0 : this.player_.volume() } stepForward() { this.checkMuted(), this.player_.volume(this.player_.volume() + .1) } stepBack() { this.checkMuted(), this.player_.volume(this.player_.volume() - .1) } updateARIAAttributes(e) { const t = this.player_.muted() ? 0 : this.volumeAsPercentage_(); this.el_.setAttribute("aria-valuenow", t), this.el_.setAttribute("aria-valuetext", t + "%") } volumeAsPercentage_() { return Math.round(100 * this.player_.volume()) } updateLastVolume_() { const e = this.player_.volume(); this.one("sliderinactive", (() => { 0 === this.player_.volume() && this.player_.lastVolume_(e) })) } } Gl.prototype.options_ = { children: ["volumeLevel"], barName: "volumeLevel" }, Vs || Is || Gl.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay"), Gl.prototype.playerEvent = "volumechange", go.registerComponent("VolumeBar", Gl); class Xl extends go { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; t.vertical = t.vertical || !1, ("undefined" === typeof t.volumeBar || Ss(t.volumeBar)) && (t.volumeBar = t.volumeBar || {}, t.volumeBar.vertical = t.vertical), super(e, t), function (e, t) { t.tech_ && !t.tech_.featuresVolumeControl && e.addClass("vjs-hidden"), e.on(t, "loadstart", (function () { t.tech_.featuresVolumeControl ? e.removeClass("vjs-hidden") : e.addClass("vjs-hidden") })) }(this, e), this.throttledHandleMouseMove = Ka(Xa(this, this.handleMouseMove), Ga), this.handleMouseUpHandler_ = e => this.handleMouseUp(e), this.on("mousedown", (e => this.handleMouseDown(e))), this.on("touchstart", (e => this.handleMouseDown(e))), this.on("mousemove", (e => this.handleMouseMove(e))), this.on(this.volumeBar, ["focus", "slideractive"], (() => { this.volumeBar.addClass("vjs-slider-active"), this.addClass("vjs-slider-active"), this.trigger("slideractive") })), this.on(this.volumeBar, ["blur", "sliderinactive"], (() => { this.volumeBar.removeClass("vjs-slider-active"), this.removeClass("vjs-slider-active"), this.trigger("sliderinactive") })) } createEl() { let e = "vjs-volume-horizontal"; return this.options_.vertical && (e = "vjs-volume-vertical"), super.createEl("div", { className: "vjs-volume-control vjs-control ".concat(e) }) } handleMouseDown(e) { const t = this.el_.ownerDocument; this.on(t, "mousemove", this.throttledHandleMouseMove), this.on(t, "touchmove", this.throttledHandleMouseMove), this.on(t, "mouseup", this.handleMouseUpHandler_), this.on(t, "touchend", this.handleMouseUpHandler_) } handleMouseUp(e) { const t = this.el_.ownerDocument; this.off(t, "mousemove", this.throttledHandleMouseMove), this.off(t, "touchmove", this.throttledHandleMouseMove), this.off(t, "mouseup", this.handleMouseUpHandler_), this.off(t, "touchend", this.handleMouseUpHandler_) } handleMouseMove(e) { this.volumeBar.handleMouseMove(e) } } Xl.prototype.options_ = { children: ["volumeBar"] }, go.registerComponent("VolumeControl", Xl); class Kl extends Cl { constructor(e, t) { super(e, t), function (e, t) { t.tech_ && !t.tech_.featuresMuteControl && e.addClass("vjs-hidden"), e.on(t, "loadstart", (function () { t.tech_.featuresMuteControl ? e.removeClass("vjs-hidden") : e.addClass("vjs-hidden") })) }(this, e), this.on(e, ["loadstart", "volumechange"], (e => this.update(e))) } buildCSSClass() { return "vjs-mute-control ".concat(super.buildCSSClass()) } handleClick(e) { const t = this.player_.volume(), n = this.player_.lastVolume_(); if (0 === t) { const e = n < .1 ? .1 : n; this.player_.volume(e), this.player_.muted(!1) } else this.player_.muted(!this.player_.muted()) } update(e) { this.updateIcon_(), this.updateControlText_() } updateIcon_() { const e = this.player_.volume(); let t = 3; Vs && this.player_.tech_ && this.player_.tech_.el_ && this.player_.muted(this.player_.tech_.el_.muted), 0 === e || this.player_.muted() ? t = 0 : e < .33 ? t = 1 : e < .67 && (t = 2), na(this.el_, [0, 1, 2, 3].reduce(((e, t) => e + "".concat(t ? " " : "", "vjs-vol-").concat(t)), "")), ta(this.el_, "vjs-vol-".concat(t)) } updateControlText_() { const e = this.player_.muted() || 0 === this.player_.volume() ? "Unmute" : "Mute"; this.controlText() !== e && this.controlText(e) } } Kl.prototype.controlText_ = "Mute", go.registerComponent("MuteToggle", Kl); class $l extends go { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; "undefined" !== typeof t.inline ? t.inline = t.inline : t.inline = !0, ("undefined" === typeof t.volumeControl || Ss(t.volumeControl)) && (t.volumeControl = t.volumeControl || {}, t.volumeControl.vertical = !t.inline), super(e, t), this.handleKeyPressHandler_ = e => this.handleKeyPress(e), this.on(e, ["loadstart"], (e => this.volumePanelState_(e))), this.on(this.muteToggle, "keyup", (e => this.handleKeyPress(e))), this.on(this.volumeControl, "keyup", (e => this.handleVolumeControlKeyUp(e))), this.on("keydown", (e => this.handleKeyPress(e))), this.on("mouseover", (e => this.handleMouseOver(e))), this.on("mouseout", (e => this.handleMouseOut(e))), this.on(this.volumeControl, ["slideractive"], this.sliderActive_), this.on(this.volumeControl, ["sliderinactive"], this.sliderInactive_) } sliderActive_() { this.addClass("vjs-slider-active") } sliderInactive_() { this.removeClass("vjs-slider-active") } volumePanelState_() { this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-hidden"), this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-mute-toggle-only") } createEl() { let e = "vjs-volume-panel-horizontal"; return this.options_.inline || (e = "vjs-volume-panel-vertical"), super.createEl("div", { className: "vjs-volume-panel vjs-control ".concat(e) }) } dispose() { this.handleMouseOut(), super.dispose() } handleVolumeControlKeyUp(e) { Hn().isEventKey(e, "Esc") && this.muteToggle.focus() } handleMouseOver(e) { this.addClass("vjs-hover"), Fa(Fn(), "keyup", this.handleKeyPressHandler_) } handleMouseOut(e) { this.removeClass("vjs-hover"), za(Fn(), "keyup", this.handleKeyPressHandler_) } handleKeyPress(e) { Hn().isEventKey(e, "Esc") && this.handleMouseOut() } } $l.prototype.options_ = { children: ["muteToggle", "volumeControl"] }, go.registerComponent("VolumePanel", $l); go.registerComponent("SkipForward", class extends Cl { constructor(e, t) { super(e, t), this.validOptions = [5, 10, 30], this.skipTime = this.getSkipForwardTime(), this.skipTime && this.validOptions.includes(this.skipTime) ? (this.controlText(this.localize("Skip forward {1} seconds", [this.skipTime])), this.show()) : this.hide() } getSkipForwardTime() { const e = this.options_.playerOptions; return e.controlBar && e.controlBar.skipButtons && e.controlBar.skipButtons.forward } buildCSSClass() { return "vjs-skip-forward-".concat(this.getSkipForwardTime(), " ").concat(super.buildCSSClass()) } handleClick(e) { const t = this.player_.currentTime(), n = this.player_.liveTracker, i = n && n.isLive() ? n.seekableEnd() : this.player_.duration(); let r; r = t + this.skipTime <= i ? t + this.skipTime : i, this.player_.currentTime(r) } }); class Yl extends Cl { constructor(e, t) { super(e, t), this.validOptions = [5, 10, 30], this.skipTime = this.getSkipBackwardTime(), this.skipTime && this.validOptions.includes(this.skipTime) ? (this.controlText(this.localize("Skip backward {1} seconds", [this.skipTime])), this.show()) : this.hide() } getSkipBackwardTime() { const e = this.options_.playerOptions; return e.controlBar && e.controlBar.skipButtons && e.controlBar.skipButtons.backward } buildCSSClass() { return "vjs-skip-backward-".concat(this.getSkipBackwardTime(), " ").concat(super.buildCSSClass()) } handleClick(e) { const t = this.player_.currentTime(), n = this.player_.liveTracker, i = n && n.isLive() && n.seekableStart(); let r; r = i && t - this.skipTime <= i ? i : t >= this.skipTime ? t - this.skipTime : 0, this.player_.currentTime(r) } } Yl.prototype.controlText_ = "Skip Backward", go.registerComponent("SkipBackward", Yl); class Ql extends go { constructor(e, t) { super(e, t), t && (this.menuButton_ = t.menuButton), this.focusedChild_ = -1, this.on("keydown", (e => this.handleKeyDown(e))), this.boundHandleBlur_ = e => this.handleBlur(e), this.boundHandleTapClick_ = e => this.handleTapClick(e) } addEventListenerForItem(e) { e instanceof go && (this.on(e, "blur", this.boundHandleBlur_), this.on(e, ["tap", "click"], this.boundHandleTapClick_)) } removeEventListenerForItem(e) { e instanceof go && (this.off(e, "blur", this.boundHandleBlur_), this.off(e, ["tap", "click"], this.boundHandleTapClick_)) } removeChild(e) { "string" === typeof e && (e = this.getChild(e)), this.removeEventListenerForItem(e), super.removeChild(e) } addItem(e) { const t = this.addChild(e); t && this.addEventListenerForItem(t) } createEl() { const e = this.options_.contentElType || "ul"; this.contentEl_ = Qs(e, { className: "vjs-menu-content" }), this.contentEl_.setAttribute("role", "menu"); const t = super.createEl("div", { append: this.contentEl_, className: "vjs-menu" }); return t.appendChild(this.contentEl_), Fa(t, "click", (function (e) { e.preventDefault(), e.stopImmediatePropagation() })), t } dispose() { this.contentEl_ = null, this.boundHandleBlur_ = null, this.boundHandleTapClick_ = null, super.dispose() } handleBlur(e) { const t = e.relatedTarget || Fn().activeElement; if (!this.children().some((e => e.el() === t))) { const e = this.menuButton_; e && e.buttonPressed_ && t !== e.el().firstChild && e.unpressButton() } } handleTapClick(e) { if (this.menuButton_) { this.menuButton_.unpressButton(); const t = this.children(); if (!Array.isArray(t)) return; const n = t.filter((t => t.el() === e.target))[0]; if (!n) return; "CaptionSettingsMenuItem" !== n.name() && this.menuButton_.focus() } } handleKeyDown(e) { Hn().isEventKey(e, "Left") || Hn().isEventKey(e, "Down") ? (e.preventDefault(), e.stopPropagation(), this.stepForward()) : (Hn().isEventKey(e, "Right") || Hn().isEventKey(e, "Up")) && (e.preventDefault(), e.stopPropagation(), this.stepBack()) } stepForward() { let e = 0; void 0 !== this.focusedChild_ && (e = this.focusedChild_ + 1), this.focus(e) } stepBack() { let e = 0; void 0 !== this.focusedChild_ && (e = this.focusedChild_ - 1), this.focus(e) } focus() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const t = this.children().slice(); t.length && t[0].hasClass("vjs-menu-title") && t.shift(), t.length > 0 && (e < 0 ? e = 0 : e >= t.length && (e = t.length - 1), this.focusedChild_ = e, t[e].el_.focus()) } } go.registerComponent("Menu", Ql); class Jl extends go { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; super(e, t), this.menuButton_ = new Cl(e, t), this.menuButton_.controlText(this.controlText_), this.menuButton_.el_.setAttribute("aria-haspopup", "true"); const n = Cl.prototype.buildCSSClass(); this.menuButton_.el_.className = this.buildCSSClass() + " " + n, this.menuButton_.removeClass("vjs-control"), this.addChild(this.menuButton_), this.update(), this.enabled_ = !0; const i = e => this.handleClick(e); this.handleMenuKeyUp_ = e => this.handleMenuKeyUp(e), this.on(this.menuButton_, "tap", i), this.on(this.menuButton_, "click", i), this.on(this.menuButton_, "keydown", (e => this.handleKeyDown(e))), this.on(this.menuButton_, "mouseenter", (() => { this.addClass("vjs-hover"), this.menu.show(), Fa(Fn(), "keyup", this.handleMenuKeyUp_) })), this.on("mouseleave", (e => this.handleMouseLeave(e))), this.on("keydown", (e => this.handleSubmenuKeyDown(e))) } update() { const e = this.createMenu(); this.menu && (this.menu.dispose(), this.removeChild(this.menu)), this.menu = e, this.addChild(e), this.buttonPressed_ = !1, this.menuButton_.el_.setAttribute("aria-expanded", "false"), this.items && this.items.length <= this.hideThreshold_ ? (this.hide(), this.menu.contentEl_.removeAttribute("role")) : (this.show(), this.menu.contentEl_.setAttribute("role", "menu")) } createMenu() { const e = new Ql(this.player_, { menuButton: this }); if (this.hideThreshold_ = 0, this.options_.title) { const t = Qs("li", { className: "vjs-menu-title", textContent: po(this.options_.title), tabIndex: -1 }), n = new go(this.player_, { el: t }); e.addItem(n) } if (this.items = this.createItems(), this.items) for (let t = 0; t < this.items.length; t++)e.addItem(this.items[t]); return e } createItems() { } createEl() { return super.createEl("div", { className: this.buildWrapperCSSClass() }, {}) } buildWrapperCSSClass() { let e = "vjs-menu-button"; !0 === this.options_.inline ? e += "-inline" : e += "-popup"; const t = Cl.prototype.buildCSSClass(); return "vjs-menu-button ".concat(e, " ").concat(t, " ").concat(super.buildCSSClass()) } buildCSSClass() { let e = "vjs-menu-button"; return !0 === this.options_.inline ? e += "-inline" : e += "-popup", "vjs-menu-button ".concat(e, " ").concat(super.buildCSSClass()) } controlText(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.menuButton_.el(); return this.menuButton_.controlText(e, t) } dispose() { this.handleMouseLeave(), super.dispose() } handleClick(e) { this.buttonPressed_ ? this.unpressButton() : this.pressButton() } handleMouseLeave(e) { this.removeClass("vjs-hover"), za(Fn(), "keyup", this.handleMenuKeyUp_) } focus() { this.menuButton_.focus() } blur() { this.menuButton_.blur() } handleKeyDown(e) { Hn().isEventKey(e, "Esc") || Hn().isEventKey(e, "Tab") ? (this.buttonPressed_ && this.unpressButton(), Hn().isEventKey(e, "Tab") || (e.preventDefault(), this.menuButton_.focus())) : (Hn().isEventKey(e, "Up") || Hn().isEventKey(e, "Down")) && (this.buttonPressed_ || (e.preventDefault(), this.pressButton())) } handleMenuKeyUp(e) { (Hn().isEventKey(e, "Esc") || Hn().isEventKey(e, "Tab")) && this.removeClass("vjs-hover") } handleSubmenuKeyPress(e) { this.handleSubmenuKeyDown(e) } handleSubmenuKeyDown(e) { (Hn().isEventKey(e, "Esc") || Hn().isEventKey(e, "Tab")) && (this.buttonPressed_ && this.unpressButton(), Hn().isEventKey(e, "Tab") || (e.preventDefault(), this.menuButton_.focus())) } pressButton() { if (this.enabled_) { if (this.buttonPressed_ = !0, this.menu.show(), this.menu.lockShowing(), this.menuButton_.el_.setAttribute("aria-expanded", "true"), Vs && $s()) return; this.menu.focus() } } unpressButton() { this.enabled_ && (this.buttonPressed_ = !1, this.menu.unlockShowing(), this.menu.hide(), this.menuButton_.el_.setAttribute("aria-expanded", "false")) } disable() { this.unpressButton(), this.enabled_ = !1, this.addClass("vjs-disabled"), this.menuButton_.disable() } enable() { this.enabled_ = !0, this.removeClass("vjs-disabled"), this.menuButton_.enable() } } go.registerComponent("MenuButton", Jl); class Zl extends Jl { constructor(e, t) { const n = t.tracks; if (super(e, t), this.items.length <= 1 && this.hide(), !n) return; const i = Xa(this, this.update); n.addEventListener("removetrack", i), n.addEventListener("addtrack", i), n.addEventListener("labelchange", i), this.player_.on("ready", i), this.player_.on("dispose", (function () { n.removeEventListener("removetrack", i), n.removeEventListener("addtrack", i), n.removeEventListener("labelchange", i) })) } } go.registerComponent("TrackButton", Zl); const ec = ["Tab", "Esc", "Up", "Down", "Right", "Left"]; class tc extends _l { constructor(e, t) { super(e, t), this.selectable = t.selectable, this.isSelected_ = t.selected || !1, this.multiSelectable = t.multiSelectable, this.selected(this.isSelected_), this.selectable ? this.multiSelectable ? this.el_.setAttribute("role", "menuitemcheckbox") : this.el_.setAttribute("role", "menuitemradio") : this.el_.setAttribute("role", "menuitem") } createEl(e, t, n) { this.nonIconControl = !0; const i = super.createEl("li", Object.assign({ className: "vjs-menu-item", tabIndex: -1 }, t), n); return i.replaceChild(Qs("span", { className: "vjs-menu-item-text", textContent: this.localize(this.options_.label) }), i.querySelector(".vjs-icon-placeholder")), i } handleKeyDown(e) { ec.some((t => Hn().isEventKey(e, t))) || super.handleKeyDown(e) } handleClick(e) { this.selected(!0) } selected(e) { this.selectable && (e ? (this.addClass("vjs-selected"), this.el_.setAttribute("aria-checked", "true"), this.controlText(", selected"), this.isSelected_ = !0) : (this.removeClass("vjs-selected"), this.el_.setAttribute("aria-checked", "false"), this.controlText(""), this.isSelected_ = !1)) } } go.registerComponent("MenuItem", tc); class nc extends tc { constructor(e, t) { var n; const i = t.track, r = e.textTracks(); t.label = i.label || i.language || "Unknown", t.selected = "showing" === i.mode, super(e, t), n = this, this.track = i, this.kinds = (t.kinds || [t.kind || this.track.kind]).filter(Boolean); const s = function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; n.handleTracksChange.apply(n, t) }, a = function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; n.handleSelectedLanguageChange.apply(n, t) }; if (e.on(["loadstart", "texttrackchange"], s), r.addEventListener("change", s), r.addEventListener("selectedlanguagechange", a), this.on("dispose", (function () { e.off(["loadstart", "texttrackchange"], s), r.removeEventListener("change", s), r.removeEventListener("selectedlanguagechange", a) })), void 0 === r.onchange) { let e; this.on(["tap", "click"], (function () { if ("object" !== typeof Un().Event) try { e = new (Un().Event)("change") } catch (t) { } e || (e = Fn().createEvent("Event"), e.initEvent("change", !0, !0)), r.dispatchEvent(e) })) } this.handleTracksChange() } handleClick(e) { const t = this.track, n = this.player_.textTracks(); if (super.handleClick(e), n) for (let i = 0; i < n.length; i++) { const e = n[i]; -1 !== this.kinds.indexOf(e.kind) && (e === t ? "showing" !== e.mode && (e.mode = "showing") : "disabled" !== e.mode && (e.mode = "disabled")) } } handleTracksChange(e) { const t = "showing" === this.track.mode; t !== this.isSelected_ && this.selected(t) } handleSelectedLanguageChange(e) { if ("showing" === this.track.mode) { const e = this.player_.cache_.selectedLanguage; if (e && e.enabled && e.language === this.track.language && e.kind !== this.track.kind) return; this.player_.cache_.selectedLanguage = { enabled: !0, language: this.track.language, kind: this.track.kind } } } dispose() { this.track = null, super.dispose() } } go.registerComponent("TextTrackMenuItem", nc); class ic extends nc { constructor(e, t) { t.track = { player: e, kind: t.kind, kinds: t.kinds, default: !1, mode: "disabled" }, t.kinds || (t.kinds = [t.kind]), t.label ? t.track.label = t.label : t.track.label = t.kinds.join(" and ") + " off", t.selectable = !0, t.multiSelectable = !1, super(e, t) } handleTracksChange(e) { const t = this.player().textTracks(); let n = !0; for (let i = 0, r = t.length; i < r; i++) { const e = t[i]; if (this.options_.kinds.indexOf(e.kind) > -1 && "showing" === e.mode) { n = !1; break } } n !== this.isSelected_ && this.selected(n) } handleSelectedLanguageChange(e) { const t = this.player().textTracks(); let n = !0; for (let i = 0, r = t.length; i < r; i++) { const e = t[i]; if (["captions", "descriptions", "subtitles"].indexOf(e.kind) > -1 && "showing" === e.mode) { n = !1; break } } n && (this.player_.cache_.selectedLanguage = { enabled: !1 }) } } go.registerComponent("OffTextTrackMenuItem", ic); class rc extends Zl { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; t.tracks = e.textTracks(), super(e, t) } createItems() { let e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : nc; this.label_ && (e = "".concat(this.label_, " off")), t.push(new ic(this.player_, { kinds: this.kinds_, kind: this.kind_, label: e })), this.hideThreshold_ += 1; const i = this.player_.textTracks(); Array.isArray(this.kinds_) || (this.kinds_ = [this.kind_]); for (let r = 0; r < i.length; r++) { const e = i[r]; if (this.kinds_.indexOf(e.kind) > -1) { const i = new n(this.player_, { track: e, kinds: this.kinds_, kind: this.kind_, selectable: !0, multiSelectable: !1 }); i.addClass("vjs-".concat(e.kind, "-menu-item")), t.push(i) } } return t } } go.registerComponent("TextTrackButton", rc); class sc extends tc { constructor(e, t) { const n = t.track, i = t.cue, r = e.currentTime(); t.selectable = !0, t.multiSelectable = !1, t.label = i.text, t.selected = i.startTime <= r && r < i.endTime, super(e, t), this.track = n, this.cue = i } handleClick(e) { super.handleClick(), this.player_.currentTime(this.cue.startTime) } } go.registerComponent("ChaptersTrackMenuItem", sc); class ac extends rc { constructor(e, t, n) { super(e, t, n), this.selectCurrentItem_ = () => { this.items.forEach((e => { e.selected(this.track_.activeCues[0] === e.cue) })) } } buildCSSClass() { return "vjs-chapters-button ".concat(super.buildCSSClass()) } buildWrapperCSSClass() { return "vjs-chapters-button ".concat(super.buildWrapperCSSClass()) } update(e) { if (e && e.track && "chapters" !== e.track.kind) return; const t = this.findChaptersTrack(); t !== this.track_ ? (this.setTrack(t), super.update()) : (!this.items || t && t.cues && t.cues.length !== this.items.length) && super.update() } setTrack(e) { if (this.track_ !== e) { if (this.updateHandler_ || (this.updateHandler_ = this.update.bind(this)), this.track_) { const e = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_); e && e.removeEventListener("load", this.updateHandler_), this.track_.removeEventListener("cuechange", this.selectCurrentItem_), this.track_ = null } if (this.track_ = e, this.track_) { this.track_.mode = "hidden"; const e = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_); e && e.addEventListener("load", this.updateHandler_), this.track_.addEventListener("cuechange", this.selectCurrentItem_) } } } findChaptersTrack() { const e = this.player_.textTracks() || []; for (let t = e.length - 1; t >= 0; t--) { const n = e[t]; if (n.kind === this.kind_) return n } } getMenuCaption() { return this.track_ && this.track_.label ? this.track_.label : this.localize(po(this.kind_)) } createMenu() { return this.options_.title = this.getMenuCaption(), super.createMenu() } createItems() { const e = []; if (!this.track_) return e; const t = this.track_.cues; if (!t) return e; for (let n = 0, i = t.length; n < i; n++) { const i = t[n], r = new sc(this.player_, { track: this.track_, cue: i }); e.push(r) } return e } } ac.prototype.kind_ = "chapters", ac.prototype.controlText_ = "Chapters", go.registerComponent("ChaptersButton", ac); class oc extends rc { constructor(e, t, n) { super(e, t, n); const i = e.textTracks(), r = Xa(this, this.handleTracksChange); i.addEventListener("change", r), this.on("dispose", (function () { i.removeEventListener("change", r) })) } handleTracksChange(e) { const t = this.player().textTracks(); let n = !1; for (let i = 0, r = t.length; i < r; i++) { const e = t[i]; if (e.kind !== this.kind_ && "showing" === e.mode) { n = !0; break } } n ? this.disable() : this.enable() } buildCSSClass() { return "vjs-descriptions-button ".concat(super.buildCSSClass()) } buildWrapperCSSClass() { return "vjs-descriptions-button ".concat(super.buildWrapperCSSClass()) } } oc.prototype.kind_ = "descriptions", oc.prototype.controlText_ = "Descriptions", go.registerComponent("DescriptionsButton", oc); class lc extends rc { constructor(e, t, n) { super(e, t, n) } buildCSSClass() { return "vjs-subtitles-button ".concat(super.buildCSSClass()) } buildWrapperCSSClass() { return "vjs-subtitles-button ".concat(super.buildWrapperCSSClass()) } } lc.prototype.kind_ = "subtitles", lc.prototype.controlText_ = "Subtitles", go.registerComponent("SubtitlesButton", lc); class cc extends nc { constructor(e, t) { t.track = { player: e, kind: t.kind, label: t.kind + " settings", selectable: !1, default: !1, mode: "disabled" }, t.selectable = !1, t.name = "CaptionSettingsMenuItem", super(e, t), this.addClass("vjs-texttrack-settings"), this.controlText(", opens " + t.kind + " settings dialog") } handleClick(e) { this.player().getChild("textTrackSettings").open() } } go.registerComponent("CaptionSettingsMenuItem", cc); class uc extends rc { constructor(e, t, n) { super(e, t, n) } buildCSSClass() { return "vjs-captions-button ".concat(super.buildCSSClass()) } buildWrapperCSSClass() { return "vjs-captions-button ".concat(super.buildWrapperCSSClass()) } createItems() { const e = []; return this.player().tech_ && this.player().tech_.featuresNativeTextTracks || !this.player().getChild("textTrackSettings") || (e.push(new cc(this.player_, { kind: this.kind_ })), this.hideThreshold_ += 1), super.createItems(e) } } uc.prototype.kind_ = "captions", uc.prototype.controlText_ = "Captions", go.registerComponent("CaptionsButton", uc); class dc extends nc { createEl(e, t, n) { const i = super.createEl(e, t, n), r = i.querySelector(".vjs-menu-item-text"); return "captions" === this.options_.track.kind && (r.appendChild(Qs("span", { className: "vjs-icon-placeholder" }, { "aria-hidden": !0 })), r.appendChild(Qs("span", { className: "vjs-control-text", textContent: " ".concat(this.localize("Captions")) }))), i } } go.registerComponent("SubsCapsMenuItem", dc); class hc extends rc { constructor(e) { super(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}), this.label_ = "subtitles", ["en", "en-us", "en-ca", "fr-ca"].indexOf(this.player_.language_) > -1 && (this.label_ = "captions"), this.menuButton_.controlText(po(this.label_)) } buildCSSClass() { return "vjs-subs-caps-button ".concat(super.buildCSSClass()) } buildWrapperCSSClass() { return "vjs-subs-caps-button ".concat(super.buildWrapperCSSClass()) } createItems() { let e = []; return this.player().tech_ && this.player().tech_.featuresNativeTextTracks || !this.player().getChild("textTrackSettings") || (e.push(new cc(this.player_, { kind: this.label_ })), this.hideThreshold_ += 1), e = super.createItems(e, dc), e } } hc.prototype.kinds_ = ["captions", "subtitles"], hc.prototype.controlText_ = "Subtitles", go.registerComponent("SubsCapsButton", hc); class pc extends tc { constructor(e, t) { var n; const i = t.track, r = e.audioTracks(); t.label = i.label || i.language || "Unknown", t.selected = i.enabled, super(e, t), n = this, this.track = i, this.addClass("vjs-".concat(i.kind, "-menu-item")); const s = function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; n.handleTracksChange.apply(n, t) }; r.addEventListener("change", s), this.on("dispose", (() => { r.removeEventListener("change", s) })) } createEl(e, t, n) { const i = super.createEl(e, t, n), r = i.querySelector(".vjs-menu-item-text"); return "main-desc" === this.options_.track.kind && (r.appendChild(Qs("span", { className: "vjs-icon-placeholder" }, { "aria-hidden": !0 })), r.appendChild(Qs("span", { className: "vjs-control-text", textContent: " " + this.localize("Descriptions") }))), i } handleClick(e) { if (super.handleClick(e), this.track.enabled = !0, this.player_.tech_.featuresNativeAudioTracks) { const e = this.player_.audioTracks(); for (let t = 0; t < e.length; t++) { const n = e[t]; n !== this.track && (n.enabled = n === this.track) } } } handleTracksChange(e) { this.selected(this.track.enabled) } } go.registerComponent("AudioTrackMenuItem", pc); class fc extends Zl { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; t.tracks = e.audioTracks(), super(e, t) } buildCSSClass() { return "vjs-audio-button ".concat(super.buildCSSClass()) } buildWrapperCSSClass() { return "vjs-audio-button ".concat(super.buildWrapperCSSClass()) } createItems() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; this.hideThreshold_ = 1; const t = this.player_.audioTracks(); for (let n = 0; n < t.length; n++) { const i = t[n]; e.push(new pc(this.player_, { track: i, selectable: !0, multiSelectable: !1 })) } return e } } fc.prototype.controlText_ = "Audio Track", go.registerComponent("AudioTrackButton", fc); class mc extends tc { constructor(e, t) { const n = t.rate, i = parseFloat(n, 10); t.label = n, t.selected = i === e.playbackRate(), t.selectable = !0, t.multiSelectable = !1, super(e, t), this.label = n, this.rate = i, this.on(e, "ratechange", (e => this.update(e))) } handleClick(e) { super.handleClick(), this.player().playbackRate(this.rate) } update(e) { this.selected(this.player().playbackRate() === this.rate) } } mc.prototype.contentElType = "button", go.registerComponent("PlaybackRateMenuItem", mc); class gc extends Jl { constructor(e, t) { super(e, t), this.menuButton_.el_.setAttribute("aria-describedby", this.labelElId_), this.updateVisibility(), this.updateLabel(), this.on(e, "loadstart", (e => this.updateVisibility(e))), this.on(e, "ratechange", (e => this.updateLabel(e))), this.on(e, "playbackrateschange", (e => this.handlePlaybackRateschange(e))) } createEl() { const e = super.createEl(); return this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_, this.labelEl_ = Qs("div", { className: "vjs-playback-rate-value", id: this.labelElId_, textContent: "1x" }), e.appendChild(this.labelEl_), e } dispose() { this.labelEl_ = null, super.dispose() } buildCSSClass() { return "vjs-playback-rate ".concat(super.buildCSSClass()) } buildWrapperCSSClass() { return "vjs-playback-rate ".concat(super.buildWrapperCSSClass()) } createItems() { const e = this.playbackRates(), t = []; for (let n = e.length - 1; n >= 0; n--)t.push(new mc(this.player(), { rate: e[n] + "x" })); return t } handlePlaybackRateschange(e) { this.update() } playbackRates() { const e = this.player(); return e.playbackRates && e.playbackRates() || [] } playbackRateSupported() { return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0 } updateVisibility(e) { this.playbackRateSupported() ? this.removeClass("vjs-hidden") : this.addClass("vjs-hidden") } updateLabel(e) { this.playbackRateSupported() && (this.labelEl_.textContent = this.player().playbackRate() + "x") } } gc.prototype.controlText_ = "Playback Rate", go.registerComponent("PlaybackRateMenuButton", gc); class yc extends go { buildCSSClass() { return "vjs-spacer ".concat(super.buildCSSClass()) } createEl() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "div", t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return t.className || (t.className = this.buildCSSClass()), super.createEl(e, t, n) } } go.registerComponent("Spacer", yc); go.registerComponent("CustomControlSpacer", class extends yc { buildCSSClass() { return "vjs-custom-control-spacer ".concat(super.buildCSSClass()) } createEl() { return super.createEl("div", { className: this.buildCSSClass(), textContent: "\xa0" }) } }); class vc extends go { createEl() { return super.createEl("div", { className: "vjs-control-bar", dir: "ltr" }) } } vc.prototype.options_ = { children: ["playToggle", "skipBackward", "skipForward", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "fullscreenToggle"] }, "exitPictureInPicture" in Fn() && vc.prototype.options_.children.splice(vc.prototype.options_.children.length - 1, 0, "pictureInPictureToggle"), go.registerComponent("ControlBar", vc); class bc extends jo { constructor(e, t) { super(e, t), this.on(e, "error", (e => this.open(e))) } buildCSSClass() { return "vjs-error-display ".concat(super.buildCSSClass()) } content() { const e = this.player().error(); return e ? this.localize(e.message) : "" } } bc.prototype.options_ = Object.assign({}, jo.prototype.options_, { pauseOnOpen: !1, fillAlways: !0, temporary: !1, uncloseable: !0 }), go.registerComponent("ErrorDisplay", bc); const _c = "vjs-text-track-settings", Tc = ["#000", "Black"], Sc = ["#00F", "Blue"], wc = ["#0FF", "Cyan"], xc = ["#0F0", "Green"], kc = ["#F0F", "Magenta"], Ec = ["#F00", "Red"], Cc = ["#FFF", "White"], Pc = ["#FF0", "Yellow"], Ic = ["1", "Opaque"], Lc = ["0.5", "Semi-Transparent"], Oc = ["0", "Transparent"], Ac = { backgroundColor: { selector: ".vjs-bg-color > select", id: "captions-background-color-%s", label: "Color", options: [Tc, Cc, Ec, xc, Sc, Pc, kc, wc] }, backgroundOpacity: { selector: ".vjs-bg-opacity > select", id: "captions-background-opacity-%s", label: "Opacity", options: [Ic, Lc, Oc] }, color: { selector: ".vjs-text-color > select", id: "captions-foreground-color-%s", label: "Color", options: [Cc, Tc, Ec, xc, Sc, Pc, kc, wc] }, edgeStyle: { selector: ".vjs-edge-style > select", id: "%s", label: "Text Edge Style", options: [["none", "None"], ["raised", "Raised"], ["depressed", "Depressed"], ["uniform", "Uniform"], ["dropshadow", "Dropshadow"]] }, fontFamily: { selector: ".vjs-font-family > select", id: "captions-font-family-%s", label: "Font Family", options: [["proportionalSansSerif", "Proportional Sans-Serif"], ["monospaceSansSerif", "Monospace Sans-Serif"], ["proportionalSerif", "Proportional Serif"], ["monospaceSerif", "Monospace Serif"], ["casual", "Casual"], ["script", "Script"], ["small-caps", "Small Caps"]] }, fontPercent: { selector: ".vjs-font-percent > select", id: "captions-font-size-%s", label: "Font Size", options: [["0.50", "50%"], ["0.75", "75%"], ["1.00", "100%"], ["1.25", "125%"], ["1.50", "150%"], ["1.75", "175%"], ["2.00", "200%"], ["3.00", "300%"], ["4.00", "400%"]], default: 2, parser: e => "1.00" === e ? null : Number(e) }, textOpacity: { selector: ".vjs-text-opacity > select", id: "captions-foreground-opacity-%s", label: "Opacity", options: [Ic, Lc] }, windowColor: { selector: ".vjs-window-color > select", id: "captions-window-color-%s", label: "Color" }, windowOpacity: { selector: ".vjs-window-opacity > select", id: "captions-window-opacity-%s", label: "Opacity", options: [Oc, Lc, Ic] } }; function Nc(e, t) { if (t && (e = t(e)), e && "none" !== e) return e } Ac.windowColor.options = Ac.backgroundColor.options; go.registerComponent("TextTrackSettings", class extends jo { constructor(e, t) { t.temporary = !1, super(e, t), this.updateDisplay = this.updateDisplay.bind(this), this.fill(), this.hasBeenOpened_ = this.hasBeenFilled_ = !0, this.endDialog = Qs("p", { className: "vjs-control-text", textContent: this.localize("End of dialog window.") }), this.el().appendChild(this.endDialog), this.setDefaults(), void 0 === t.persistTextTrackSettings && (this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings), this.on(this.$(".vjs-done-button"), "click", (() => { this.saveSettings(), this.close() })), this.on(this.$(".vjs-default-button"), "click", (() => { this.setDefaults(), this.updateDisplay() })), bs(Ac, (e => { this.on(this.$(e.selector), "change", this.updateDisplay) })), this.options_.persistTextTrackSettings && this.restoreSettings() } dispose() { this.endDialog = null, super.dispose() } createElSelect_(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "label"; const i = Ac[e], r = i.id.replace("%s", this.id_), s = [t, r].join(" ").trim(); return ["<".concat(n, ' id="').concat(r, '" class="').concat("label" === n ? "vjs-label" : "", '">'), this.localize(i.label), "</".concat(n, ">"), '<select aria-labelledby="'.concat(s, '">')].concat(i.options.map((e => { const t = r + "-" + e[1].replace(/\W+/g, ""); return ['<option id="'.concat(t, '" value="').concat(e[0], '" '), 'aria-labelledby="'.concat(s, " ").concat(t, '">'), this.localize(e[1]), "</option>"].join("") }))).concat("</select>").join("") } createElFgColor_() { const e = "captions-text-legend-".concat(this.id_); return ['<fieldset class="vjs-fg vjs-track-setting">', '<legend id="'.concat(e, '">'), this.localize("Text"), "</legend>", '<span class="vjs-text-color">', this.createElSelect_("color", e), "</span>", '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_("textOpacity", e), "</span>", "</fieldset>"].join("") } createElBgColor_() { const e = "captions-background-".concat(this.id_); return ['<fieldset class="vjs-bg vjs-track-setting">', '<legend id="'.concat(e, '">'), this.localize("Text Background"), "</legend>", '<span class="vjs-bg-color">', this.createElSelect_("backgroundColor", e), "</span>", '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_("backgroundOpacity", e), "</span>", "</fieldset>"].join("") } createElWinColor_() { const e = "captions-window-".concat(this.id_); return ['<fieldset class="vjs-window vjs-track-setting">', '<legend id="'.concat(e, '">'), this.localize("Caption Area Background"), "</legend>", '<span class="vjs-window-color">', this.createElSelect_("windowColor", e), "</span>", '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_("windowOpacity", e), "</span>", "</fieldset>"].join("") } createElColors_() { return Qs("div", { className: "vjs-track-settings-colors", innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join("") }) } createElFont_() { return Qs("div", { className: "vjs-track-settings-font", innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_("fontPercent", "", "legend"), "</fieldset>", '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_("edgeStyle", "", "legend"), "</fieldset>", '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_("fontFamily", "", "legend"), "</fieldset>"].join("") }) } createElControls_() { const e = this.localize("restore all settings to the default values"); return Qs("div", { className: "vjs-track-settings-controls", innerHTML: ['<button type="button" class="vjs-default-button" title="'.concat(e, '">'), this.localize("Reset"), '<span class="vjs-control-text"> '.concat(e, "</span>"), "</button>", '<button type="button" class="vjs-done-button">'.concat(this.localize("Done"), "</button>")].join("") }) } content() { return [this.createElColors_(), this.createElFont_(), this.createElControls_()] } label() { return this.localize("Caption Settings Dialog") } description() { return this.localize("Beginning of dialog window. Escape will cancel and close the window.") } buildCSSClass() { return super.buildCSSClass() + " vjs-text-track-settings" } getValues() { return _s(Ac, ((e, t, n) => { const i = (r = this.$(t.selector), s = t.parser, Nc(r.options[r.options.selectedIndex].value, s)); var r, s; return void 0 !== i && (e[n] = i), e }), {}) } setValues(e) { bs(Ac, ((t, n) => { !function (e, t, n) { if (t) for (let i = 0; i < e.options.length; i++)if (Nc(e.options[i].value, n) === t) { e.selectedIndex = i; break } }(this.$(t.selector), e[n], t.parser) })) } setDefaults() { bs(Ac, (e => { const t = e.hasOwnProperty("default") ? e.default : 0; this.$(e.selector).selectedIndex = t })) } restoreSettings() { let e; try { e = JSON.parse(Un().localStorage.getItem(_c)) } catch (t) { ms.warn(t) } e && this.setValues(e) } saveSettings() { if (!this.options_.persistTextTrackSettings) return; const e = this.getValues(); try { Object.keys(e).length ? Un().localStorage.setItem(_c, JSON.stringify(e)) : Un().localStorage.removeItem(_c) } catch (t) { ms.warn(t) } } updateDisplay() { const e = this.player_.getChild("textTrackDisplay"); e && e.updateDisplay() } conditionalBlur_() { this.previouslyActiveEl_ = null; const e = this.player_.controlBar, t = e && e.subsCapsButton, n = e && e.captionsButton; t ? t.focus() : n && n.focus() } }); go.registerComponent("ResizeManager", class extends go { constructor(e, t) { let n = t.ResizeObserver || Un().ResizeObserver; null === t.ResizeObserver && (n = !1); super(e, ws({ createEl: !n, reportTouchActivity: !1 }, t)), this.ResizeObserver = t.ResizeObserver || Un().ResizeObserver, this.loadListener_ = null, this.resizeObserver_ = null, this.debouncedHandler_ = $a((() => { this.resizeHandler() }), 100, !1, this), n ? (this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_), this.resizeObserver_.observe(e.el())) : (this.loadListener_ = () => { if (!this.el_ || !this.el_.contentWindow) return; const e = this.debouncedHandler_; let t = this.unloadListener_ = function () { za(this, "resize", e), za(this, "unload", t), t = null }; Fa(this.el_.contentWindow, "unload", t), Fa(this.el_.contentWindow, "resize", e) }, this.one("load", this.loadListener_)) } createEl() { return super.createEl("iframe", { className: "vjs-resize-manager", tabIndex: -1, title: this.localize("No content") }, { "aria-hidden": "true" }) } resizeHandler() { this.player_ && this.player_.trigger && this.player_.trigger("playerresize") } dispose() { this.debouncedHandler_ && this.debouncedHandler_.cancel(), this.resizeObserver_ && (this.player_.el() && this.resizeObserver_.unobserve(this.player_.el()), this.resizeObserver_.disconnect()), this.loadListener_ && this.off("load", this.loadListener_), this.el_ && this.el_.contentWindow && this.unloadListener_ && this.unloadListener_.call(this.el_.contentWindow), this.ResizeObserver = null, this.resizeObserver = null, this.debouncedHandler_ = null, this.loadListener_ = null, super.dispose() } }); const jc = { trackingThreshold: 20, liveTolerance: 15 }; go.registerComponent("LiveTracker", class extends go { constructor(e, t) { super(e, ws(jc, t, { createEl: !1 })), this.trackLiveHandler_ = () => this.trackLive_(), this.handlePlay_ = e => this.handlePlay(e), this.handleFirstTimeupdate_ = e => this.handleFirstTimeupdate(e), this.handleSeeked_ = e => this.handleSeeked(e), this.seekToLiveEdge_ = e => this.seekToLiveEdge(e), this.reset_(), this.on(this.player_, "durationchange", (e => this.handleDurationchange(e))), this.on(this.player_, "canplay", (() => this.toggleTracking())) } trackLive_() { const e = this.player_.seekable(); if (!e || !e.length) return; const t = Number(Un().performance.now().toFixed(4)), n = -1 === this.lastTime_ ? 0 : (t - this.lastTime_) / 1e3; this.lastTime_ = t, this.pastSeekEnd_ = this.pastSeekEnd() + n; const i = this.liveCurrentTime(), r = this.player_.currentTime(); let s = this.player_.paused() || this.seekedBehindLive_ || Math.abs(i - r) > this.options_.liveTolerance; this.timeupdateSeen_ && i !== 1 / 0 || (s = !1), s !== this.behindLiveEdge_ && (this.behindLiveEdge_ = s, this.trigger("liveedgechange")) } handleDurationchange() { this.toggleTracking() } toggleTracking() { this.player_.duration() === 1 / 0 && this.liveWindow() >= this.options_.trackingThreshold ? (this.player_.options_.liveui && this.player_.addClass("vjs-liveui"), this.startTracking()) : (this.player_.removeClass("vjs-liveui"), this.stopTracking()) } startTracking() { this.isTracking() || (this.timeupdateSeen_ || (this.timeupdateSeen_ = this.player_.hasStarted()), this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, Ga), this.trackLive_(), this.on(this.player_, ["play", "pause"], this.trackLiveHandler_), this.timeupdateSeen_ ? this.on(this.player_, "seeked", this.handleSeeked_) : (this.one(this.player_, "play", this.handlePlay_), this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_))) } handleFirstTimeupdate() { this.timeupdateSeen_ = !0, this.on(this.player_, "seeked", this.handleSeeked_) } handleSeeked() { const e = Math.abs(this.liveCurrentTime() - this.player_.currentTime()); this.seekedBehindLive_ = this.nextSeekedFromUser_ && e > 2, this.nextSeekedFromUser_ = !1, this.trackLive_() } handlePlay() { this.one(this.player_, "timeupdate", this.seekToLiveEdge_) } reset_() { this.lastTime_ = -1, this.pastSeekEnd_ = 0, this.lastSeekEnd_ = -1, this.behindLiveEdge_ = !0, this.timeupdateSeen_ = !1, this.seekedBehindLive_ = !1, this.nextSeekedFromUser_ = !1, this.clearInterval(this.trackingInterval_), this.trackingInterval_ = null, this.off(this.player_, ["play", "pause"], this.trackLiveHandler_), this.off(this.player_, "seeked", this.handleSeeked_), this.off(this.player_, "play", this.handlePlay_), this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_), this.off(this.player_, "timeupdate", this.seekToLiveEdge_) } nextSeekedFromUser() { this.nextSeekedFromUser_ = !0 } stopTracking() { this.isTracking() && (this.reset_(), this.trigger("liveedgechange")) } seekableEnd() { const e = this.player_.seekable(), t = []; let n = e ? e.length : 0; for (; n--;)t.push(e.end(n)); return t.length ? t.sort()[t.length - 1] : 1 / 0 } seekableStart() { const e = this.player_.seekable(), t = []; let n = e ? e.length : 0; for (; n--;)t.push(e.start(n)); return t.length ? t.sort()[0] : 0 } liveWindow() { const e = this.liveCurrentTime(); return e === 1 / 0 ? 0 : e - this.seekableStart() } isLive() { return this.isTracking() } atLiveEdge() { return !this.behindLiveEdge() } liveCurrentTime() { return this.pastSeekEnd() + this.seekableEnd() } pastSeekEnd() { const e = this.seekableEnd(); return -1 !== this.lastSeekEnd_ && e !== this.lastSeekEnd_ && (this.pastSeekEnd_ = 0), this.lastSeekEnd_ = e, this.pastSeekEnd_ } behindLiveEdge() { return this.behindLiveEdge_ } isTracking() { return "number" === typeof this.trackingInterval_ } seekToLiveEdge() { this.seekedBehindLive_ = !1, this.atLiveEdge() || (this.nextSeekedFromUser_ = !1, this.player_.currentTime(this.liveCurrentTime())) } dispose() { this.stopTracking(), super.dispose() } }); go.registerComponent("TitleBar", class extends go { constructor(e, t) { super(e, t), this.on("statechanged", (e => this.updateDom_())), this.updateDom_() } createEl() { return this.els = { title: Qs("div", { className: "vjs-title-bar-title", id: "vjs-title-bar-title-".concat(ja()) }), description: Qs("div", { className: "vjs-title-bar-description", id: "vjs-title-bar-description-".concat(ja()) }) }, Qs("div", { className: "vjs-title-bar" }, {}, Object.values(this.els)) } updateDom_() { const e = this.player_.tech_, t = e && e.el_, n = { title: "aria-labelledby", description: "aria-describedby" };["title", "description"].forEach((e => { const i = this.state[e], r = this.els[e], s = n[e]; ma(r), i && Js(r, i), t && (t.removeAttribute(s), i && t.setAttribute(s, r.id)) })), this.state.title || this.state.description ? this.show() : this.hide() } update(e) { this.setState(e) } dispose() { const e = this.player_.tech_, t = e && e.el_; t && (t.removeAttribute("aria-labelledby"), t.removeAttribute("aria-describedby")), super.dispose(), this.els = null } }); const Dc = e => { const t = e.el(); if (t.hasAttribute("src")) return e.triggerSourceset(t.src), !0; const n = e.$$("source"), i = []; let r = ""; if (!n.length) return !1; for (let s = 0; s < n.length; s++) { const e = n[s].src; e && -1 === i.indexOf(e) && i.push(e) } return !!i.length && (1 === i.length && (r = i[0]), e.triggerSourceset(r), !0) }, Mc = Object.defineProperty({}, "innerHTML", { get() { return this.cloneNode(!0).innerHTML }, set(e) { const t = Fn().createElement(this.nodeName.toLowerCase()); t.innerHTML = e; const n = Fn().createDocumentFragment(); for (; t.childNodes.length;)n.appendChild(t.childNodes[0]); return this.innerText = "", Un().Element.prototype.appendChild.call(this, n), this.innerHTML } }), Rc = (e, t) => { let n = {}; for (let i = 0; i < e.length && (n = Object.getOwnPropertyDescriptor(e[i], t), !(n && n.set && n.get)); i++); return n.enumerable = !0, n.configurable = !0, n }, Uc = function (e) { const t = e.el(); if (t.resetSourceWatch_) return; const n = {}, i = (e => Rc([e.el(), Un().HTMLMediaElement.prototype, Un().Element.prototype, Mc], "innerHTML"))(e), r = n => function () { for (var i = arguments.length, r = new Array(i), s = 0; s < i; s++)r[s] = arguments[s]; const a = n.apply(t, r); return Dc(e), a };["append", "appendChild", "insertAdjacentHTML"].forEach((e => { t[e] && (n[e] = t[e], t[e] = r(n[e])) })), Object.defineProperty(t, "innerHTML", ws(i, { set: r(i.set) })), t.resetSourceWatch_ = () => { t.resetSourceWatch_ = null, Object.keys(n).forEach((e => { t[e] = n[e] })), Object.defineProperty(t, "innerHTML", i) }, e.one("sourceset", t.resetSourceWatch_) }, Bc = Object.defineProperty({}, "src", { get() { return this.hasAttribute("src") ? Go(Un().Element.prototype.getAttribute.call(this, "src")) : "" }, set(e) { return Un().Element.prototype.setAttribute.call(this, "src", e), e } }), Fc = function (e) { if (!e.featuresSourceset) return; const t = e.el(); if (t.resetSourceset_) return; const n = (e => Rc([e.el(), Un().HTMLMediaElement.prototype, Bc], "src"))(e), i = t.setAttribute, r = t.load; Object.defineProperty(t, "src", ws(n, { set: i => { const r = n.set.call(t, i); return e.triggerSourceset(t.src), r } })), t.setAttribute = (n, r) => { const s = i.call(t, n, r); return /src/i.test(n) && e.triggerSourceset(t.src), s }, t.load = () => { const n = r.call(t); return Dc(e) || (e.triggerSourceset(""), Uc(e)), n }, t.currentSrc ? e.triggerSourceset(t.currentSrc) : Dc(e) || Uc(e), t.resetSourceset_ = () => { t.resetSourceset_ = null, t.load = r, t.setAttribute = i, Object.defineProperty(t, "src", n), t.resetSourceWatch_ && t.resetSourceWatch_() } }; class zc extends sl { constructor(e, t) { super(e, t); const n = e.source; let i = !1; if (this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && "VIDEO" === this.el_.tagName, n && (this.el_.currentSrc !== n.src || e.tag && 3 === e.tag.initNetworkState_) ? this.setSource(n) : this.handleLateInit_(this.el_), e.enableSourceset && this.setupSourcesetHandling_(), this.isScrubbing_ = !1, this.el_.hasChildNodes()) { const e = this.el_.childNodes; let t = e.length; const n = []; for (; t--;) { const r = e[t]; "track" === r.nodeName.toLowerCase() && (this.featuresNativeTextTracks ? (this.remoteTextTrackEls().addTrackElement_(r), this.remoteTextTracks().addTrack(r.track), this.textTracks().addTrack(r.track), i || this.el_.hasAttribute("crossorigin") || !Ko(r.src) || (i = !0)) : n.push(r)) } for (let i = 0; i < n.length; i++)this.el_.removeChild(n[i]) } this.proxyNativeTracks_(), this.featuresNativeTextTracks && i && ms.warn("Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\nThis may prevent text tracks from loading."), this.restoreMetadataTracksInIOSNativePlayer_(), (zs || Fs) && !0 === e.nativeControlsForTouch && this.setControls(!0), this.proxyWebkitFullscreen_(), this.triggerReady() } dispose() { this.el_ && this.el_.resetSourceset_ && this.el_.resetSourceset_(), zc.disposeMediaElement(this.el_), this.options_ = null, super.dispose() } setupSourcesetHandling_() { Fc(this) } restoreMetadataTracksInIOSNativePlayer_() { const e = this.textTracks(); let t; const n = () => { t = []; for (let n = 0; n < e.length; n++) { const i = e[n]; "metadata" === i.kind && t.push({ track: i, storedMode: i.mode }) } }; n(), e.addEventListener("change", n), this.on("dispose", (() => e.removeEventListener("change", n))); const i = () => { for (let e = 0; e < t.length; e++) { const n = t[e]; "disabled" === n.track.mode && n.track.mode !== n.storedMode && (n.track.mode = n.storedMode) } e.removeEventListener("change", i) }; this.on("webkitbeginfullscreen", (() => { e.removeEventListener("change", n), e.removeEventListener("change", i), e.addEventListener("change", i) })), this.on("webkitendfullscreen", (() => { e.removeEventListener("change", n), e.addEventListener("change", n), e.removeEventListener("change", i) })) } overrideNative_(e, t) { if (t !== this["featuresNative".concat(e, "Tracks")]) return; const n = e.toLowerCase(); this["".concat(n, "TracksListeners_")] && Object.keys(this["".concat(n, "TracksListeners_")]).forEach((e => { this.el()["".concat(n, "Tracks")].removeEventListener(e, this["".concat(n, "TracksListeners_")][e]) })), this["featuresNative".concat(e, "Tracks")] = !t, this["".concat(n, "TracksListeners_")] = null, this.proxyNativeTracksForType_(n) } overrideNativeAudioTracks(e) { this.overrideNative_("Audio", e) } overrideNativeVideoTracks(e) { this.overrideNative_("Video", e) } proxyNativeTracksForType_(e) { const t = nl[e], n = this.el()[t.getterName], i = this[t.getterName](); if (!this["featuresNative".concat(t.capitalName, "Tracks")] || !n || !n.addEventListener) return; const r = { change: t => { const n = { type: "change", target: i, currentTarget: i, srcElement: i }; i.trigger(n), "text" === e && this[il.remoteText.getterName]().trigger(n) }, addtrack(e) { i.addTrack(e.track) }, removetrack(e) { i.removeTrack(e.track) } }, s = function () { const e = []; for (let t = 0; t < i.length; t++) { let r = !1; for (let e = 0; e < n.length; e++)if (n[e] === i[t]) { r = !0; break } r || e.push(i[t]) } for (; e.length;)i.removeTrack(e.shift()) }; this[t.getterName + "Listeners_"] = r, Object.keys(r).forEach((e => { const t = r[e]; n.addEventListener(e, t), this.on("dispose", (i => n.removeEventListener(e, t))) })), this.on("loadstart", s), this.on("dispose", (e => this.off("loadstart", s))) } proxyNativeTracks_() { nl.names.forEach((e => { this.proxyNativeTracksForType_(e) })) } createEl() { let e = this.options_.tag; if (!e || !this.options_.playerElIngest && !this.movingMediaElementInDOM) { if (e) { const t = e.cloneNode(!0); e.parentNode && e.parentNode.insertBefore(t, e), zc.disposeMediaElement(e), e = t } else { e = Fn().createElement("video"); const t = ws({}, this.options_.tag && sa(this.options_.tag)); zs && !0 === this.options_.nativeControlsForTouch || delete t.controls, ra(e, Object.assign(t, { id: this.options_.techId, class: "vjs-tech" })) } e.playerId = this.options_.playerId } "undefined" !== typeof this.options_.preload && oa(e, "preload", this.options_.preload), void 0 !== this.options_.disablePictureInPicture && (e.disablePictureInPicture = this.options_.disablePictureInPicture); const t = ["loop", "muted", "playsinline", "autoplay"]; for (let n = 0; n < t.length; n++) { const i = t[n], r = this.options_[i]; "undefined" !== typeof r && (r ? oa(e, i, i) : la(e, i), e[i] = r) } return e } handleLateInit_(e) { if (0 === e.networkState || 3 === e.networkState) return; if (0 === e.readyState) { let e = !1; const t = function () { e = !0 }; this.on("loadstart", t); const n = function () { e || this.trigger("loadstart") }; return this.on("loadedmetadata", n), void this.ready((function () { this.off("loadstart", t), this.off("loadedmetadata", n), e || this.trigger("loadstart") })) } const t = ["loadstart"]; t.push("loadedmetadata"), e.readyState >= 2 && t.push("loadeddata"), e.readyState >= 3 && t.push("canplay"), e.readyState >= 4 && t.push("canplaythrough"), this.ready((function () { t.forEach((function (e) { this.trigger(e) }), this) })) } setScrubbing(e) { this.isScrubbing_ = e } scrubbing() { return this.isScrubbing_ } setCurrentTime(e) { try { this.isScrubbing_ && this.el_.fastSeek && Ws ? this.el_.fastSeek(e) : this.el_.currentTime = e } catch (t) { ms(t, "Video is not ready. (Video.js)") } } duration() { if (this.el_.duration === 1 / 0 && Is && Ns && 0 === this.el_.currentTime) { const e = () => { this.el_.currentTime > 0 && (this.el_.duration === 1 / 0 && this.trigger("durationchange"), this.off("timeupdate", e)) }; return this.on("timeupdate", e), NaN } return this.el_.duration || NaN } width() { return this.el_.offsetWidth } height() { return this.el_.offsetHeight } proxyWebkitFullscreen_() { if (!("webkitDisplayingFullscreen" in this.el_)) return; const e = function () { this.trigger("fullscreenchange", { isFullscreen: !1 }), this.el_.controls && !this.options_.nativeControlsForTouch && this.controls() && (this.el_.controls = !1) }, t = function () { "webkitPresentationMode" in this.el_ && "picture-in-picture" !== this.el_.webkitPresentationMode && (this.one("webkitendfullscreen", e), this.trigger("fullscreenchange", { isFullscreen: !0, nativeIOSFullscreen: !0 })) }; this.on("webkitbeginfullscreen", t), this.on("dispose", (() => { this.off("webkitbeginfullscreen", t), this.off("webkitendfullscreen", e) })) } supportsFullScreen() { return "function" === typeof this.el_.webkitEnterFullScreen } enterFullScreen() { const e = this.el_; if (e.paused && e.networkState <= e.HAVE_METADATA) Io(this.el_.play()), this.setTimeout((function () { e.pause(); try { e.webkitEnterFullScreen() } catch (t) { this.trigger("fullscreenerror", t) } }), 0); else try { e.webkitEnterFullScreen() } catch (t) { this.trigger("fullscreenerror", t) } } exitFullScreen() { this.el_.webkitDisplayingFullscreen ? this.el_.webkitExitFullScreen() : this.trigger("fullscreenerror", new Error("The video is not fullscreen")) } requestPictureInPicture() { return this.el_.requestPictureInPicture() } requestVideoFrameCallback(e) { return this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.requestVideoFrameCallback(e) : super.requestVideoFrameCallback(e) } cancelVideoFrameCallback(e) { this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.cancelVideoFrameCallback(e) : super.cancelVideoFrameCallback(e) } src(e) { if (void 0 === e) return this.el_.src; this.setSrc(e) } reset() { zc.resetMediaElement(this.el_) } currentSrc() { return this.currentSource_ ? this.currentSource_.src : this.el_.currentSrc } setControls(e) { this.el_.controls = !!e } addTextTrack(e, t, n) { return this.featuresNativeTextTracks ? this.el_.addTextTrack(e, t, n) : super.addTextTrack(e, t, n) } createRemoteTextTrack(e) { if (!this.featuresNativeTextTracks) return super.createRemoteTextTrack(e); const t = Fn().createElement("track"); return e.kind && (t.kind = e.kind), e.label && (t.label = e.label), (e.language || e.srclang) && (t.srclang = e.language || e.srclang), e.default && (t.default = e.default), e.id && (t.id = e.id), e.src && (t.src = e.src), t } addRemoteTextTrack(e, t) { const n = super.addRemoteTextTrack(e, t); return this.featuresNativeTextTracks && this.el().appendChild(n), n } removeRemoteTextTrack(e) { if (super.removeRemoteTextTrack(e), this.featuresNativeTextTracks) { const t = this.$$("track"); let n = t.length; for (; n--;)e !== t[n] && e !== t[n].track || this.el().removeChild(t[n]) } } getVideoPlaybackQuality() { if ("function" === typeof this.el().getVideoPlaybackQuality) return this.el().getVideoPlaybackQuality(); const e = {}; return "undefined" !== typeof this.el().webkitDroppedFrameCount && "undefined" !== typeof this.el().webkitDecodedFrameCount && (e.droppedVideoFrames = this.el().webkitDroppedFrameCount, e.totalVideoFrames = this.el().webkitDecodedFrameCount), Un().performance && (e.creationTime = Un().performance.now()), e } } xs(zc, "TEST_VID", (function () { if (!Xs()) return; const e = Fn().createElement("video"), t = Fn().createElement("track"); return t.kind = "captions", t.srclang = "en", t.label = "English", e.appendChild(t), e })), zc.isSupported = function () { try { zc.TEST_VID.volume = .5 } catch (e) { return !1 } return !(!zc.TEST_VID || !zc.TEST_VID.canPlayType) }, zc.canPlayType = function (e) { return zc.TEST_VID.canPlayType(e) }, zc.canPlaySource = function (e, t) { return zc.canPlayType(e.type) }, zc.canControlVolume = function () { try { const e = zc.TEST_VID.volume; zc.TEST_VID.volume = e / 2 + .1; const t = e !== zc.TEST_VID.volume; return t && Vs ? (Un().setTimeout((() => { zc && zc.prototype && (zc.prototype.featuresVolumeControl = e !== zc.TEST_VID.volume) })), !1) : t } catch (e) { return !1 } }, zc.canMuteVolume = function () { try { const e = zc.TEST_VID.muted; return zc.TEST_VID.muted = !e, zc.TEST_VID.muted ? oa(zc.TEST_VID, "muted", "muted") : la(zc.TEST_VID, "muted"), e !== zc.TEST_VID.muted } catch (e) { return !1 } }, zc.canControlPlaybackRate = function () { if (Is && Ns && Ds < 58) return !1; try { const e = zc.TEST_VID.playbackRate; return zc.TEST_VID.playbackRate = e / 2 + .1, e !== zc.TEST_VID.playbackRate } catch (e) { return !1 } }, zc.canOverrideAttributes = function () { try { const e = () => { }; Object.defineProperty(Fn().createElement("video"), "src", { get: e, set: e }), Object.defineProperty(Fn().createElement("audio"), "src", { get: e, set: e }), Object.defineProperty(Fn().createElement("video"), "innerHTML", { get: e, set: e }), Object.defineProperty(Fn().createElement("audio"), "innerHTML", { get: e, set: e }) } catch (e) { return !1 } return !0 }, zc.supportsNativeTextTracks = function () { return Ws || Vs && Ns }, zc.supportsNativeVideoTracks = function () { return !(!zc.TEST_VID || !zc.TEST_VID.videoTracks) }, zc.supportsNativeAudioTracks = function () { return !(!zc.TEST_VID || !zc.TEST_VID.audioTracks) }, zc.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"], [["featuresMuteControl", "canMuteVolume"], ["featuresPlaybackRate", "canControlPlaybackRate"], ["featuresSourceset", "canOverrideAttributes"], ["featuresNativeTextTracks", "supportsNativeTextTracks"], ["featuresNativeVideoTracks", "supportsNativeVideoTracks"], ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]].forEach((function (e) { let [t, n] = e; xs(zc.prototype, t, (() => zc[n]()), !0) })), zc.prototype.featuresVolumeControl = zc.canControlVolume(), zc.prototype.movingMediaElementInDOM = !Vs, zc.prototype.featuresFullscreenResize = !0, zc.prototype.featuresProgressEvents = !0, zc.prototype.featuresTimeupdateEvents = !0, zc.prototype.featuresVideoFrameCallback = !(!zc.TEST_VID || !zc.TEST_VID.requestVideoFrameCallback), zc.disposeMediaElement = function (e) { if (e) { for (e.parentNode && e.parentNode.removeChild(e); e.hasChildNodes();)e.removeChild(e.firstChild); e.removeAttribute("src"), "function" === typeof e.load && function () { try { e.load() } catch (t) { } }() } }, zc.resetMediaElement = function (e) { if (!e) return; const t = e.querySelectorAll("source"); let n = t.length; for (; n--;)e.removeChild(t[n]); e.removeAttribute("src"), "function" === typeof e.load && function () { try { e.load() } catch (t) { } }() }, ["muted", "defaultMuted", "autoplay", "controls", "loop", "playsinline"].forEach((function (e) { zc.prototype[e] = function () { return this.el_[e] || this.el_.hasAttribute(e) } })), ["muted", "defaultMuted", "autoplay", "loop", "playsinline"].forEach((function (e) { zc.prototype["set" + po(e)] = function (t) { this.el_[e] = t, t ? this.el_.setAttribute(e, e) : this.el_.removeAttribute(e) } })), ["paused", "currentTime", "buffered", "volume", "poster", "preload", "error", "seeking", "seekable", "ended", "playbackRate", "defaultPlaybackRate", "disablePictureInPicture", "played", "networkState", "readyState", "videoWidth", "videoHeight", "crossOrigin"].forEach((function (e) { zc.prototype[e] = function () { return this.el_[e] } })), ["volume", "src", "poster", "preload", "playbackRate", "defaultPlaybackRate", "disablePictureInPicture", "crossOrigin"].forEach((function (e) { zc.prototype["set" + po(e)] = function (t) { this.el_[e] = t } })), ["pause", "load", "play"].forEach((function (e) { zc.prototype[e] = function () { return this.el_[e]() } })), sl.withSourceHandlers(zc), zc.nativeSourceHandler = {}, zc.nativeSourceHandler.canPlayType = function (e) { try { return zc.TEST_VID.canPlayType(e) } catch (t) { return "" } }, zc.nativeSourceHandler.canHandleSource = function (e, t) { if (e.type) return zc.nativeSourceHandler.canPlayType(e.type); if (e.src) { const t = Xo(e.src); return zc.nativeSourceHandler.canPlayType("video/".concat(t)) } return "" }, zc.nativeSourceHandler.handleSource = function (e, t, n) { t.setSrc(e.src) }, zc.nativeSourceHandler.dispose = function () { }, zc.registerSourceHandler(zc.nativeSourceHandler), sl.registerTech("Html5", zc); const Hc = ["progress", "abort", "suspend", "emptied", "stalled", "loadedmetadata", "loadeddata", "timeupdate", "resize", "volumechange", "texttrackchange"], Vc = { canplay: "CanPlay", canplaythrough: "CanPlayThrough", playing: "Playing", seeked: "Seeked" }, Wc = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"], qc = {}; Wc.forEach((e => { const t = "x" === e.charAt(0) ? "x-".concat(e.substring(1)) : e; qc[e] = "vjs-layout-".concat(t) })); const Gc = { tiny: 210, xsmall: 320, small: 425, medium: 768, large: 1440, xlarge: 2560, huge: 1 / 0 }; class Xc extends go { constructor(e, t, n) { if (e.id = e.id || t.id || "vjs_video_".concat(ja()), (t = Object.assign(Xc.getTagSettings(e), t)).initChildren = !1, t.createEl = !1, t.evented = !1, t.reportTouchActivity = !1, !t.language) { const n = e.closest("[lang]"); n && (t.language = n.getAttribute("lang")) } if (super(null, t, n), this.boundDocumentFullscreenChange_ = e => this.documentFullscreenChange_(e), this.boundFullWindowOnEscKey_ = e => this.fullWindowOnEscKey(e), this.boundUpdateStyleEl_ = e => this.updateStyleEl_(e), this.boundApplyInitTime_ = e => this.applyInitTime_(e), this.boundUpdateCurrentBreakpoint_ = e => this.updateCurrentBreakpoint_(e), this.boundHandleTechClick_ = e => this.handleTechClick_(e), this.boundHandleTechDoubleClick_ = e => this.handleTechDoubleClick_(e), this.boundHandleTechTouchStart_ = e => this.handleTechTouchStart_(e), this.boundHandleTechTouchMove_ = e => this.handleTechTouchMove_(e), this.boundHandleTechTouchEnd_ = e => this.handleTechTouchEnd_(e), this.boundHandleTechTap_ = e => this.handleTechTap_(e), this.isFullscreen_ = !1, this.log = gs(this.id_), this.fsApi_ = us, this.isPosterFromTech_ = !1, this.queuedCallbacks_ = [], this.isReady_ = !1, this.hasStarted_ = !1, this.userActive_ = !1, this.debugEnabled_ = !1, this.audioOnlyMode_ = !1, this.audioPosterMode_ = !1, this.audioOnlyCache_ = { playerHeight: null, hiddenChildren: [] }, !this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) throw new Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?"); if (this.tag = e, this.tagAttributes = e && sa(e), this.language(this.options_.language), t.languages) { const e = {}; Object.getOwnPropertyNames(t.languages).forEach((function (n) { e[n.toLowerCase()] = t.languages[n] })), this.languages_ = e } else this.languages_ = Xc.prototype.options_.languages; this.resetCache_(), this.poster_ = t.poster || "", this.controls_ = !!t.controls, e.controls = !1, e.removeAttribute("controls"), this.changingSrc_ = !1, this.playCallbacks_ = [], this.playTerminatedQueue_ = [], e.hasAttribute("autoplay") ? this.autoplay(!0) : this.autoplay(this.options_.autoplay), t.plugins && Object.keys(t.plugins).forEach((e => { if ("function" !== typeof this[e]) throw new Error('plugin "'.concat(e, '" does not exist')) })), this.scrubbing_ = !1, this.el_ = this.createEl(), lo(this, { eventBusKey: "el_" }), this.fsApi_.requestFullscreen && (Fa(Fn(), this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_), this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_)), this.fluid_ && this.on(["playerreset", "resize"], this.boundUpdateStyleEl_); const i = ws(this.options_); t.plugins && Object.keys(t.plugins).forEach((e => { this[e](t.plugins[e]) })), t.debug && this.debug(!0), this.options_.playerOptions = i, this.middleware_ = [], this.playbackRates(t.playbackRates), this.initChildren(), this.isAudio("audio" === e.nodeName.toLowerCase()), this.controls() ? this.addClass("vjs-controls-enabled") : this.addClass("vjs-controls-disabled"), this.el_.setAttribute("role", "region"), this.isAudio() ? this.el_.setAttribute("aria-label", this.localize("Audio Player")) : this.el_.setAttribute("aria-label", this.localize("Video Player")), this.isAudio() && this.addClass("vjs-audio"), zs && this.addClass("vjs-touch-enabled"), Vs || this.addClass("vjs-workinghover"), Xc.players[this.id_] = this; const r = as.split(".")[0]; this.addClass("vjs-v".concat(r)), this.userActive(!0), this.reportUserActivity(), this.one("play", (e => this.listenForUserActivity_(e))), this.on("keydown", (e => this.handleKeyDown(e))), this.on("languagechange", (e => this.handleLanguagechange(e))), this.breakpoints(this.options_.breakpoints), this.responsive(this.options_.responsive), this.on("ready", (() => { this.audioPosterMode(this.options_.audioPosterMode), this.audioOnlyMode(this.options_.audioOnlyMode) })) } dispose() { this.trigger("dispose"), this.off("dispose"), za(Fn(), this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_), za(Fn(), "keydown", this.boundFullWindowOnEscKey_), this.styleEl_ && this.styleEl_.parentNode && (this.styleEl_.parentNode.removeChild(this.styleEl_), this.styleEl_ = null), Xc.players[this.id_] = null, this.tag && this.tag.player && (this.tag.player = null), this.el_ && this.el_.player && (this.el_.player = null), this.tech_ && (this.tech_.dispose(), this.isPosterFromTech_ = !1, this.poster_ = ""), this.playerElIngest_ && (this.playerElIngest_ = null), this.tag && (this.tag = null), ol[this.id()] = null, rl.names.forEach((e => { const t = this[rl[e].getterName](); t && t.off && t.off() })), super.dispose({ restoreEl: this.options_.restoreEl }) } createEl() { let e, t = this.tag, n = this.playerElIngest_ = t.parentNode && t.parentNode.hasAttribute && t.parentNode.hasAttribute("data-vjs-player"); const i = "video-js" === this.tag.tagName.toLowerCase(); n ? e = this.el_ = t.parentNode : i || (e = this.el_ = super.createEl("div")); const r = sa(t); if (i) { for (e = this.el_ = t, t = this.tag = Fn().createElement("video"); e.children.length;)t.appendChild(e.firstChild); ea(e, "video-js") || ta(e, "video-js"), e.appendChild(t), n = this.playerElIngest_ = e, Object.keys(e).forEach((n => { try { t[n] = e[n] } catch (i) { } })) } if (t.setAttribute("tabindex", "-1"), r.tabindex = "-1", Ns && Us && (t.setAttribute("role", "application"), r.role = "application"), t.removeAttribute("width"), t.removeAttribute("height"), "width" in r && delete r.width, "height" in r && delete r.height, Object.getOwnPropertyNames(r).forEach((function (n) { i && "class" === n || e.setAttribute(n, r[n]), i && t.setAttribute(n, r[n]) })), t.playerId = t.id, t.id += "_html5_api", t.className = "vjs-tech", t.player = e.player = this, this.addClass("vjs-paused"), !0 !== Un().VIDEOJS_NO_DYNAMIC_STYLE) { this.styleEl_ = Ia("vjs-styles-dimensions"); const e = _a(".vjs-styles-defaults"), t = _a("head"); t.insertBefore(this.styleEl_, e ? e.nextSibling : t.firstChild) } this.fill_ = !1, this.fluid_ = !1, this.width(this.options_.width), this.height(this.options_.height), this.fill(this.options_.fill), this.fluid(this.options_.fluid), this.aspectRatio(this.options_.aspectRatio), this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin); const s = t.getElementsByTagName("a"); for (let a = 0; a < s.length; a++) { const e = s.item(a); ta(e, "vjs-hidden"), e.setAttribute("hidden", "hidden") } return t.initNetworkState_ = t.networkState, t.parentNode && !n && t.parentNode.insertBefore(e, t), Zs(t, e), this.children_.unshift(t), this.el_.setAttribute("lang", this.language_), this.el_.setAttribute("translate", "no"), this.el_ = e, e } crossOrigin(e) { if ("undefined" === typeof e) return this.techGet_("crossOrigin"); null === e || "anonymous" === e || "use-credentials" === e ? (this.techCall_("setCrossOrigin", e), this.posterImage && this.posterImage.crossOrigin(e)) : ms.warn('crossOrigin must be null,  "anonymous" or "use-credentials", given "'.concat(e, '"')) } width(e) { return this.dimension("width", e) } height(e) { return this.dimension("height", e) } dimension(e, t) { const n = e + "_"; if (void 0 === t) return this[n] || 0; if ("" === t || "auto" === t) return this[n] = void 0, void this.updateStyleEl_(); const i = parseFloat(t); isNaN(i) ? ms.error('Improper value "'.concat(t, '" supplied for for ').concat(e)) : (this[n] = i, this.updateStyleEl_()) } fluid(e) { if (void 0 === e) return !!this.fluid_; var t, n; this.fluid_ = !!e, eo(this) && this.off(["playerreset", "resize"], this.boundUpdateStyleEl_), e ? (this.addClass("vjs-fluid"), this.fill(!1), n = () => { this.on(["playerreset", "resize"], this.boundUpdateStyleEl_) }, eo(t = this) ? n() : (t.eventedCallbacks || (t.eventedCallbacks = []), t.eventedCallbacks.push(n))) : this.removeClass("vjs-fluid"), this.updateStyleEl_() } fill(e) { if (void 0 === e) return !!this.fill_; this.fill_ = !!e, e ? (this.addClass("vjs-fill"), this.fluid(!1)) : this.removeClass("vjs-fill") } aspectRatio(e) { if (void 0 === e) return this.aspectRatio_; if (!/^\d+\:\d+$/.test(e)) throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9."); this.aspectRatio_ = e, this.fluid(!0), this.updateStyleEl_() } updateStyleEl_() { if (!0 === Un().VIDEOJS_NO_DYNAMIC_STYLE) { const e = "number" === typeof this.width_ ? this.width_ : this.options_.width, t = "number" === typeof this.height_ ? this.height_ : this.options_.height, n = this.tech_ && this.tech_.el(); return void (n && (e >= 0 && (n.width = e), t >= 0 && (n.height = t))) } let e, t, n, i; n = void 0 !== this.aspectRatio_ && "auto" !== this.aspectRatio_ ? this.aspectRatio_ : this.videoWidth() > 0 ? this.videoWidth() + ":" + this.videoHeight() : "16:9"; const r = n.split(":"), s = r[1] / r[0]; e = void 0 !== this.width_ ? this.width_ : void 0 !== this.height_ ? this.height_ / s : this.videoWidth() || 300, t = void 0 !== this.height_ ? this.height_ : e * s, i = /^[^a-zA-Z]/.test(this.id()) ? "dimensions-" + this.id() : this.id() + "-dimensions", this.addClass(i), La(this.styleEl_, "\n      .".concat(i, " {\n        width: ").concat(e, "px;\n        height: ").concat(t, "px;\n      }\n\n      .").concat(i, ".vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: ").concat(100 * s, "%;\n      }\n    ")) } loadTech_(e, t) { this.tech_ && this.unloadTech_(); const n = po(e), i = e.charAt(0).toLowerCase() + e.slice(1); "Html5" !== n && this.tag && (sl.getTech("Html5").disposeMediaElement(this.tag), this.tag.player = null, this.tag = null), this.techName_ = n, this.isReady_ = !1; let r = this.autoplay(); ("string" === typeof this.autoplay() || !0 === this.autoplay() && this.options_.normalizeAutoplay) && (r = !1); const s = { source: t, autoplay: r, nativeControlsForTouch: this.options_.nativeControlsForTouch, playerId: this.id(), techId: "".concat(this.id(), "_").concat(i, "_api"), playsinline: this.options_.playsinline, preload: this.options_.preload, loop: this.options_.loop, disablePictureInPicture: this.options_.disablePictureInPicture, muted: this.options_.muted, poster: this.poster(), language: this.language(), playerElIngest: this.playerElIngest_ || !1, "vtt.js": this.options_["vtt.js"], canOverridePoster: !!this.options_.techCanOverridePoster, enableSourceset: this.options_.enableSourceset }; rl.names.forEach((e => { const t = rl[e]; s[t.getterName] = this[t.privateName] })), Object.assign(s, this.options_[n]), Object.assign(s, this.options_[i]), Object.assign(s, this.options_[e.toLowerCase()]), this.tag && (s.tag = this.tag), t && t.src === this.cache_.src && this.cache_.currentTime > 0 && (s.startTime = this.cache_.currentTime); const a = sl.getTech(e); if (!a) throw new Error("No Tech named '".concat(n, "' exists! '").concat(n, "' should be registered using videojs.registerTech()'")); this.tech_ = new a(s), this.tech_.ready(Xa(this, this.handleTechReady_), !0), Ao(this.textTracksJson_ || [], this.tech_), Hc.forEach((e => { this.on(this.tech_, e, (t => this["handleTech".concat(po(e), "_")](t))) })), Object.keys(Vc).forEach((e => { this.on(this.tech_, e, (t => { 0 === this.tech_.playbackRate() && this.tech_.seeking() ? this.queuedCallbacks_.push({ callback: this["handleTech".concat(Vc[e], "_")].bind(this), event: t }) : this["handleTech".concat(Vc[e], "_")](t) })) })), this.on(this.tech_, "loadstart", (e => this.handleTechLoadStart_(e))), this.on(this.tech_, "sourceset", (e => this.handleTechSourceset_(e))), this.on(this.tech_, "waiting", (e => this.handleTechWaiting_(e))), this.on(this.tech_, "ended", (e => this.handleTechEnded_(e))), this.on(this.tech_, "seeking", (e => this.handleTechSeeking_(e))), this.on(this.tech_, "play", (e => this.handleTechPlay_(e))), this.on(this.tech_, "pause", (e => this.handleTechPause_(e))), this.on(this.tech_, "durationchange", (e => this.handleTechDurationChange_(e))), this.on(this.tech_, "fullscreenchange", ((e, t) => this.handleTechFullscreenChange_(e, t))), this.on(this.tech_, "fullscreenerror", ((e, t) => this.handleTechFullscreenError_(e, t))), this.on(this.tech_, "enterpictureinpicture", (e => this.handleTechEnterPictureInPicture_(e))), this.on(this.tech_, "leavepictureinpicture", (e => this.handleTechLeavePictureInPicture_(e))), this.on(this.tech_, "error", (e => this.handleTechError_(e))), this.on(this.tech_, "posterchange", (e => this.handleTechPosterChange_(e))), this.on(this.tech_, "textdata", (e => this.handleTechTextData_(e))), this.on(this.tech_, "ratechange", (e => this.handleTechRateChange_(e))), this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_), this.usingNativeControls(this.techGet_("controls")), this.controls() && !this.usingNativeControls() && this.addTechControlsListeners_(), this.tech_.el().parentNode === this.el() || "Html5" === n && this.tag || Zs(this.tech_.el(), this.el()), this.tag && (this.tag.player = null, this.tag = null) } unloadTech_() { rl.names.forEach((e => { const t = rl[e]; this[t.privateName] = this[t.getterName]() })), this.textTracksJson_ = Oo(this.tech_), this.isReady_ = !1, this.tech_.dispose(), this.tech_ = !1, this.isPosterFromTech_ && (this.poster_ = "", this.trigger("posterchange")), this.isPosterFromTech_ = !1 } tech(e) { return void 0 === e && ms.warn("Using the tech directly can be dangerous. I hope you know what you're doing.\nSee https://github.com/videojs/video.js/issues/2617 for more info.\n"), this.tech_ } addTechControlsListeners_() { this.removeTechControlsListeners_(), this.on(this.tech_, "click", this.boundHandleTechClick_), this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_), this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.on(this.tech_, "tap", this.boundHandleTechTap_) } removeTechControlsListeners_() { this.off(this.tech_, "tap", this.boundHandleTechTap_), this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.off(this.tech_, "click", this.boundHandleTechClick_), this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_) } handleTechReady_() { this.triggerReady(), this.cache_.volume && this.techCall_("setVolume", this.cache_.volume), this.handleTechPosterChange_(), this.handleTechDurationChange_() } handleTechLoadStart_() { this.removeClass("vjs-ended", "vjs-seeking"), this.error(null), this.handleTechDurationChange_(), this.paused() ? (this.hasStarted(!1), this.trigger("loadstart")) : this.trigger("loadstart"), this.manualAutoplay_(!0 === this.autoplay() && this.options_.normalizeAutoplay ? "play" : this.autoplay()) } manualAutoplay_(e) { if (!this.tech_ || "string" !== typeof e) return; const t = () => { const e = this.muted(); this.muted(!0); const t = () => { this.muted(e) }; this.playTerminatedQueue_.push(t); const n = this.play(); if (Po(n)) return n.catch((e => { throw t(), new Error("Rejection at manualAutoplay. Restoring muted value. ".concat(e || "")) })) }; let n; return "any" !== e || this.muted() ? n = "muted" !== e || this.muted() ? this.play() : t() : (n = this.play(), Po(n) && (n = n.catch(t))), Po(n) ? n.then((() => { this.trigger({ type: "autoplay-success", autoplay: e }) })).catch((() => { this.trigger({ type: "autoplay-failure", autoplay: e }) })) : void 0 } updateSourceCaches_() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", t = e, n = ""; "string" !== typeof t && (t = e.src, n = e.type), this.cache_.source = this.cache_.source || {}, this.cache_.sources = this.cache_.sources || [], t && !n && (n = ((e, t) => { if (!t) return ""; if (e.cache_.source.src === t && e.cache_.source.type) return e.cache_.source.type; const n = e.cache_.sources.filter((e => e.src === t)); if (n.length) return n[0].type; const i = e.$$("source"); for (let r = 0; r < i.length; r++) { const e = i[r]; if (e.type && e.src && e.src === t) return e.type } return yl(t) })(this, t)), this.cache_.source = ws({}, e, { src: t, type: n }); const i = this.cache_.sources.filter((e => e.src && e.src === t)), r = [], s = this.$$("source"), a = []; for (let o = 0; o < s.length; o++) { const e = sa(s[o]); r.push(e), e.src && e.src === t && a.push(e.src) } a.length && !i.length ? this.cache_.sources = r : i.length || (this.cache_.sources = [this.cache_.source]), this.cache_.src = t } handleTechSourceset_(e) { if (!this.changingSrc_) { let t = e => this.updateSourceCaches_(e); const n = this.currentSource().src, i = e.src; n && !/^blob:/.test(n) && /^blob:/.test(i) && (!this.lastSource_ || this.lastSource_.tech !== i && this.lastSource_.player !== n) && (t = () => { }), t(i), e.src || this.tech_.any(["sourceset", "loadstart"], (e => { if ("sourceset" === e.type) return; const t = this.techGet("currentSrc"); this.lastSource_.tech = t, this.updateSourceCaches_(t) })) } this.lastSource_ = { player: this.currentSource().src, tech: e.src }, this.trigger({ src: e.src, type: "sourceset" }) } hasStarted(e) { if (void 0 === e) return this.hasStarted_; e !== this.hasStarted_ && (this.hasStarted_ = e, this.hasStarted_ ? this.addClass("vjs-has-started") : this.removeClass("vjs-has-started")) } handleTechPlay_() { this.removeClass("vjs-ended", "vjs-paused"), this.addClass("vjs-playing"), this.hasStarted(!0), this.trigger("play") } handleTechRateChange_() { this.tech_.playbackRate() > 0 && 0 === this.cache_.lastPlaybackRate && (this.queuedCallbacks_.forEach((e => e.callback(e.event))), this.queuedCallbacks_ = []), this.cache_.lastPlaybackRate = this.tech_.playbackRate(), this.trigger("ratechange") } handleTechWaiting_() { this.addClass("vjs-waiting"), this.trigger("waiting"); const e = this.currentTime(), t = () => { e !== this.currentTime() && (this.removeClass("vjs-waiting"), this.off("timeupdate", t)) }; this.on("timeupdate", t) } handleTechCanPlay_() { this.removeClass("vjs-waiting"), this.trigger("canplay") } handleTechCanPlayThrough_() { this.removeClass("vjs-waiting"), this.trigger("canplaythrough") } handleTechPlaying_() { this.removeClass("vjs-waiting"), this.trigger("playing") } handleTechSeeking_() { this.addClass("vjs-seeking"), this.trigger("seeking") } handleTechSeeked_() { this.removeClass("vjs-seeking", "vjs-ended"), this.trigger("seeked") } handleTechPause_() { this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.trigger("pause") } handleTechEnded_() { this.addClass("vjs-ended"), this.removeClass("vjs-waiting"), this.options_.loop ? (this.currentTime(0), this.play()) : this.paused() || this.pause(), this.trigger("ended") } handleTechDurationChange_() { this.duration(this.techGet_("duration")) } handleTechClick_(e) { this.controls_ && (void 0 !== this.options_ && void 0 !== this.options_.userActions && void 0 !== this.options_.userActions.click && !1 === this.options_.userActions.click || (void 0 !== this.options_ && void 0 !== this.options_.userActions && "function" === typeof this.options_.userActions.click ? this.options_.userActions.click.call(this, e) : this.paused() ? Io(this.play()) : this.pause())) } handleTechDoubleClick_(e) { if (!this.controls_) return; Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), (t => t.contains(e.target))) || void 0 !== this.options_ && void 0 !== this.options_.userActions && void 0 !== this.options_.userActions.doubleClick && !1 === this.options_.userActions.doubleClick || (void 0 !== this.options_ && void 0 !== this.options_.userActions && "function" === typeof this.options_.userActions.doubleClick ? this.options_.userActions.doubleClick.call(this, e) : this.isFullscreen() ? this.exitFullscreen() : this.requestFullscreen()) } handleTechTap_() { this.userActive(!this.userActive()) } handleTechTouchStart_() { this.userWasActive = this.userActive() } handleTechTouchMove_() { this.userWasActive && this.reportUserActivity() } handleTechTouchEnd_(e) { e.cancelable && e.preventDefault() } toggleFullscreenClass_() { this.isFullscreen() ? this.addClass("vjs-fullscreen") : this.removeClass("vjs-fullscreen") } documentFullscreenChange_(e) { const t = e.target.player; if (t && t !== this) return; const n = this.el(); let i = Fn()[this.fsApi_.fullscreenElement] === n; !i && n.matches ? i = n.matches(":" + this.fsApi_.fullscreen) : !i && n.msMatchesSelector && (i = n.msMatchesSelector(":" + this.fsApi_.fullscreen)), this.isFullscreen(i) } handleTechFullscreenChange_(e, t) { t && (t.nativeIOSFullscreen && (this.addClass("vjs-ios-native-fs"), this.tech_.one("webkitendfullscreen", (() => { this.removeClass("vjs-ios-native-fs") }))), this.isFullscreen(t.isFullscreen)) } handleTechFullscreenError_(e, t) { this.trigger("fullscreenerror", t) } togglePictureInPictureClass_() { this.isInPictureInPicture() ? this.addClass("vjs-picture-in-picture") : this.removeClass("vjs-picture-in-picture") } handleTechEnterPictureInPicture_(e) { this.isInPictureInPicture(!0) } handleTechLeavePictureInPicture_(e) { this.isInPictureInPicture(!1) } handleTechError_() { const e = this.tech_.error(); this.error(e) } handleTechTextData_() { let e = null; arguments.length > 1 && (e = arguments[1]), this.trigger("textdata", e) } getCache() { return this.cache_ } resetCache_() { this.cache_ = { currentTime: 0, initTime: 0, inactivityTimeout: this.options_.inactivityTimeout, duration: NaN, lastVolume: 1, lastPlaybackRate: this.defaultPlaybackRate(), media: null, src: "", source: {}, sources: [], playbackRates: [], volume: 1 } } techCall_(e, t) { this.ready((function () { if (e in hl) return function (e, t, n, i) { return t[n](e.reduce(fl(n), i)) }(this.middleware_, this.tech_, e, t); if (e in pl) return ul(this.middleware_, this.tech_, e, t); try { this.tech_ && this.tech_[e](t) } catch (n) { throw ms(n), n } }), !0) } techGet_(e) { if (this.tech_ && this.tech_.isReady_) { if (e in dl) return function (e, t, n) { return e.reduceRight(fl(n), t[n]()) }(this.middleware_, this.tech_, e); if (e in pl) return ul(this.middleware_, this.tech_, e); try { return this.tech_[e]() } catch (t) { if (void 0 === this.tech_[e]) throw ms("Video.js: ".concat(e, " method not defined for ").concat(this.techName_, " playback technology."), t), t; if ("TypeError" === t.name) throw ms("Video.js: ".concat(e, " unavailable on ").concat(this.techName_, " playback technology element."), t), this.tech_.isReady_ = !1, t; throw ms(t), t } } } play() { return new Promise((e => { this.play_(e) })) } play_() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Io; this.playCallbacks_.push(e); const t = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc())); if (this.waitToPlay_ && (this.off(["ready", "loadstart"], this.waitToPlay_), this.waitToPlay_ = null), !this.isReady_ || !t) return this.waitToPlay_ = e => { this.play_() }, this.one(["ready", "loadstart"], this.waitToPlay_), void (t || !Ws && !Vs || this.load()); const n = this.techGet_("play"); null === n ? this.runPlayTerminatedQueue_() : this.runPlayCallbacks_(n) } runPlayTerminatedQueue_() { const e = this.playTerminatedQueue_.slice(0); this.playTerminatedQueue_ = [], e.forEach((function (e) { e() })) } runPlayCallbacks_(e) { const t = this.playCallbacks_.slice(0); this.playCallbacks_ = [], this.playTerminatedQueue_ = [], t.forEach((function (t) { t(e) })) } pause() { this.techCall_("pause") } paused() { return !1 !== this.techGet_("paused") } played() { return this.techGet_("played") || bo(0, 0) } scrubbing(e) { if ("undefined" === typeof e) return this.scrubbing_; this.scrubbing_ = !!e, this.techCall_("setScrubbing", this.scrubbing_), e ? this.addClass("vjs-scrubbing") : this.removeClass("vjs-scrubbing") } currentTime(e) { return "undefined" !== typeof e ? (e < 0 && (e = 0), this.isReady_ && !this.changingSrc_ && this.tech_ && this.tech_.isReady_ ? (this.techCall_("setCurrentTime", e), void (this.cache_.initTime = 0)) : (this.cache_.initTime = e, this.off("canplay", this.boundApplyInitTime_), void this.one("canplay", this.boundApplyInitTime_))) : (this.cache_.currentTime = this.techGet_("currentTime") || 0, this.cache_.currentTime) } applyInitTime_() { this.currentTime(this.cache_.initTime) } duration(e) { if (void 0 === e) return void 0 !== this.cache_.duration ? this.cache_.duration : NaN; (e = parseFloat(e)) < 0 && (e = 1 / 0), e !== this.cache_.duration && (this.cache_.duration = e, e === 1 / 0 ? this.addClass("vjs-live") : this.removeClass("vjs-live"), isNaN(e) || this.trigger("durationchange")) } remainingTime() { return this.duration() - this.currentTime() } remainingTimeDisplay() { return Math.floor(this.duration()) - Math.floor(this.currentTime()) } buffered() { let e = this.techGet_("buffered"); return e && e.length || (e = bo(0, 0)), e } bufferedPercent() { return Eo(this.buffered(), this.duration()) } bufferedEnd() { const e = this.buffered(), t = this.duration(); let n = e.end(e.length - 1); return n > t && (n = t), n } volume(e) { let t; return void 0 !== e ? (t = Math.max(0, Math.min(1, parseFloat(e))), this.cache_.volume = t, this.techCall_("setVolume", t), void (t > 0 && this.lastVolume_(t))) : (t = parseFloat(this.techGet_("volume")), isNaN(t) ? 1 : t) } muted(e) { if (void 0 === e) return this.techGet_("muted") || !1; this.techCall_("setMuted", e) } defaultMuted(e) { return void 0 !== e ? this.techCall_("setDefaultMuted", e) : this.techGet_("defaultMuted") || !1 } lastVolume_(e) { if (void 0 === e || 0 === e) return this.cache_.lastVolume; this.cache_.lastVolume = e } supportsFullScreen() { return this.techGet_("supportsFullScreen") || !1 } isFullscreen(e) { if (void 0 !== e) { const t = this.isFullscreen_; return this.isFullscreen_ = Boolean(e), this.isFullscreen_ !== t && this.fsApi_.prefixed && this.trigger("fullscreenchange"), void this.toggleFullscreenClass_() } return this.isFullscreen_ } requestFullscreen(e) { this.isInPictureInPicture() && this.exitPictureInPicture(); const t = this; return new Promise(((n, i) => { function r() { t.off("fullscreenerror", a), t.off("fullscreenchange", s) } function s() { r(), n() } function a(e, t) { r(), i(t) } t.one("fullscreenchange", s), t.one("fullscreenerror", a); const o = t.requestFullscreenHelper_(e); o && (o.then(r, r), o.then(n, i)) })) } requestFullscreenHelper_(e) { let t; if (this.fsApi_.prefixed || (t = this.options_.fullscreen && this.options_.fullscreen.options || {}, void 0 !== e && (t = e)), this.fsApi_.requestFullscreen) { const e = this.el_[this.fsApi_.requestFullscreen](t); return e && e.then((() => this.isFullscreen(!0)), (() => this.isFullscreen(!1))), e } this.tech_.supportsFullScreen() && !0 === !this.options_.preferFullWindow ? this.techCall_("enterFullScreen") : this.enterFullWindow() } exitFullscreen() { const e = this; return new Promise(((t, n) => { function i() { e.off("fullscreenerror", s), e.off("fullscreenchange", r) } function r() { i(), t() } function s(e, t) { i(), n(t) } e.one("fullscreenchange", r), e.one("fullscreenerror", s); const a = e.exitFullscreenHelper_(); a && (a.then(i, i), a.then(t, n)) })) } exitFullscreenHelper_() { if (this.fsApi_.requestFullscreen) { const e = Fn()[this.fsApi_.exitFullscreen](); return e && Io(e.then((() => this.isFullscreen(!1)))), e } this.tech_.supportsFullScreen() && !0 === !this.options_.preferFullWindow ? this.techCall_("exitFullScreen") : this.exitFullWindow() } enterFullWindow() { this.isFullscreen(!0), this.isFullWindow = !0, this.docOrigOverflow = Fn().documentElement.style.overflow, Fa(Fn(), "keydown", this.boundFullWindowOnEscKey_), Fn().documentElement.style.overflow = "hidden", ta(Fn().body, "vjs-full-window"), this.trigger("enterFullWindow") } fullWindowOnEscKey(e) { Hn().isEventKey(e, "Esc") && !0 === this.isFullscreen() && (this.isFullWindow ? this.exitFullWindow() : this.exitFullscreen()) } exitFullWindow() { this.isFullscreen(!1), this.isFullWindow = !1, za(Fn(), "keydown", this.boundFullWindowOnEscKey_), Fn().documentElement.style.overflow = this.docOrigOverflow, na(Fn().body, "vjs-full-window"), this.trigger("exitFullWindow") } disablePictureInPicture(e) { if (void 0 === e) return this.techGet_("disablePictureInPicture"); this.techCall_("setDisablePictureInPicture", e), this.options_.disablePictureInPicture = e, this.trigger("disablepictureinpicturechanged") } isInPictureInPicture(e) { return void 0 !== e ? (this.isInPictureInPicture_ = !!e, void this.togglePictureInPictureClass_()) : !!this.isInPictureInPicture_ } requestPictureInPicture() { if ("pictureInPictureEnabled" in Fn() && !1 === this.disablePictureInPicture()) return this.techGet_("requestPictureInPicture") } exitPictureInPicture() { if ("pictureInPictureEnabled" in Fn()) return Fn().exitPictureInPicture() } handleKeyDown(e) { const { userActions: t } = this.options_; if (!t || !t.hotkeys) return; (e => { const t = e.tagName.toLowerCase(); if (e.isContentEditable) return !0; if ("input" === t) return -1 === ["button", "checkbox", "hidden", "radio", "reset", "submit"].indexOf(e.type); return -1 !== ["textarea"].indexOf(t) })(this.el_.ownerDocument.activeElement) || ("function" === typeof t.hotkeys ? t.hotkeys.call(this, e) : this.handleHotkeys(e)) } handleHotkeys(e) { const t = this.options_.userActions ? this.options_.userActions.hotkeys : {}, { fullscreenKey: n = (e => Hn().isEventKey(e, "f")), muteKey: i = (e => Hn().isEventKey(e, "m")), playPauseKey: r = (e => Hn().isEventKey(e, "k") || Hn().isEventKey(e, "Space")) } = t; if (n.call(this, e)) { e.preventDefault(), e.stopPropagation(); const t = go.getComponent("FullscreenToggle"); !1 !== Fn()[this.fsApi_.fullscreenEnabled] && t.prototype.handleClick.call(this, e) } else if (i.call(this, e)) { e.preventDefault(), e.stopPropagation(); go.getComponent("MuteToggle").prototype.handleClick.call(this, e) } else if (r.call(this, e)) { e.preventDefault(), e.stopPropagation(); go.getComponent("PlayToggle").prototype.handleClick.call(this, e) } } canPlayType(e) { let t; for (let n = 0, i = this.options_.techOrder; n < i.length; n++) { const r = i[n]; let s = sl.getTech(r); if (s || (s = go.getComponent(r)), s) { if (s.isSupported() && (t = s.canPlayType(e), t)) return t } else ms.error('The "'.concat(r, '" tech is undefined. Skipped browser support check for that tech.')) } return "" } selectSource(e) { const t = this.options_.techOrder.map((e => [e, sl.getTech(e)])).filter((e => { let [t, n] = e; return n ? n.isSupported() : (ms.error('The "'.concat(t, '" tech is undefined. Skipped browser support check for that tech.')), !1) })), n = function (e, t, n) { let i; return e.some((e => t.some((t => { if (i = n(e, t), i) return !0 })))), i }; let i; const r = (e, t) => { let [n, i] = e; if (i.canPlaySource(t, this.options_[n.toLowerCase()])) return { source: t, tech: n } }; var s; return i = this.options_.sourceOrder ? n(e, t, (s = r, (e, t) => s(t, e))) : n(t, e, r), i || !1 } handleSrc_(e, t) { if ("undefined" === typeof e) return this.cache_.src || ""; this.resetRetryOnError_ && this.resetRetryOnError_(); const n = vl(e); if (n.length) { if (this.changingSrc_ = !0, t || (this.cache_.sources = n), this.updateSourceCaches_(n[0]), cl(this, n[0], ((e, i) => { this.middleware_ = i, t || (this.cache_.sources = n), this.updateSourceCaches_(e); if (this.src_(e)) return n.length > 1 ? this.handleSrc_(n.slice(1)) : (this.changingSrc_ = !1, this.setTimeout((function () { this.error({ code: 4, message: this.options_.notSupportedMessage }) }), 0), void this.triggerReady()); var r, s; r = i, s = this.tech_, r.forEach((e => e.setTech && e.setTech(s))) })), n.length > 1) { const e = () => { this.error(null), this.handleSrc_(n.slice(1), !0) }, t = () => { this.off("error", e) }; this.one("error", e), this.one("playing", t), this.resetRetryOnError_ = () => { this.off("error", e), this.off("playing", t) } } } else this.setTimeout((function () { this.error({ code: 4, message: this.options_.notSupportedMessage }) }), 0) } src(e) { return this.handleSrc_(e, !1) } src_(e) { const t = this.selectSource([e]); return !t || (fo(t.tech, this.techName_) ? (this.ready((function () { this.tech_.constructor.prototype.hasOwnProperty("setSource") ? this.techCall_("setSource", e) : this.techCall_("src", e.src), this.changingSrc_ = !1 }), !0), !1) : (this.changingSrc_ = !0, this.loadTech_(t.tech, t.source), this.tech_.ready((() => { this.changingSrc_ = !1 })), !1)) } load() { this.techCall_("load") } reset() { if (this.paused()) this.doReset_(); else { Io(this.play().then((() => this.doReset_()))) } } doReset_() { this.tech_ && this.tech_.clearTracks("text"), this.resetCache_(), this.poster(""), this.loadTech_(this.options_.techOrder[0], null), this.techCall_("reset"), this.resetControlBarUI_(), eo(this) && this.trigger("playerreset") } resetControlBarUI_() { this.resetProgressBar_(), this.resetPlaybackRate_(), this.resetVolumeBar_() } resetProgressBar_() { this.currentTime(0); const { durationDisplay: e, remainingTimeDisplay: t } = this.controlBar || {}; e && e.updateContent(), t && t.updateContent() } resetPlaybackRate_() { this.playbackRate(this.defaultPlaybackRate()), this.handleTechRateChange_() } resetVolumeBar_() { this.volume(1), this.trigger("volumechange") } currentSources() { const e = this.currentSource(), t = []; return 0 !== Object.keys(e).length && t.push(e), this.cache_.sources || t } currentSource() { return this.cache_.source || {} } currentSrc() { return this.currentSource() && this.currentSource().src || "" } currentType() { return this.currentSource() && this.currentSource().type || "" } preload(e) { return void 0 !== e ? (this.techCall_("setPreload", e), void (this.options_.preload = e)) : this.techGet_("preload") } autoplay(e) { if (void 0 === e) return this.options_.autoplay || !1; let t; "string" === typeof e && /(any|play|muted)/.test(e) || !0 === e && this.options_.normalizeAutoplay ? (this.options_.autoplay = e, this.manualAutoplay_("string" === typeof e ? e : "play"), t = !1) : this.options_.autoplay = !!e, t = "undefined" === typeof t ? this.options_.autoplay : t, this.tech_ && this.techCall_("setAutoplay", t) } playsinline(e) { return void 0 !== e ? (this.techCall_("setPlaysinline", e), this.options_.playsinline = e, this) : this.techGet_("playsinline") } loop(e) { return void 0 !== e ? (this.techCall_("setLoop", e), void (this.options_.loop = e)) : this.techGet_("loop") } poster(e) { if (void 0 === e) return this.poster_; e || (e = ""), e !== this.poster_ && (this.poster_ = e, this.techCall_("setPoster", e), this.isPosterFromTech_ = !1, this.trigger("posterchange")) } handleTechPosterChange_() { if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) { const e = this.tech_.poster() || ""; e !== this.poster_ && (this.poster_ = e, this.isPosterFromTech_ = !0, this.trigger("posterchange")) } } controls(e) { if (void 0 === e) return !!this.controls_; e = !!e, this.controls_ !== e && (this.controls_ = e, this.usingNativeControls() && this.techCall_("setControls", e), this.controls_ ? (this.removeClass("vjs-controls-disabled"), this.addClass("vjs-controls-enabled"), this.trigger("controlsenabled"), this.usingNativeControls() || this.addTechControlsListeners_()) : (this.removeClass("vjs-controls-enabled"), this.addClass("vjs-controls-disabled"), this.trigger("controlsdisabled"), this.usingNativeControls() || this.removeTechControlsListeners_())) } usingNativeControls(e) { if (void 0 === e) return !!this.usingNativeControls_; e = !!e, this.usingNativeControls_ !== e && (this.usingNativeControls_ = e, this.usingNativeControls_ ? (this.addClass("vjs-using-native-controls"), this.trigger("usingnativecontrols")) : (this.removeClass("vjs-using-native-controls"), this.trigger("usingcustomcontrols"))) } error(e) { if (void 0 === e) return this.error_ || null; if (ls("beforeerror").forEach((t => { const n = t(this, e); Ts(n) && !Array.isArray(n) || "string" === typeof n || "number" === typeof n || null === n ? e = n : this.log.error("please return a value that MediaError expects in beforeerror hooks") })), this.options_.suppressNotSupportedError && e && 4 === e.code) { const t = function () { this.error(e) }; return this.options_.suppressNotSupportedError = !1, this.any(["click", "touchstart"], t), void this.one("loadstart", (function () { this.off(["click", "touchstart"], t) })) } if (null === e) return this.error_ = e, this.removeClass("vjs-error"), void (this.errorDisplay && this.errorDisplay.close()); this.error_ = new Co(e), this.addClass("vjs-error"), ms.error("(CODE:".concat(this.error_.code, " ").concat(Co.errorTypes[this.error_.code], ")"), this.error_.message, this.error_), this.trigger("error"), ls("error").forEach((e => e(this, this.error_))) } reportUserActivity(e) { this.userActivity_ = !0 } userActive(e) { if (void 0 === e) return this.userActive_; if ((e = !!e) !== this.userActive_) { if (this.userActive_ = e, this.userActive_) return this.userActivity_ = !0, this.removeClass("vjs-user-inactive"), this.addClass("vjs-user-active"), void this.trigger("useractive"); this.tech_ && this.tech_.one("mousemove", (function (e) { e.stopPropagation(), e.preventDefault() })), this.userActivity_ = !1, this.removeClass("vjs-user-active"), this.addClass("vjs-user-inactive"), this.trigger("userinactive") } } listenForUserActivity_() { let e, t, n; const i = Xa(this, this.reportUserActivity), r = function (t) { i(), this.clearInterval(e) }; this.on("mousedown", (function () { i(), this.clearInterval(e), e = this.setInterval(i, 250) })), this.on("mousemove", (function (e) { e.screenX === t && e.screenY === n || (t = e.screenX, n = e.screenY, i()) })), this.on("mouseup", r), this.on("mouseleave", r); const s = this.getChild("controlBar"); let a; !s || Vs || Is || (s.on("mouseenter", (function (e) { 0 !== this.player().options_.inactivityTimeout && (this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout), this.player().options_.inactivityTimeout = 0 })), s.on("mouseleave", (function (e) { this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout }))), this.on("keydown", i), this.on("keyup", i), this.setInterval((function () { if (!this.userActivity_) return; this.userActivity_ = !1, this.userActive(!0), this.clearTimeout(a); const e = this.options_.inactivityTimeout; e <= 0 || (a = this.setTimeout((function () { this.userActivity_ || this.userActive(!1) }), e)) }), 250) } playbackRate(e) { if (void 0 === e) return this.tech_ && this.tech_.featuresPlaybackRate ? this.cache_.lastPlaybackRate || this.techGet_("playbackRate") : 1; this.techCall_("setPlaybackRate", e) } defaultPlaybackRate(e) { return void 0 !== e ? this.techCall_("setDefaultPlaybackRate", e) : this.tech_ && this.tech_.featuresPlaybackRate ? this.techGet_("defaultPlaybackRate") : 1 } isAudio(e) { if (void 0 === e) return !!this.isAudio_; this.isAudio_ = !!e } enableAudioOnlyUI_() { this.addClass("vjs-audio-only-mode"); const e = this.children(), t = this.getChild("ControlBar"), n = t && t.currentHeight(); e.forEach((e => { e !== t && e.el_ && !e.hasClass("vjs-hidden") && (e.hide(), this.audioOnlyCache_.hiddenChildren.push(e)) })), this.audioOnlyCache_.playerHeight = this.currentHeight(), this.height(n), this.trigger("audioonlymodechange") } disableAudioOnlyUI_() { this.removeClass("vjs-audio-only-mode"), this.audioOnlyCache_.hiddenChildren.forEach((e => e.show())), this.height(this.audioOnlyCache_.playerHeight), this.trigger("audioonlymodechange") } audioOnlyMode(e) { if ("boolean" !== typeof e || e === this.audioOnlyMode_) return this.audioOnlyMode_; if (this.audioOnlyMode_ = e, e) { const e = []; return this.isInPictureInPicture() && e.push(this.exitPictureInPicture()), this.isFullscreen() && e.push(this.exitFullscreen()), this.audioPosterMode() && e.push(this.audioPosterMode(!1)), Promise.all(e).then((() => this.enableAudioOnlyUI_())) } return Promise.resolve().then((() => this.disableAudioOnlyUI_())) } enablePosterModeUI_() { (this.tech_ && this.tech_).hide(), this.addClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange") } disablePosterModeUI_() { (this.tech_ && this.tech_).show(), this.removeClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange") } audioPosterMode(e) { if ("boolean" !== typeof e || e === this.audioPosterMode_) return this.audioPosterMode_; if (this.audioPosterMode_ = e, e) { if (this.audioOnlyMode()) { return this.audioOnlyMode(!1).then((() => { this.enablePosterModeUI_() })) } return Promise.resolve().then((() => { this.enablePosterModeUI_() })) } return Promise.resolve().then((() => { this.disablePosterModeUI_() })) } addTextTrack(e, t, n) { if (this.tech_) return this.tech_.addTextTrack(e, t, n) } addRemoteTextTrack(e, t) { if (this.tech_) return this.tech_.addRemoteTextTrack(e, t) } removeRemoteTextTrack() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, { track: t } = e; if (t || (t = e), this.tech_) return this.tech_.removeRemoteTextTrack(t) } getVideoPlaybackQuality() { return this.techGet_("getVideoPlaybackQuality") } videoWidth() { return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0 } videoHeight() { return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0 } language(e) { if (void 0 === e) return this.language_; this.language_ !== String(e).toLowerCase() && (this.language_ = String(e).toLowerCase(), eo(this) && this.trigger("languagechange")) } languages() { return ws(Xc.prototype.options_.languages, this.languages_) } toJSON() { const e = ws(this.options_), t = e.tracks; e.tracks = []; for (let n = 0; n < t.length; n++) { let i = t[n]; i = ws(i), i.player = void 0, e.tracks[n] = i } return e } createModal(e, t) { (t = t || {}).content = e || ""; const n = new jo(this, t); return this.addChild(n), n.on("dispose", (() => { this.removeChild(n) })), n.open(), n } updateCurrentBreakpoint_() { if (!this.responsive()) return; const e = this.currentBreakpoint(), t = this.currentWidth(); for (let n = 0; n < Wc.length; n++) { const i = Wc[n]; if (t <= this.breakpoints_[i]) { if (e === i) return; e && this.removeClass(qc[e]), this.addClass(qc[i]), this.breakpoint_ = i; break } } } removeCurrentBreakpoint_() { const e = this.currentBreakpointClass(); this.breakpoint_ = "", e && this.removeClass(e) } breakpoints(e) { return void 0 === e || (this.breakpoint_ = "", this.breakpoints_ = Object.assign({}, Gc, e), this.updateCurrentBreakpoint_()), Object.assign(this.breakpoints_) } responsive(e) { if (void 0 === e) return this.responsive_; return (e = Boolean(e)) !== this.responsive_ ? (this.responsive_ = e, e ? (this.on("playerresize", this.boundUpdateCurrentBreakpoint_), this.updateCurrentBreakpoint_()) : (this.off("playerresize", this.boundUpdateCurrentBreakpoint_), this.removeCurrentBreakpoint_()), e) : void 0 } currentBreakpoint() { return this.breakpoint_ } currentBreakpointClass() { return qc[this.breakpoint_] || "" } loadMedia(e, t) { if (!e || "object" !== typeof e) return; this.reset(), this.cache_.media = ws(e); const { artist: n, artwork: i, description: r, poster: s, src: a, textTracks: o, title: l } = this.cache_.media; !i && s && (this.cache_.media.artwork = [{ src: s, type: yl(s) }]), a && this.src(a), s && this.poster(s), Array.isArray(o) && o.forEach((e => this.addRemoteTextTrack(e, !1))), this.titleBar && this.titleBar.update({ title: l, description: r || n || "" }), this.ready(t) } getMedia() { if (!this.cache_.media) { const e = this.poster(), t = { src: this.currentSources(), textTracks: Array.prototype.map.call(this.remoteTextTracks(), (e => ({ kind: e.kind, label: e.label, language: e.language, src: e.src }))) }; return e && (t.poster = e, t.artwork = [{ src: t.poster, type: yl(t.poster) }]), t } return ws(this.cache_.media) } static getTagSettings(e) { const t = { sources: [], tracks: [] }, n = sa(e), i = n["data-setup"]; if (ea(e, "vjs-fill") && (n.fill = !0), ea(e, "vjs-fluid") && (n.fluid = !0), null !== i) { const [e, t] = Wn()(i || "{}"); e && ms.error(e), Object.assign(n, t) } if (Object.assign(t, n), e.hasChildNodes()) { const n = e.childNodes; for (let e = 0, i = n.length; e < i; e++) { const i = n[e], r = i.nodeName.toLowerCase(); "source" === r ? t.sources.push(sa(i)) : "track" === r && t.tracks.push(sa(i)) } } return t } debug(e) { if (void 0 === e) return this.debugEnabled_; e ? (this.trigger("debugon"), this.previousLogLevel_ = this.log.level, this.log.level("debug"), this.debugEnabled_ = !0) : (this.trigger("debugoff"), this.log.level(this.previousLogLevel_), this.previousLogLevel_ = void 0, this.debugEnabled_ = !1) } playbackRates(e) { if (void 0 === e) return this.cache_.playbackRates; Array.isArray(e) && e.every((e => "number" === typeof e)) && (this.cache_.playbackRates = e, this.trigger("playbackrateschange")) } } rl.names.forEach((function (e) { const t = rl[e]; Xc.prototype[t.getterName] = function () { return this.tech_ ? this.tech_[t.getterName]() : (this[t.privateName] = this[t.privateName] || new t.ListClass, this[t.privateName]) } })), Xc.prototype.crossorigin = Xc.prototype.crossOrigin, Xc.players = {}; const Kc = Un().navigator; Xc.prototype.options_ = { techOrder: sl.defaultTechOrder_, html5: {}, enableSourceset: !0, inactivityTimeout: 2e3, playbackRates: [], liveui: !1, children: ["mediaLoader", "posterImage", "titleBar", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager"], language: Kc && (Kc.languages && Kc.languages[0] || Kc.userLanguage || Kc.language) || "en", languages: {}, notSupportedMessage: "No compatible source was found for this media.", normalizeAutoplay: !1, fullscreen: { options: { navigationUI: "hide" } }, breakpoints: {}, responsive: !1, audioOnlyMode: !1, audioPosterMode: !1 }, ["ended", "seeking", "seekable", "networkState", "readyState"].forEach((function (e) { Xc.prototype[e] = function () { return this.techGet_(e) } })), Hc.forEach((function (e) { Xc.prototype["handleTech".concat(po(e), "_")] = function () { return this.trigger(e) } })), go.registerComponent("Player", Xc); const $c = "plugin", Yc = "activePlugins_", Qc = {}, Jc = e => Qc.hasOwnProperty(e), Zc = e => Jc(e) ? Qc[e] : void 0, eu = (e, t) => { e[Yc] = e[Yc] || {}, e[Yc][t] = !0 }, tu = (e, t, n) => { const i = (n ? "before" : "") + "pluginsetup"; e.trigger(i, t), e.trigger(i + ":" + t.name, t) }, nu = (e, t) => (t.prototype.name = e, function () { tu(this, { name: e, plugin: t, instance: null }, !0); for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++)i[r] = arguments[r]; const s = new t(...[this, ...i]); return this[e] = () => s, tu(this, s.getEventHash()), s }); class iu { constructor(e) { if (this.constructor === iu) throw new Error("Plugin must be sub-classed; not directly instantiated."); this.player = e, this.log || (this.log = this.player.log.createLogger(this.name)), lo(this), delete this.trigger, uo(this, this.constructor.defaultState), eu(e, this.name), this.dispose = this.dispose.bind(this), e.on("dispose", this.dispose) } version() { return this.constructor.VERSION } getEventHash() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return e.name = this.name, e.plugin = this.constructor, e.instance = this, e } trigger(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return Ha(this.eventBusEl_, e, this.getEventHash(t)) } handleStateChanged(e) { } dispose() { const { name: e, player: t } = this; this.trigger("dispose"), this.off(), t.off("dispose", this.dispose), t[Yc][e] = !1, this.player = this.state = null, t[e] = nu(e, Qc[e]) } static isBasic(e) { const t = "string" === typeof e ? Zc(e) : e; return "function" === typeof t && !iu.prototype.isPrototypeOf(t.prototype) } static registerPlugin(e, t) { if ("string" !== typeof e) throw new Error('Illegal plugin name, "'.concat(e, '", must be a string, was ').concat(typeof e, ".")); if (Jc(e)) ms.warn('A plugin named "'.concat(e, '" already exists. You may want to avoid re-registering plugins!')); else if (Xc.prototype.hasOwnProperty(e)) throw new Error('Illegal plugin name, "'.concat(e, '", cannot share a name with an existing player method!')); if ("function" !== typeof t) throw new Error('Illegal plugin for "'.concat(e, '", must be a function, was ').concat(typeof t, ".")); return Qc[e] = t, e !== $c && (iu.isBasic(t) ? Xc.prototype[e] = function (e, t) { const n = function () { tu(this, { name: e, plugin: t, instance: null }, !0); const n = t.apply(this, arguments); return eu(this, e), tu(this, { name: e, plugin: t, instance: n }), n }; return Object.keys(t).forEach((function (e) { n[e] = t[e] })), n }(e, t) : Xc.prototype[e] = nu(e, t)), t } static deregisterPlugin(e) { if (e === $c) throw new Error("Cannot de-register base plugin."); Jc(e) && (delete Qc[e], delete Xc.prototype[e]) } static getPlugins() { let e; return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Object.keys(Qc)).forEach((t => { const n = Zc(t); n && (e = e || {}, e[t] = n) })), e } static getPluginVersion(e) { const t = Zc(e); return t && t.VERSION || "" } } function ru(e, t, n, i) { return function (e, t) { let n = !1; return function () { n || ms.warn(e), n = !0; for (var i = arguments.length, r = new Array(i), s = 0; s < i; s++)r[s] = arguments[s]; return t.apply(this, r) } }("".concat(t, " is deprecated and will be removed in ").concat(e, ".0; please use ").concat(n, " instead."), i) } iu.getPlugin = Zc, iu.BASE_PLUGIN_NAME = $c, iu.registerPlugin($c, iu), Xc.prototype.usingPlugin = function (e) { return !!this[Yc] && !0 === this[Yc][e] }, Xc.prototype.hasPlugin = function (e) { return !!Jc(e) }; const su = e => 0 === e.indexOf("#") ? e.slice(1) : e; function au(e, t, n) { let i = au.getPlayer(e); if (i) return t && ms.warn('Player "'.concat(e, '" is already initialised. Options will not be applied.')), n && i.ready(n), i; const r = "string" === typeof e ? _a("#" + su(e)) : e; if (!Ks(r)) throw new TypeError("The element or ID supplied is not valid. (videojs)"); r.ownerDocument.defaultView && r.ownerDocument.body.contains(r) || ms.warn("The element supplied is not included in the DOM"), !0 === (t = t || {}).restoreEl && (t.restoreEl = (r.parentNode && r.parentNode.hasAttribute("data-vjs-player") ? r.parentNode : r).cloneNode(!0)), ls("beforesetup").forEach((e => { const n = e(r, ws(t)); Ts(n) && !Array.isArray(n) ? t = ws(t, n) : ms.error("please return an object in beforesetup hooks") })); const s = go.getComponent("Player"); return i = new s(r, t, n), ls("setup").forEach((e => e(i))), i } if (au.hooks_ = os, au.hooks = ls, au.hook = function (e, t) { ls(e, t) }, au.hookOnce = function (e, t) { ls(e, [].concat(t).map((t => { const n = function () { return cs(e, n), t(...arguments) }; return n }))) }, au.removeHook = cs, !0 !== Un().VIDEOJS_NO_DYNAMIC_STYLE && Xs()) { let e = _a(".vjs-styles-defaults"); if (!e) { e = Ia("vjs-styles-defaults"); const t = _a("head"); t && t.insertBefore(e, t.firstChild), La(e, "\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: 56.25%\n      }\n    ") } } Ca(1, au), au.VERSION = as, au.options = Xc.prototype.options_, au.getPlayers = () => Xc.players, au.getPlayer = e => { const t = Xc.players; let n; if ("string" === typeof e) { const i = su(e), r = t[i]; if (r) return r; n = _a("#" + i) } else n = e; if (Ks(n)) { const { player: e, playerId: i } = n; if (e || t[i]) return e || t[i] } }, au.getAllPlayers = () => Object.keys(Xc.players).map((e => Xc.players[e])).filter(Boolean), au.players = Xc.players, au.getComponent = go.getComponent, au.registerComponent = (e, t) => { sl.isTech(t) && ms.warn("The ".concat(e, " tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)")), go.registerComponent.call(go, e, t) }, au.getTech = sl.getTech, au.registerTech = sl.registerTech, au.use = function (e, t) { al[e] = al[e] || [], al[e].push(t) }, Object.defineProperty(au, "middleware", { value: {}, writeable: !1, enumerable: !0 }), Object.defineProperty(au.middleware, "TERMINATOR", { value: ll, writeable: !1, enumerable: !0 }), au.browser = qs, au.obj = ks, au.mergeOptions = ru(9, "videojs.mergeOptions", "videojs.obj.merge", ws), au.defineLazyProperty = ru(9, "videojs.defineLazyProperty", "videojs.obj.defineLazyProperty", xs), au.bind = ru(9, "videojs.bind", "native Function.prototype.bind", Xa), au.registerPlugin = iu.registerPlugin, au.deregisterPlugin = iu.deregisterPlugin, au.plugin = (e, t) => (ms.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead"), iu.registerPlugin(e, t)), au.getPlugins = iu.getPlugins, au.getPlugin = iu.getPlugin, au.getPluginVersion = iu.getPluginVersion, au.addLanguage = function (e, t) { return e = ("" + e).toLowerCase(), au.options.languages = ws(au.options.languages, { [e]: t }), au.options.languages[e] }, au.log = ms, au.createLogger = gs, au.time = ko, au.createTimeRange = ru(9, "videojs.createTimeRange", "videojs.time.createTimeRanges", bo), au.createTimeRanges = ru(9, "videojs.createTimeRanges", "videojs.time.createTimeRanges", bo), au.formatTime = ru(9, "videojs.formatTime", "videojs.time.formatTime", xo), au.setFormatTime = ru(9, "videojs.setFormatTime", "videojs.time.setFormatTime", So), au.resetFormatTime = ru(9, "videojs.resetFormatTime", "videojs.time.resetFormatTime", wo), au.parseUrl = ru(9, "videojs.parseUrl", "videojs.url.parseUrl", qo), au.isCrossOrigin = ru(9, "videojs.isCrossOrigin", "videojs.url.isCrossOrigin", Ko), au.EventTarget = Ja, au.any = Wa, au.on = Fa, au.one = Va, au.off = za, au.trigger = Ha, au.xhr = Gn(), au.TextTrack = Jo, au.AudioTrack = Zo, au.VideoTrack = el, ["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach((e => { au[e] = function () { return ms.warn("videojs.".concat(e, "() is deprecated; use videojs.dom.").concat(e, "() instead")), wa[e].apply(null, arguments) } })), au.computedStyle = ru(9, "videojs.computedStyle", "videojs.dom.computedStyle", Sa), au.dom = wa, au.fn = Ya, au.num = Ml, au.str = mo, au.url = $o; class ou { constructor(e) { let t = this; return t.id = e.id, t.label = t.id, t.width = e.width, t.height = e.height, t.bitrate = e.bandwidth, t.frameRate = e.frameRate, t.enabled_ = e.enabled, Object.defineProperty(t, "enabled", { get: () => t.enabled_(), set(e) { t.enabled_(e) } }), t } } class lu extends au.EventTarget { constructor() { super(); let e = this; return e.levels_ = [], e.selectedIndex_ = -1, Object.defineProperty(e, "selectedIndex", { get: () => e.selectedIndex_ }), Object.defineProperty(e, "length", { get: () => e.levels_.length }), e } addQualityLevel(e) { let t = this.getQualityLevelById(e.id); if (t) return t; const n = this.levels_.length; return t = new ou(e), "" + n in this || Object.defineProperty(this, n, { get() { return this.levels_[n] } }), this.levels_.push(t), this.trigger({ qualityLevel: t, type: "addqualitylevel" }), t } removeQualityLevel(e) { let t = null; for (let n = 0, i = this.length; n < i; n++)if (this[n] === e) { t = this.levels_.splice(n, 1)[0], this.selectedIndex_ === n ? this.selectedIndex_ = -1 : this.selectedIndex_ > n && this.selectedIndex_--; break } return t && this.trigger({ qualityLevel: e, type: "removequalitylevel" }), t } getQualityLevelById(e) { for (let t = 0, n = this.length; t < n; t++) { const n = this[t]; if (n.id === e) return n } return null } dispose() { this.selectedIndex_ = -1, this.levels_.length = 0 } } lu.prototype.allowedEvents_ = { change: "change", addqualitylevel: "addqualitylevel", removequalitylevel: "removequalitylevel" }; for (const n in lu.prototype.allowedEvents_) lu.prototype["on" + n] = null; var cu = "3.0.0"; const uu = au.registerPlugin || au.plugin, du = function (e) { return function (e, t) { const n = e.qualityLevels, i = new lu, r = function () { i.dispose(), e.qualityLevels = n, e.off("dispose", r) }; return e.on("dispose", r), e.qualityLevels = () => i, e.qualityLevels.VERSION = cu, i }(this, au.mergeOptions({}, e)) }; uu("qualityLevels", du), du.VERSION = cu; const hu = Jn, pu = (e, t) => t && t.responseURL && e !== t.responseURL ? t.responseURL : e, fu = e => au.log.debug ? au.log.debug.bind(au, "VHS:", "".concat(e, " >")) : function () { }; function mu() { const e = au.obj || au, t = e.merge || e.mergeOptions; for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++)i[r] = arguments[r]; return t.apply(e, i) } function gu() { const e = au.time || au, t = e.createTimeRanges || e.createTimeRanges; for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++)i[r] = arguments[r]; return t.apply(e, i) } const yu = 1 / 30, vu = .1, bu = function (e, t) { const n = []; let i; if (e && e.length) for (i = 0; i < e.length; i++)t(e.start(i), e.end(i)) && n.push([e.start(i), e.end(i)]); return gu(n) }, _u = function (e, t) { return bu(e, (function (e, n) { return e - vu <= t && n + vu >= t })) }, Tu = function (e, t) { return bu(e, (function (e) { return e - yu >= t })) }, Su = e => { const t = []; if (!e || !e.length) return ""; for (let n = 0; n < e.length; n++)t.push(e.start(n) + " => " + e.end(n)); return t.join(", ") }, wu = e => { const t = []; for (let n = 0; n < e.length; n++)t.push({ start: e.start(n), end: e.end(n) }); return t }, xu = function (e) { if (e && e.length && e.end) return e.end(e.length - 1) }, ku = function (e, t) { let n = 0; if (!e || !e.length) return n; for (let i = 0; i < e.length; i++) { const r = e.start(i), s = e.end(i); t > s || (n += t > r && t <= s ? s - t : s - r) } return n }, Eu = (e, t) => { if (!t.preload) return t.duration; let n = 0; return (t.parts || []).forEach((function (e) { n += e.duration })), (t.preloadHints || []).forEach((function (t) { "PART" === t.type && (n += e.partTargetDuration) })), n }, Cu = e => (e.segments || []).reduce(((e, t, n) => (t.parts ? t.parts.forEach((function (i, r) { e.push({ duration: i.duration, segmentIndex: n, partIndex: r, part: i, segment: t }) })) : e.push({ duration: t.duration, segmentIndex: n, partIndex: null, segment: t, part: null }), e)), []), Pu = e => { const t = e.segments && e.segments.length && e.segments[e.segments.length - 1]; return t && t.parts || [] }, Iu = e => { let { preloadSegment: t } = e; if (!t) return; const { parts: n, preloadHints: i } = t; let r = (i || []).reduce(((e, t) => e + ("PART" === t.type ? 1 : 0)), 0); return r += n && n.length ? n.length : 0, r }, Lu = (e, t) => { if (t.endList) return 0; if (e && e.suggestedPresentationDelay) return e.suggestedPresentationDelay; const n = Pu(t).length > 0; return n && t.serverControl && t.serverControl.partHoldBack ? t.serverControl.partHoldBack : n && t.partTargetDuration ? 3 * t.partTargetDuration : t.serverControl && t.serverControl.holdBack ? t.serverControl.holdBack : t.targetDuration ? 3 * t.targetDuration : 0 }, Ou = function (e, t, n) { if ("undefined" === typeof t && (t = e.mediaSequence + e.segments.length), t < e.mediaSequence) return 0; const i = function (e, t) { let n = 0, i = t - e.mediaSequence, r = e.segments[i]; if (r) { if ("undefined" !== typeof r.start) return { result: r.start, precise: !0 }; if ("undefined" !== typeof r.end) return { result: r.end - r.duration, precise: !0 } } for (; i--;) { if (r = e.segments[i], "undefined" !== typeof r.end) return { result: n + r.end, precise: !0 }; if (n += Eu(e, r), "undefined" !== typeof r.start) return { result: n + r.start, precise: !0 } } return { result: n, precise: !1 } }(e, t); if (i.precise) return i.result; const r = function (e, t) { let n, i = 0, r = t - e.mediaSequence; for (; r < e.segments.length; r++) { if (n = e.segments[r], "undefined" !== typeof n.start) return { result: n.start - i, precise: !0 }; if (i += Eu(e, n), "undefined" !== typeof n.end) return { result: n.end - i, precise: !0 } } return { result: -1, precise: !1 } }(e, t); return r.precise ? r.result : i.result + n }, Au = function (e, t, n) { if (!e) return 0; if ("number" !== typeof n && (n = 0), "undefined" === typeof t) { if (e.totalDuration) return e.totalDuration; if (!e.endList) return Un()[1 / 0] } return Ou(e, t, n) }, Nu = function (e) { let { defaultDuration: t, durationList: n, startIndex: i, endIndex: r } = e, s = 0; if (i > r && ([i, r] = [r, i]), i < 0) { for (let e = i; e < Math.min(0, r); e++)s += t; i = 0 } for (let a = i; a < r; a++)s += n[a].duration; return s }, ju = function (e, t, n, i) { if (!e || !e.segments) return null; if (e.endList) return Au(e); if (null === t) return null; t = t || 0; let r = Ou(e, e.mediaSequence + e.segments.length, t); return n && (r -= i = "number" === typeof i ? i : Lu(null, e)), Math.max(0, r) }, Du = function (e) { return e.excludeUntil && e.excludeUntil > Date.now() }, Mu = function (e) { return e.excludeUntil && e.excludeUntil === 1 / 0 }, Ru = function (e) { const t = Du(e); return !e.disabled && !t }, Uu = function (e, t) { return t.attributes && t.attributes[e] }, Bu = (e, t) => { if (1 === e.playlists.length) return !0; const n = t.attributes.BANDWIDTH || Number.MAX_VALUE; return 0 === e.playlists.filter((e => !!Ru(e) && (e.attributes.BANDWIDTH || 0) < n)).length }, Fu = (e, t) => !(!e && !t || !e && t || e && !t) && (e === t || (!(!e.id || !t.id || e.id !== t.id) || (!(!e.resolvedUri || !t.resolvedUri || e.resolvedUri !== t.resolvedUri) || !(!e.uri || !t.uri || e.uri !== t.uri)))), zu = function (e, t) { const n = e && e.mediaGroups && e.mediaGroups.AUDIO || {}; let i = !1; for (const r in n) { for (const e in n[r]) if (i = t(n[r][e]), i) break; if (i) break } return !!i }, Hu = e => { if (!e || !e.playlists || !e.playlists.length) { return zu(e, (e => e.playlists && e.playlists.length || e.uri)) } for (let t = 0; t < e.playlists.length; t++) { const n = e.playlists[t], i = n.attributes && n.attributes.CODECS; if (i && i.split(",").every((e => mi(e)))) continue; if (!zu(e, (e => Fu(n, e)))) return !1 } return !0 }; var Vu = { liveEdgeDelay: Lu, duration: Au, seekable: function (e, t, n) { const i = t || 0, r = ju(e, t, !0, n); return null === r ? gu() : gu(i, r) }, getMediaInfoForTime: function (e) { let { playlist: t, currentTime: n, startingSegmentIndex: i, startingPartIndex: r, startTime: s, exactManifestTimings: a } = e, o = n - s; const l = Cu(t); let c = 0; for (let u = 0; u < l.length; u++) { const e = l[u]; if (i === e.segmentIndex && ("number" !== typeof r || "number" !== typeof e.partIndex || r === e.partIndex)) { c = u; break } } if (o < 0) { if (c > 0) for (let e = c - 1; e >= 0; e--) { const n = l[e]; if (o += n.duration, a) { if (o < 0) continue } else if (o + yu <= 0) continue; return { partIndex: n.partIndex, segmentIndex: n.segmentIndex, startTime: s - Nu({ defaultDuration: t.targetDuration, durationList: l, startIndex: c, endIndex: e }) } } return { partIndex: l[0] && l[0].partIndex || null, segmentIndex: l[0] && l[0].segmentIndex || 0, startTime: n } } if (c < 0) { for (let e = c; e < 0; e++)if (o -= t.targetDuration, o < 0) return { partIndex: l[0] && l[0].partIndex || null, segmentIndex: l[0] && l[0].segmentIndex || 0, startTime: n }; c = 0 } for (let u = c; u < l.length; u++) { const e = l[u]; if (o -= e.duration, a) { if (o > 0) continue } else if (o - yu >= 0) continue; return { partIndex: e.partIndex, segmentIndex: e.segmentIndex, startTime: s + Nu({ defaultDuration: t.targetDuration, durationList: l, startIndex: c, endIndex: u }) } } return { segmentIndex: l[l.length - 1].segmentIndex, partIndex: l[l.length - 1].partIndex, startTime: n } }, isEnabled: Ru, isDisabled: function (e) { return e.disabled }, isExcluded: Du, isIncompatible: Mu, playlistEnd: ju, isAes: function (e) { for (let t = 0; t < e.segments.length; t++)if (e.segments[t].key) return !0; return !1 }, hasAttribute: Uu, estimateSegmentRequestTime: function (e, t, n) { let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0; if (!Uu("BANDWIDTH", n)) return NaN; return (e * n.attributes.BANDWIDTH - 8 * i) / t }, isLowestEnabledRendition: Bu, isAudioOnly: Hu, playlistMatch: Fu, segmentDurationWithParts: Eu }; const { log: Wu } = au, qu = (e, t) => "".concat(e, "-").concat(t), Gu = (e, t, n) => "placeholder-uri-".concat(e, "-").concat(t, "-").concat(n), Xu = (e, t) => { e.mediaGroups && ["AUDIO", "SUBTITLES"].forEach((n => { if (e.mediaGroups[n]) for (const i in e.mediaGroups[n]) for (const r in e.mediaGroups[n][i]) { const s = e.mediaGroups[n][i][r]; t(s, n, i, r) } })) }, Ku = e => { let { playlist: t, uri: n, id: i } = e; t.id = i, t.playlistErrors_ = 0, n && (t.uri = n), t.attributes = t.attributes || {} }, $u = function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Gu; e.uri = t; for (let r = 0; r < e.playlists.length; r++)if (!e.playlists[r].uri) { const t = "placeholder-uri-".concat(r); e.playlists[r].uri = t } const i = Hu(e); Xu(e, ((t, r, s, a) => { if (!t.playlists || !t.playlists.length) { if (i && "AUDIO" === r && !t.uri) for (let t = 0; t < e.playlists.length; t++) { const n = e.playlists[t]; if (n.attributes && n.attributes.AUDIO && n.attributes.AUDIO === s) return } t.playlists = [Zn({}, t)] } t.playlists.forEach((function (t, i) { const o = n(r, s, a, t), l = qu(i, o); t.uri ? t.resolvedUri = t.resolvedUri || hu(e.uri, t.uri) : (t.uri = 0 === i ? o : l, t.resolvedUri = t.uri), t.id = t.id || l, t.attributes = t.attributes || {}, e.playlists[t.id] = t, e.playlists[t.uri] = t })) })), (e => { let t = e.playlists.length; for (; t--;) { const n = e.playlists[t]; Ku({ playlist: n, id: qu(t, n.uri) }), n.resolvedUri = hu(e.uri, n.uri), e.playlists[n.id] = n, e.playlists[n.uri] = n, n.attributes.BANDWIDTH || Wu.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.") } })(e), (e => { Xu(e, (t => { t.uri && (t.resolvedUri = hu(e.uri, t.uri)) })) })(e) }, { EventTarget: Yu } = au, Qu = (e, t) => { if (!e) return t; const n = mu(e, t); if (e.preloadHints && !t.preloadHints && delete n.preloadHints, e.parts && !t.parts) delete n.parts; else if (e.parts && t.parts) for (let i = 0; i < t.parts.length; i++)e.parts && e.parts[i] && (n.parts[i] = mu(e.parts[i], t.parts[i])); return !e.skipped && t.skipped && (n.skipped = !1), e.preload && !t.preload && (n.preload = !1), n }, Ju = (e, t) => { !e.resolvedUri && e.uri && (e.resolvedUri = hu(t, e.uri)), e.key && !e.key.resolvedUri && (e.key.resolvedUri = hu(t, e.key.uri)), e.map && !e.map.resolvedUri && (e.map.resolvedUri = hu(t, e.map.uri)), e.map && e.map.key && !e.map.key.resolvedUri && (e.map.key.resolvedUri = hu(t, e.map.key.uri)), e.parts && e.parts.length && e.parts.forEach((e => { e.resolvedUri || (e.resolvedUri = hu(t, e.uri)) })), e.preloadHints && e.preloadHints.length && e.preloadHints.forEach((e => { e.resolvedUri || (e.resolvedUri = hu(t, e.uri)) })) }, Zu = function (e) { const t = e.segments || [], n = e.preloadSegment; if (n && n.parts && n.parts.length) { if (n.preloadHints) for (let e = 0; e < n.preloadHints.length; e++)if ("MAP" === n.preloadHints[e].type) return t; n.duration = e.targetDuration, n.preload = !0, t.push(n) } return t }, ed = (e, t) => e === t || e.segments && t.segments && e.segments.length === t.segments.length && e.endList === t.endList && e.mediaSequence === t.mediaSequence && e.preloadSegment === t.preloadSegment, td = function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ed; const i = mu(e, {}), r = i.playlists[t.id]; if (!r) return null; if (n(r, t)) return null; t.segments = Zu(t); const s = mu(r, t); if (s.preloadSegment && !t.preloadSegment && delete s.preloadSegment, r.segments) { if (t.skip) { t.segments = t.segments || []; for (let e = 0; e < t.skip.skippedSegments; e++)t.segments.unshift({ skipped: !0 }) } s.segments = ((e, t, n) => { const i = e.slice(), r = t.slice(); n = n || 0; const s = []; let a; for (let o = 0; o < r.length; o++) { const e = i[o + n], t = r[o]; e ? (a = e.map || a, s.push(Qu(e, t))) : (a && !t.map && (t.map = a), s.push(t)) } return s })(r.segments, t.segments, t.mediaSequence - r.mediaSequence) } s.segments.forEach((e => { Ju(e, s.resolvedUri) })); for (let a = 0; a < i.playlists.length; a++)i.playlists[a].id === t.id && (i.playlists[a] = s); return i.playlists[t.id] = s, i.playlists[t.uri] = s, Xu(e, ((e, n, i, r) => { if (e.playlists) for (let a = 0; a < e.playlists.length; a++)t.id === e.playlists[a].id && (e.playlists[a] = s) })), i }, nd = (e, t) => { const n = e.segments || [], i = n[n.length - 1], r = i && i.parts && i.parts[i.parts.length - 1], s = r && r.duration || i && i.duration; return t && s ? 1e3 * s : 500 * (e.partTargetDuration || e.targetDuration || 10) }; class id extends Yu { constructor(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (super(), !e) throw new Error("A non-empty playlist URL or object is required"); this.logger_ = fu("PlaylistLoader"); const { withCredentials: i = !1 } = n; this.src = e, this.vhs_ = t, this.withCredentials = i; const r = t.options_; this.customTagParsers = r && r.customTagParsers || [], this.customTagMappers = r && r.customTagMappers || [], this.llhls = r && r.llhls, this.state = "HAVE_NOTHING", this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this), this.on("mediaupdatetimeout", this.handleMediaupdatetimeout_) } handleMediaupdatetimeout_() { if ("HAVE_METADATA" !== this.state) return; const e = this.media(); let t = hu(this.main.uri, e.uri); this.llhls && (t = ((e, t) => { if (t.endList || !t.serverControl) return e; const n = {}; if (t.serverControl.canBlockReload) { const { preloadSegment: e } = t; let i = t.mediaSequence + t.segments.length; if (e) { const r = e.parts || [], s = Iu(t) - 1; s > -1 && s !== r.length - 1 && (n._HLS_part = s), (s > -1 || r.length) && i-- } n._HLS_msn = i } if (t.serverControl && t.serverControl.canSkipUntil && (n._HLS_skip = t.serverControl.canSkipDateranges ? "v2" : "YES"), Object.keys(n).length) { const t = new (Un().URL)(e);["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach((function (e) { n.hasOwnProperty(e) && t.searchParams.set(e, n[e]) })), e = t.toString() } return e })(t, e)), this.state = "HAVE_CURRENT_METADATA", this.request = this.vhs_.xhr({ uri: t, withCredentials: this.withCredentials }, ((e, t) => { if (this.request) return e ? this.playlistRequestError(this.request, this.media(), "HAVE_METADATA") : void this.haveMetadata({ playlistString: this.request.responseText, url: this.media().uri, id: this.media().id }) })) } playlistRequestError(e, t, n) { const { uri: i, id: r } = t; this.request = null, n && (this.state = n), this.error = { playlist: this.main.playlists[r], status: e.status, message: "HLS playlist request error at URL: ".concat(i, "."), responseText: e.responseText, code: e.status >= 500 ? 4 : 2 }, this.trigger("error") } parseManifest_(e) { let { url: t, manifestString: n } = e; return (e => { let { onwarn: t, oninfo: n, manifestString: i, customTagParsers: r = [], customTagMappers: s = [], llhls: a } = e; const o = new ci; t && o.on("warn", t), n && o.on("info", n), r.forEach((e => o.addParser(e))), s.forEach((e => o.addTagMapper(e))), o.push(i), o.end(); const l = o.manifest; if (a || (["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach((function (e) { l.hasOwnProperty(e) && delete l[e] })), l.segments && l.segments.forEach((function (e) { ["parts", "preloadHints"].forEach((function (t) { e.hasOwnProperty(t) && delete e[t] })) }))), !l.targetDuration) { let e = 10; l.segments && l.segments.length && (e = l.segments.reduce(((e, t) => Math.max(e, t.duration)), 0)), t && t("manifest has no targetDuration defaulting to ".concat(e)), l.targetDuration = e } const c = Pu(l); if (c.length && !l.partTargetDuration) { const e = c.reduce(((e, t) => Math.max(e, t.duration)), 0); t && (t("manifest has no partTargetDuration defaulting to ".concat(e)), Wu.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.")), l.partTargetDuration = e } return l })({ onwarn: e => { let { message: n } = e; return this.logger_("m3u8-parser warn for ".concat(t, ": ").concat(n)) }, oninfo: e => { let { message: n } = e; return this.logger_("m3u8-parser info for ".concat(t, ": ").concat(n)) }, manifestString: n, customTagParsers: this.customTagParsers, customTagMappers: this.customTagMappers, llhls: this.llhls }) } haveMetadata(e) { let { playlistString: t, playlistObject: n, url: i, id: r } = e; this.request = null, this.state = "HAVE_METADATA"; const s = n || this.parseManifest_({ url: i, manifestString: t }); s.lastRequest = Date.now(), Ku({ playlist: s, uri: i, id: r }); const a = td(this.main, s); this.targetDuration = s.partTargetDuration || s.targetDuration, this.pendingMedia_ = null, a ? (this.main = a, this.media_ = this.main.playlists[r]) : this.trigger("playlistunchanged"), this.updateMediaUpdateTimeout_(nd(this.media(), !!a)), this.trigger("loadedplaylist") } dispose() { this.trigger("dispose"), this.stopRequest(), Un().clearTimeout(this.mediaUpdateTimeout), Un().clearTimeout(this.finalRenditionTimeout), this.off() } stopRequest() { if (this.request) { const e = this.request; this.request = null, e.onreadystatechange = null, e.abort() } } media(e, t) { if (!e) return this.media_; if ("HAVE_NOTHING" === this.state) throw new Error("Cannot switch media playlist from " + this.state); if ("string" === typeof e) { if (!this.main.playlists[e]) throw new Error("Unknown playlist URI: " + e); e = this.main.playlists[e] } if (Un().clearTimeout(this.finalRenditionTimeout), t) { const t = (e.partTargetDuration || e.targetDuration) / 2 * 1e3 || 5e3; return void (this.finalRenditionTimeout = Un().setTimeout(this.media.bind(this, e, !1), t)) } const n = this.state, i = !this.media_ || e.id !== this.media_.id, r = this.main.playlists[e.id]; if (r && r.endList || e.endList && e.segments.length) return this.request && (this.request.onreadystatechange = null, this.request.abort(), this.request = null), this.state = "HAVE_METADATA", this.media_ = e, void (i && (this.trigger("mediachanging"), "HAVE_MAIN_MANIFEST" === n ? this.trigger("loadedmetadata") : this.trigger("mediachange"))); if (this.updateMediaUpdateTimeout_(nd(e, !0)), i) { if (this.state = "SWITCHING_MEDIA", this.request) { if (e.resolvedUri === this.request.url) return; this.request.onreadystatechange = null, this.request.abort(), this.request = null } this.media_ && this.trigger("mediachanging"), this.pendingMedia_ = e, this.request = this.vhs_.xhr({ uri: e.resolvedUri, withCredentials: this.withCredentials }, ((t, i) => { if (this.request) { if (e.lastRequest = Date.now(), e.resolvedUri = pu(e.resolvedUri, i), t) return this.playlistRequestError(this.request, e, n); this.haveMetadata({ playlistString: i.responseText, url: e.uri, id: e.id }), "HAVE_MAIN_MANIFEST" === n ? this.trigger("loadedmetadata") : this.trigger("mediachange") } })) } } pause() { this.mediaUpdateTimeout && (Un().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.stopRequest(), "HAVE_NOTHING" === this.state && (this.started = !1), "SWITCHING_MEDIA" === this.state ? this.media_ ? this.state = "HAVE_METADATA" : this.state = "HAVE_MAIN_MANIFEST" : "HAVE_CURRENT_METADATA" === this.state && (this.state = "HAVE_METADATA") } load(e) { this.mediaUpdateTimeout && (Un().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null); const t = this.media(); if (e) { const e = t ? (t.partTargetDuration || t.targetDuration) / 2 * 1e3 : 5e3; this.mediaUpdateTimeout = Un().setTimeout((() => { this.mediaUpdateTimeout = null, this.load() }), e) } else this.started ? t && !t.endList ? this.trigger("mediaupdatetimeout") : this.trigger("loadedplaylist") : this.start() } updateMediaUpdateTimeout_(e) { this.mediaUpdateTimeout && (Un().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.media() && !this.media().endList && (this.mediaUpdateTimeout = Un().setTimeout((() => { this.mediaUpdateTimeout = null, this.trigger("mediaupdatetimeout"), this.updateMediaUpdateTimeout_(e) }), e)) } start() { if (this.started = !0, "object" === typeof this.src) return this.src.uri || (this.src.uri = Un().location.href), this.src.resolvedUri = this.src.uri, void setTimeout((() => { this.setupInitialPlaylist(this.src) }), 0); this.request = this.vhs_.xhr({ uri: this.src, withCredentials: this.withCredentials }, ((e, t) => { if (!this.request) return; if (this.request = null, e) return this.error = { status: t.status, message: "HLS playlist request error at URL: ".concat(this.src, "."), responseText: t.responseText, code: 2 }, "HAVE_NOTHING" === this.state && (this.started = !1), this.trigger("error"); this.src = pu(this.src, t); const n = this.parseManifest_({ manifestString: t.responseText, url: this.src }); this.setupInitialPlaylist(n) })) } srcUri() { return "string" === typeof this.src ? this.src : this.src.uri } setupInitialPlaylist(e) { if (this.state = "HAVE_MAIN_MANIFEST", e.playlists) return this.main = e, $u(this.main, this.srcUri()), e.playlists.forEach((e => { e.segments = Zu(e), e.segments.forEach((t => { Ju(t, e.resolvedUri) })) })), this.trigger("loadedplaylist"), void (this.request || this.media(this.main.playlists[0])); const t = this.srcUri() || Un().location.href; this.main = ((e, t) => { const n = qu(0, t), i = { mediaGroups: { AUDIO: {}, VIDEO: {}, "CLOSED-CAPTIONS": {}, SUBTITLES: {} }, uri: Un().location.href, resolvedUri: Un().location.href, playlists: [{ uri: t, id: n, resolvedUri: t, attributes: {} }] }; return i.playlists[n] = i.playlists[0], i.playlists[t] = i.playlists[0], i })(0, t), this.haveMetadata({ playlistObject: e, url: t, id: this.main.playlists[0].id }), this.trigger("loadedmetadata") } } const { xhr: rd } = au, sd = function (e, t, n, i) { const r = "arraybuffer" === e.responseType ? e.response : e.responseText; !t && r && (e.responseTime = Date.now(), e.roundTripTime = e.responseTime - e.requestTime, e.bytesReceived = r.byteLength || r.length, e.bandwidth || (e.bandwidth = Math.floor(e.bytesReceived / e.roundTripTime * 8 * 1e3))), n.headers && (e.responseHeaders = n.headers), t && "ETIMEDOUT" === t.code && (e.timedout = !0), t || e.aborted || 200 === n.statusCode || 206 === n.statusCode || 0 === n.statusCode || (t = new Error("XHR Failed with a response of: " + (e && (r || e.responseText)))), i(t, e) }, ad = function () { const e = function e(t, n) { t = mu({ timeout: 45e3 }, t); const i = e.beforeRequest || au.Vhs.xhr.beforeRequest; if (i && "function" === typeof i) { const e = i(t); e && (t = e) } const r = (!0 === au.Vhs.xhr.original ? rd : au.Vhs.xhr)(t, (function (e, t) { return sd(r, e, t, n) })), s = r.abort; return r.abort = function () { return r.aborted = !0, s.apply(r, arguments) }, r.uri = t.uri, r.requestTime = Date.now(), r }; return e.original = !0, e }, od = function (e) { const t = {}; return e.byterange && (t.Range = function (e) { let t; const n = e.offset; return t = "bigint" === typeof e.offset || "bigint" === typeof e.length ? Un().BigInt(e.offset) + Un().BigInt(e.length) - Un().BigInt(1) : e.offset + e.length - 1, "bytes=" + n + "-" + t }(e.byterange)), t }, ld = function (e, t) { return e.start(t) + "-" + e.end(t) }, cd = function (e, t) { const n = e.toString(16); return "00".substring(0, 2 - n.length) + n + (t % 2 ? " " : "") }, ud = function (e) { return e >= 32 && e < 126 ? String.fromCharCode(e) : "." }, dd = function (e) { const t = {}; return Object.keys(e).forEach((n => { const i = e[n]; wi(i) ? t[n] = { bytes: i.buffer, byteOffset: i.byteOffset, byteLength: i.byteLength } : t[n] = i })), t }, hd = function (e) { const t = e.byterange || { length: 1 / 0, offset: 0 }; return [t.length, t.offset, e.resolvedUri].join(",") }, pd = function (e) { return e.resolvedUri }, fd = e => { const t = Array.prototype.slice.call(e), n = 16; let i, r, s = ""; for (let a = 0; a < t.length / n; a++)i = t.slice(a * n, a * n + n).map(cd).join(""), r = t.slice(a * n, a * n + n).map(ud).join(""), s += i + " " + r + "\n"; return s }; var md = Object.freeze({ __proto__: null, createTransferableMessage: dd, initSegmentId: hd, segmentKeyId: pd, hexDump: fd, tagDump: e => { let { bytes: t } = e; return fd(t) }, textRanges: e => { let t, n = ""; for (t = 0; t < e.length; t++)n += ld(e, t) + " "; return n } }); const gd = e => { let { playlist: t, time: n, callback: i } = e; if (!i) throw new Error("getProgramTime: callback must be provided"); if (!t || void 0 === n) return i({ message: "getProgramTime: playlist and time must be provided" }); const r = ((e, t) => { if (!t || !t.segments || 0 === t.segments.length) return null; let n, i = 0; for (let s = 0; s < t.segments.length && (n = t.segments[s], i = n.videoTimingInfo ? n.videoTimingInfo.transmuxedPresentationEnd : i + n.duration, !(e <= i)); s++); const r = t.segments[t.segments.length - 1]; if (r.videoTimingInfo && r.videoTimingInfo.transmuxedPresentationEnd < e) return null; if (e > i) { if (e > i + .25 * r.duration) return null; n = r } return { segment: n, estimatedStart: n.videoTimingInfo ? n.videoTimingInfo.transmuxedPresentationStart : i - n.duration, type: n.videoTimingInfo ? "accurate" : "estimate" } })(n, t); if (!r) return i({ message: "valid programTime was not found" }); if ("estimate" === r.type) return i({ message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again", seekTime: r.estimatedStart }); const s = { mediaSeconds: n }, a = ((e, t) => { if (!t.dateTimeObject) return null; const n = t.videoTimingInfo.transmuxerPrependedSeconds, i = e - (t.videoTimingInfo.transmuxedPresentationStart + n); return new Date(t.dateTimeObject.getTime() + 1e3 * i) })(n, r.segment); return a && (s.programDateTime = a.toISOString()), i(null, s) }, yd = e => { let { programTime: t, playlist: n, retryCount: i = 2, seekTo: r, pauseAfterSeek: s = !0, tech: a, callback: o } = e; if (!o) throw new Error("seekToProgramTime: callback must be provided"); if ("undefined" === typeof t || !n || !r) return o({ message: "seekToProgramTime: programTime, seekTo and playlist must be provided" }); if (!n.endList && !a.hasStarted_) return o({ message: "player must be playing a live stream to start buffering" }); if (!(e => { if (!e.segments || 0 === e.segments.length) return !1; for (let t = 0; t < e.segments.length; t++)if (!e.segments[t].dateTimeObject) return !1; return !0 })(n)) return o({ message: "programDateTime tags must be provided in the manifest " + n.resolvedUri }); const l = ((e, t) => { let n; try { n = new Date(e) } catch (l) { return null } if (!t || !t.segments || 0 === t.segments.length) return null; let i = t.segments[0]; if (n < i.dateTimeObject) return null; for (let c = 0; c < t.segments.length - 1 && (i = t.segments[c], !(n < t.segments[c + 1].dateTimeObject)); c++); const r = t.segments[t.segments.length - 1], s = r.dateTimeObject, a = r.videoTimingInfo ? (o = r.videoTimingInfo).transmuxedPresentationEnd - o.transmuxedPresentationStart - o.transmuxerPrependedSeconds : r.duration + .25 * r.duration; var o; return n > new Date(s.getTime() + 1e3 * a) ? null : (n > s && (i = r), { segment: i, estimatedStart: i.videoTimingInfo ? i.videoTimingInfo.transmuxedPresentationStart : Vu.duration(t, t.mediaSequence + t.segments.indexOf(i)), type: i.videoTimingInfo ? "accurate" : "estimate" }) })(t, n); if (!l) return o({ message: "".concat(t, " was not found in the stream") }); const c = l.segment, u = ((e, t) => { let n, i; try { n = new Date(e), i = new Date(t) } catch (s) { } const r = n.getTime(); return (i.getTime() - r) / 1e3 })(c.dateTimeObject, t); if ("estimate" === l.type) return 0 === i ? o({ message: "".concat(t, " is not buffered yet. Try again") }) : (r(l.estimatedStart + u), void a.one("seeked", (() => { yd({ programTime: t, playlist: n, retryCount: i - 1, seekTo: r, pauseAfterSeek: s, tech: a, callback: o }) }))); const d = c.start + u; a.one("seeked", (() => o(null, a.currentTime()))), s && a.pause(), r(d) }, vd = (e, t) => { if (4 === e.readyState) return t() }, bd = (e, t, n) => { let i, r = [], s = !1; const a = function (e, t, i, r) { return t.abort(), s = !0, n(e, t, i, r) }, o = function (e, t) { if (s) return; if (e) return a(e, t, "", r); const n = t.responseText.substring(r && r.byteLength || 0, t.responseText.length); if (r = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; if ((t = t.filter((function (e) { return e && (e.byteLength || e.length) && "string" !== typeof e }))).length <= 1) return xi(t[0]); var i = t.reduce((function (e, t, n) { return e + (t.byteLength || t.length) }), 0), r = new Uint8Array(i), s = 0; return t.forEach((function (e) { e = xi(e), r.set(e, s), s += e.byteLength })), r }(r, Ii(n, !0)), i = i || Br(r), r.length < 10 || i && r.length < i + 2) return vd(t, (() => a(e, t, "", r))); const o = rs(r); return "ts" === o && r.length < 188 || !o && r.length < 376 ? vd(t, (() => a(e, t, "", r))) : a(null, t, o, r) }, l = { uri: e, beforeSend(e) { e.overrideMimeType("text/plain; charset=x-user-defined"), e.addEventListener("progress", (function (t) { let { total: n, loaded: i } = t; return sd(e, null, { statusCode: e.status }, o) })) } }, c = t(l, (function (e, t) { return sd(c, e, t, o) })); return c }, { EventTarget: _d } = au, Td = function (e, t) { if (!ed(e, t)) return !1; if (e.sidx && t.sidx && (e.sidx.offset !== t.sidx.offset || e.sidx.length !== t.sidx.length)) return !1; if (!e.sidx && t.sidx || e.sidx && !t.sidx) return !1; if (e.segments && !t.segments || !e.segments && t.segments) return !1; if (!e.segments && !t.segments) return !0; for (let n = 0; n < e.segments.length; n++) { const i = e.segments[n], r = t.segments[n]; if (i.uri !== r.uri) return !1; if (!i.byterange && !r.byterange) continue; const s = i.byterange, a = r.byterange; if (s && !a || !s && a) return !1; if (s.offset !== a.offset || s.length !== a.length) return !1 } return !0 }, Sd = (e, t, n, i) => { const r = i.attributes.NAME || n; return "placeholder-uri-".concat(e, "-").concat(t, "-").concat(r) }, wd = (e, t, n) => { let i = !0, r = mu(e, { duration: t.duration, minimumUpdatePeriod: t.minimumUpdatePeriod, timelineStarts: t.timelineStarts }); for (let s = 0; s < t.playlists.length; s++) { const e = t.playlists[s]; if (e.sidx) { const t = ir(e.sidx); n && n[t] && n[t].sidx && Qi(e, n[t].sidx, e.sidx.resolvedUri) } const a = td(r, e, Td); a && (r = a, i = !1) } return Xu(t, ((e, t, n, s) => { if (e.playlists && e.playlists.length) { const a = e.playlists[0].id, o = td(r, e.playlists[0], Td); o && (r = o, s in r.mediaGroups[t][n] || (r.mediaGroups[t][n][s] = e), r.mediaGroups[t][n][s].playlists[0] = r.playlists[a], i = !1) } })), ((e, t) => { Xu(e, ((n, i, r, s) => { s in t.mediaGroups[i][r] || delete e.mediaGroups[i][r][s] })) })(r, t), t.minimumUpdatePeriod !== e.minimumUpdatePeriod && (i = !1), i ? null : r }, xd = (e, t) => { const n = {}; for (const s in e) { const a = e[s].sidx; if (a) { const e = ir(a); if (!t[e]) break; const s = t[e].sidxInfo; i = s, r = a, (Boolean(!i.map && !r.map) || Boolean(i.map && r.map && i.map.byterange.offset === r.map.byterange.offset && i.map.byterange.length === r.map.byterange.length)) && i.uri === r.uri && i.byterange.offset === r.byterange.offset && i.byterange.length === r.byterange.length && (n[e] = t[e]) } } var i, r; return n }; class kd extends _d { constructor(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = arguments.length > 3 ? arguments[3] : void 0; super(), this.mainPlaylistLoader_ = i || this, i || (this.isMain_ = !0); const { withCredentials: r = !1 } = n; if (this.vhs_ = t, this.withCredentials = r, !e) throw new Error("A non-empty playlist URL or object is required"); this.on("minimumUpdatePeriod", (() => { this.refreshXml_() })), this.on("mediaupdatetimeout", (() => { this.refreshMedia_(this.media().id) })), this.state = "HAVE_NOTHING", this.loadedPlaylists_ = {}, this.logger_ = fu("DashPlaylistLoader"), this.isMain_ ? (this.mainPlaylistLoader_.srcUrl = e, this.mainPlaylistLoader_.sidxMapping_ = {}) : this.childPlaylist_ = e } requestErrored_(e, t, n) { return !this.request || (this.request = null, e ? (this.error = "object" !== typeof e || e instanceof Error ? { status: t.status, message: "DASH request error at URL: " + t.uri, response: t.response, code: 2 } : e, n && (this.state = n), this.trigger("error"), !0) : void 0) } addSidxSegments_(e, t, n) { const i = e.sidx && ir(e.sidx); if (!e.sidx || !i || this.mainPlaylistLoader_.sidxMapping_[i]) return void (this.mediaRequest_ = Un().setTimeout((() => n(!1)), 0)); const r = pu(e.sidx.resolvedUri), s = (r, s) => { if (this.requestErrored_(r, s, t)) return; const a = this.mainPlaylistLoader_.sidxMapping_; let o; try { o = Rr()(xi(s.response).subarray(8)) } catch (l) { return void this.requestErrored_(l, s, t) } return a[i] = { sidxInfo: e.sidx, sidx: o }, Qi(e, o, e.sidx.resolvedUri), n(!0) }; this.request = bd(r, this.vhs_.xhr, ((t, n, i, a) => { if (t) return s(t, n); if (!i || "mp4" !== i) return s({ status: n.status, message: "Unsupported ".concat(i || "unknown", " container type for sidx segment at URL: ").concat(r), response: "", playlist: e, internal: !0, playlistExclusionDuration: 1 / 0, code: 2 }, n); const { offset: o, length: l } = e.sidx.byterange; if (a.length >= l + o) return s(t, { response: a.subarray(o, o + l), status: n.status, uri: n.uri }); this.request = this.vhs_.xhr({ uri: r, responseType: "arraybuffer", headers: od({ byterange: e.sidx.byterange }) }, s) })) } dispose() { this.trigger("dispose"), this.stopRequest(), this.loadedPlaylists_ = {}, Un().clearTimeout(this.minimumUpdatePeriodTimeout_), Un().clearTimeout(this.mediaRequest_), Un().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.mediaRequest_ = null, this.minimumUpdatePeriodTimeout_ = null, this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_), this.mainPlaylistLoader_.createMupOnMedia_ = null), this.off() } hasPendingRequest() { return this.request || this.mediaRequest_ } stopRequest() { if (this.request) { const e = this.request; this.request = null, e.onreadystatechange = null, e.abort() } } media(e) { if (!e) return this.media_; if ("HAVE_NOTHING" === this.state) throw new Error("Cannot switch media playlist from " + this.state); const t = this.state; if ("string" === typeof e) { if (!this.mainPlaylistLoader_.main.playlists[e]) throw new Error("Unknown playlist URI: " + e); e = this.mainPlaylistLoader_.main.playlists[e] } const n = !this.media_ || e.id !== this.media_.id; if (n && this.loadedPlaylists_[e.id] && this.loadedPlaylists_[e.id].endList) return this.state = "HAVE_METADATA", this.media_ = e, void (n && (this.trigger("mediachanging"), this.trigger("mediachange"))); n && (this.media_ && this.trigger("mediachanging"), this.addSidxSegments_(e, t, (n => { this.haveMetadata({ startingState: t, playlist: e }) }))) } haveMetadata(e) { let { startingState: t, playlist: n } = e; this.state = "HAVE_METADATA", this.loadedPlaylists_[n.id] = n, this.mediaRequest_ = null, this.refreshMedia_(n.id), "HAVE_MAIN_MANIFEST" === t ? this.trigger("loadedmetadata") : this.trigger("mediachange") } pause() { this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_), this.mainPlaylistLoader_.createMupOnMedia_ = null), this.stopRequest(), Un().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.isMain_ && (Un().clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_), this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null), "HAVE_NOTHING" === this.state && (this.started = !1) } load(e) { Un().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null; const t = this.media(); if (e) { const e = t ? t.targetDuration / 2 * 1e3 : 5e3; this.mediaUpdateTimeout = Un().setTimeout((() => this.load()), e) } else this.started ? t && !t.endList ? (this.isMain_ && !this.minimumUpdatePeriodTimeout_ && (this.trigger("minimumUpdatePeriod"), this.updateMinimumUpdatePeriodTimeout_()), this.trigger("mediaupdatetimeout")) : this.trigger("loadedplaylist") : this.start() } start() { this.started = !0, this.isMain_ ? this.requestMain_(((e, t) => { this.haveMain_(), this.hasPendingRequest() || this.media_ || this.media(this.mainPlaylistLoader_.main.playlists[0]) })) : this.mediaRequest_ = Un().setTimeout((() => this.haveMain_()), 0) } requestMain_(e) { this.request = this.vhs_.xhr({ uri: this.mainPlaylistLoader_.srcUrl, withCredentials: this.withCredentials }, ((t, n) => { if (this.requestErrored_(t, n)) return void ("HAVE_NOTHING" === this.state && (this.started = !1)); const i = n.responseText !== this.mainPlaylistLoader_.mainXml_; return this.mainPlaylistLoader_.mainXml_ = n.responseText, n.responseHeaders && n.responseHeaders.date ? this.mainLoaded_ = Date.parse(n.responseHeaders.date) : this.mainLoaded_ = Date.now(), this.mainPlaylistLoader_.srcUrl = pu(this.mainPlaylistLoader_.srcUrl, n), i ? (this.handleMain_(), void this.syncClientServerClock_((() => e(n, i)))) : e(n, i) })) } syncClientServerClock_(e) { const t = jr(this.mainPlaylistLoader_.mainXml_); return null === t ? (this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(), e()) : "DIRECT" === t.method ? (this.mainPlaylistLoader_.clientOffset_ = t.value - Date.now(), e()) : void (this.request = this.vhs_.xhr({ uri: hu(this.mainPlaylistLoader_.srcUrl, t.value), method: t.method, withCredentials: this.withCredentials }, ((n, i) => { if (!this.request) return; if (n) return this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(), e(); let r; r = "HEAD" === t.method ? i.responseHeaders && i.responseHeaders.date ? Date.parse(i.responseHeaders.date) : this.mainLoaded_ : Date.parse(i.responseText), this.mainPlaylistLoader_.clientOffset_ = r - Date.now(), e() }))) } haveMain_() { this.state = "HAVE_MAIN_MANIFEST", this.isMain_ ? this.trigger("loadedplaylist") : this.media_ || this.media(this.childPlaylist_) } handleMain_() { this.mediaRequest_ = null; const e = this.mainPlaylistLoader_.main; let t = (e => { let { mainXml: t, srcUrl: n, clientOffset: i, sidxMapping: r, previousManifest: s } = e; const a = Nr(t, { manifestUri: n, clientOffset: i, sidxMapping: r, previousManifest: s }); return $u(a, n, Sd), a })({ mainXml: this.mainPlaylistLoader_.mainXml_, srcUrl: this.mainPlaylistLoader_.srcUrl, clientOffset: this.mainPlaylistLoader_.clientOffset_, sidxMapping: this.mainPlaylistLoader_.sidxMapping_, previousManifest: e }); e && (t = wd(e, t, this.mainPlaylistLoader_.sidxMapping_)), this.mainPlaylistLoader_.main = t || e; const n = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0]; return n && n !== this.mainPlaylistLoader_.srcUrl && (this.mainPlaylistLoader_.srcUrl = n), (!e || t && t.minimumUpdatePeriod !== e.minimumUpdatePeriod) && this.updateMinimumUpdatePeriodTimeout_(), Boolean(t) } updateMinimumUpdatePeriodTimeout_() { const e = this.mainPlaylistLoader_; e.createMupOnMedia_ && (e.off("loadedmetadata", e.createMupOnMedia_), e.createMupOnMedia_ = null), e.minimumUpdatePeriodTimeout_ && (Un().clearTimeout(e.minimumUpdatePeriodTimeout_), e.minimumUpdatePeriodTimeout_ = null); let t = e.main && e.main.minimumUpdatePeriod; 0 === t && (e.media() ? t = 1e3 * e.media().targetDuration : (e.createMupOnMedia_ = e.updateMinimumUpdatePeriodTimeout_, e.one("loadedmetadata", e.createMupOnMedia_))), "number" !== typeof t || t <= 0 ? t < 0 && this.logger_("found invalid minimumUpdatePeriod of ".concat(t, ", not setting a timeout")) : this.createMUPTimeout_(t) } createMUPTimeout_(e) { const t = this.mainPlaylistLoader_; t.minimumUpdatePeriodTimeout_ = Un().setTimeout((() => { t.minimumUpdatePeriodTimeout_ = null, t.trigger("minimumUpdatePeriod"), t.createMUPTimeout_(e) }), e) } refreshXml_() { this.requestMain_(((e, t) => { t && (this.media_ && (this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id]), this.mainPlaylistLoader_.sidxMapping_ = ((e, t) => { let n = xd(e.playlists, t); return Xu(e, ((e, i, r, s) => { if (e.playlists && e.playlists.length) { const i = e.playlists; n = mu(n, xd(i, t)) } })), n })(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_), this.addSidxSegments_(this.media(), this.state, (e => { this.refreshMedia_(this.media().id) }))) })) } refreshMedia_(e) { if (!e) throw new Error("refreshMedia_ must take a media id"); this.media_ && this.isMain_ && this.handleMain_(); const t = this.mainPlaylistLoader_.main.playlists, n = !this.media_ || this.media_ !== t[e]; if (n ? this.media_ = t[e] : this.trigger("playlistunchanged"), !this.mediaUpdateTimeout) { const e = () => { this.media().endList || (this.mediaUpdateTimeout = Un().setTimeout((() => { this.trigger("mediaupdatetimeout"), e() }), nd(this.media(), Boolean(n)))) }; e() } this.trigger("loadedplaylist") } } var Ed = { GOAL_BUFFER_LENGTH: 30, MAX_GOAL_BUFFER_LENGTH: 60, BACK_BUFFER_LENGTH: 30, GOAL_BUFFER_LENGTH_RATE: 1, INITIAL_BANDWIDTH: 4194304, BANDWIDTH_VARIANCE: 1.2, BUFFER_LOW_WATER_LINE: 0, MAX_BUFFER_LOW_WATER_LINE: 30, EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16, BUFFER_LOW_WATER_LINE_RATE: 1, BUFFER_HIGH_WATER_LINE: 30 }; const Cd = function (e) { return e.on = e.addEventListener, e.off = e.removeEventListener, e }, Pd = function (e) { return function () { const t = function (e) { try { return URL.createObjectURL(new Blob([e], { type: "application/javascript" })) } catch (t) { const n = new BlobBuilder; return n.append(e), URL.createObjectURL(n.getBlob()) } }(e), n = Cd(new Worker(t)); n.objURL = t; const i = n.terminate; return n.on = n.addEventListener, n.off = n.removeEventListener, n.terminate = function () { return URL.revokeObjectURL(t), i.call(this) }, n } }, Id = function (e) { return "var browserWorkerPolyFill = ".concat(Cd.toString(), ";\n") + "browserWorkerPolyFill(self);\n" + e }, Ld = function (e) { return e.toString().replace(/^function.+?{/, "").slice(0, -1) }, Od = Id(Ld((function () { var e = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof window ? window : "undefined" !== typeof n.g ? n.g : "undefined" !== typeof self ? self : {}, t = function () { this.init = function () { var e = {}; this.on = function (t, n) { e[t] || (e[t] = []), e[t] = e[t].concat(n) }, this.off = function (t, n) { var i; return !!e[t] && (i = e[t].indexOf(n), e[t] = e[t].slice(), e[t].splice(i, 1), i > -1) }, this.trigger = function (t) { var n, i, r, s; if (n = e[t]) if (2 === arguments.length) for (r = n.length, i = 0; i < r; ++i)n[i].call(this, arguments[1]); else { for (s = [], i = arguments.length, i = 1; i < arguments.length; ++i)s.push(arguments[i]); for (r = n.length, i = 0; i < r; ++i)n[i].apply(this, s) } }, this.dispose = function () { e = {} } } }; t.prototype.pipe = function (e) { return this.on("data", (function (t) { e.push(t) })), this.on("done", (function (t) { e.flush(t) })), this.on("partialdone", (function (t) { e.partialFlush(t) })), this.on("endedtimeline", (function (t) { e.endTimeline(t) })), this.on("reset", (function (t) { e.reset(t) })), e }, t.prototype.push = function (e) { this.trigger("data", e) }, t.prototype.flush = function (e) { this.trigger("done", e) }, t.prototype.partialFlush = function (e) { this.trigger("partialdone", e) }, t.prototype.endTimeline = function (e) { this.trigger("endedtimeline", e) }, t.prototype.reset = function (e) { this.trigger("reset", e) }; var i, r, s, a, o, l, c, u, d, h, p, f, m, g, y, v, b, _, T, S, w, x, k, E, C, P, I, L, O, A, N, j, D, M, R, U, B = t, F = Math.pow(2, 32), z = { getUint64: function (e) { var t, n = new DataView(e.buffer, e.byteOffset, e.byteLength); return n.getBigUint64 ? (t = n.getBigUint64(0)) < Number.MAX_SAFE_INTEGER ? Number(t) : t : n.getUint32(0) * F + n.getUint32(4) }, MAX_UINT32: F }, H = z.MAX_UINT32; !function () { var e; if (k = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], mvex: [], mvhd: [], pasp: [], sdtp: [], smhd: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], styp: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [] }, "undefined" !== typeof Uint8Array) { for (e in k) k.hasOwnProperty(e) && (k[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]); E = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]), P = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]), C = new Uint8Array([0, 0, 0, 1]), I = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), L = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]), O = { video: I, audio: L }, j = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), N = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), D = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), M = D, R = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), U = D, A = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]) } }(), i = function (e) { var t, n, i = [], r = 0; for (t = 1; t < arguments.length; t++)i.push(arguments[t]); for (t = i.length; t--;)r += i[t].byteLength; for (n = new Uint8Array(r + 8), new DataView(n.buffer, n.byteOffset, n.byteLength).setUint32(0, n.byteLength), n.set(e, 4), t = 0, r = 8; t < i.length; t++)n.set(i[t], r), r += i[t].byteLength; return n }, r = function () { return i(k.dinf, i(k.dref, j)) }, s = function (e) { return i(k.esds, new Uint8Array([0, 0, 0, 0, 3, 25, 0, 0, 0, 4, 17, 64, 21, 0, 6, 0, 0, 0, 218, 192, 0, 0, 218, 192, 5, 2, e.audioobjecttype << 3 | e.samplingfrequencyindex >>> 1, e.samplingfrequencyindex << 7 | e.channelcount << 3, 6, 1, 2])) }, a = function () { return i(k.ftyp, E, C, E, P) }, v = function (e) { return i(k.hdlr, O[e]) }, o = function (e) { return i(k.mdat, e) }, y = function (e) { var t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 1, 95, 144, e.duration >>> 24 & 255, e.duration >>> 16 & 255, e.duration >>> 8 & 255, 255 & e.duration, 85, 196, 0, 0]); return e.samplerate && (t[12] = e.samplerate >>> 24 & 255, t[13] = e.samplerate >>> 16 & 255, t[14] = e.samplerate >>> 8 & 255, t[15] = 255 & e.samplerate), i(k.mdhd, t) }, g = function (e) { return i(k.mdia, y(e), v(e.type), c(e)) }, l = function (e) { return i(k.mfhd, new Uint8Array([0, 0, 0, 0, (4278190080 & e) >> 24, (16711680 & e) >> 16, (65280 & e) >> 8, 255 & e])) }, c = function (e) { return i(k.minf, "video" === e.type ? i(k.vmhd, A) : i(k.smhd, N), r(), _(e)) }, u = function (e, t) { for (var n = [], r = t.length; r--;)n[r] = S(t[r]); return i.apply(null, [k.moof, l(e)].concat(n)) }, d = function (e) { for (var t = e.length, n = []; t--;)n[t] = f(e[t]); return i.apply(null, [k.moov, p(4294967295)].concat(n).concat(h(e))) }, h = function (e) { for (var t = e.length, n = []; t--;)n[t] = w(e[t]); return i.apply(null, [k.mvex].concat(n)) }, p = function (e) { var t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 95, 144, (4278190080 & e) >> 24, (16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]); return i(k.mvhd, t) }, b = function (e) { var t, n, r = e.samples || [], s = new Uint8Array(4 + r.length); for (n = 0; n < r.length; n++)t = r[n].flags, s[n + 4] = t.dependsOn << 4 | t.isDependedOn << 2 | t.hasRedundancy; return i(k.sdtp, s) }, _ = function (e) { return i(k.stbl, T(e), i(k.stts, U), i(k.stsc, M), i(k.stsz, R), i(k.stco, D)) }, function () { var e, t; T = function (n) { return i(k.stsd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), "video" === n.type ? e(n) : t(n)) }, e = function (e) { var t, n, r = e.sps || [], s = e.pps || [], a = [], o = []; for (t = 0; t < r.length; t++)a.push((65280 & r[t].byteLength) >>> 8), a.push(255 & r[t].byteLength), a = a.concat(Array.prototype.slice.call(r[t])); for (t = 0; t < s.length; t++)o.push((65280 & s[t].byteLength) >>> 8), o.push(255 & s[t].byteLength), o = o.concat(Array.prototype.slice.call(s[t])); if (n = [k.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & e.width) >> 8, 255 & e.width, (65280 & e.height) >> 8, 255 & e.height, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 19, 118, 105, 100, 101, 111, 106, 115, 45, 99, 111, 110, 116, 114, 105, 98, 45, 104, 108, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), i(k.avcC, new Uint8Array([1, e.profileIdc, e.profileCompatibility, e.levelIdc, 255].concat([r.length], a, [s.length], o))), i(k.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192]))], e.sarRatio) { var l = e.sarRatio[0], c = e.sarRatio[1]; n.push(i(k.pasp, new Uint8Array([(4278190080 & l) >> 24, (16711680 & l) >> 16, (65280 & l) >> 8, 255 & l, (4278190080 & c) >> 24, (16711680 & c) >> 16, (65280 & c) >> 8, 255 & c]))) } return i.apply(null, n) }, t = function (e) { return i(k.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & e.channelcount) >> 8, 255 & e.channelcount, (65280 & e.samplesize) >> 8, 255 & e.samplesize, 0, 0, 0, 0, (65280 & e.samplerate) >> 8, 255 & e.samplerate, 0, 0]), s(e)) } }(), m = function (e) { var t = new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 0, (4278190080 & e.duration) >> 24, (16711680 & e.duration) >> 16, (65280 & e.duration) >> 8, 255 & e.duration, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, (65280 & e.width) >> 8, 255 & e.width, 0, 0, (65280 & e.height) >> 8, 255 & e.height, 0, 0]); return i(k.tkhd, t) }, S = function (e) { var t, n, r, s, a, o; return t = i(k.tfhd, new Uint8Array([0, 0, 0, 58, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])), a = Math.floor(e.baseMediaDecodeTime / H), o = Math.floor(e.baseMediaDecodeTime % H), n = i(k.tfdt, new Uint8Array([1, 0, 0, 0, a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a, o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o])), 92, "audio" === e.type ? (r = x(e, 92), i(k.traf, t, n, r)) : (s = b(e), r = x(e, s.length + 92), i(k.traf, t, n, r, s)) }, f = function (e) { return e.duration = e.duration || 4294967295, i(k.trak, m(e), g(e)) }, w = function (e) { var t = new Uint8Array([0, 0, 0, 0, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]); return "video" !== e.type && (t[t.length - 1] = 0), i(k.trex, t) }, function () { var e, t, n; n = function (e, t) { var n = 0, i = 0, r = 0, s = 0; return e.length && (void 0 !== e[0].duration && (n = 1), void 0 !== e[0].size && (i = 2), void 0 !== e[0].flags && (r = 4), void 0 !== e[0].compositionTimeOffset && (s = 8)), [0, 0, n | i | r | s, 1, (4278190080 & e.length) >>> 24, (16711680 & e.length) >>> 16, (65280 & e.length) >>> 8, 255 & e.length, (4278190080 & t) >>> 24, (16711680 & t) >>> 16, (65280 & t) >>> 8, 255 & t] }, t = function (e, t) { var r, s, a, o, l, c; for (t += 20 + 16 * (o = e.samples || []).length, a = n(o, t), (s = new Uint8Array(a.length + 16 * o.length)).set(a), r = a.length, c = 0; c < o.length; c++)l = o[c], s[r++] = (4278190080 & l.duration) >>> 24, s[r++] = (16711680 & l.duration) >>> 16, s[r++] = (65280 & l.duration) >>> 8, s[r++] = 255 & l.duration, s[r++] = (4278190080 & l.size) >>> 24, s[r++] = (16711680 & l.size) >>> 16, s[r++] = (65280 & l.size) >>> 8, s[r++] = 255 & l.size, s[r++] = l.flags.isLeading << 2 | l.flags.dependsOn, s[r++] = l.flags.isDependedOn << 6 | l.flags.hasRedundancy << 4 | l.flags.paddingValue << 1 | l.flags.isNonSyncSample, s[r++] = 61440 & l.flags.degradationPriority, s[r++] = 15 & l.flags.degradationPriority, s[r++] = (4278190080 & l.compositionTimeOffset) >>> 24, s[r++] = (16711680 & l.compositionTimeOffset) >>> 16, s[r++] = (65280 & l.compositionTimeOffset) >>> 8, s[r++] = 255 & l.compositionTimeOffset; return i(k.trun, s) }, e = function (e, t) { var r, s, a, o, l, c; for (t += 20 + 8 * (o = e.samples || []).length, a = n(o, t), (r = new Uint8Array(a.length + 8 * o.length)).set(a), s = a.length, c = 0; c < o.length; c++)l = o[c], r[s++] = (4278190080 & l.duration) >>> 24, r[s++] = (16711680 & l.duration) >>> 16, r[s++] = (65280 & l.duration) >>> 8, r[s++] = 255 & l.duration, r[s++] = (4278190080 & l.size) >>> 24, r[s++] = (16711680 & l.size) >>> 16, r[s++] = (65280 & l.size) >>> 8, r[s++] = 255 & l.size; return i(k.trun, r) }, x = function (n, i) { return "audio" === n.type ? e(n, i) : t(n, i) } }(); var V, W, q, G, X, K, $, Y, Q = { ftyp: a, mdat: o, moof: u, moov: d, initSegment: function (e) { var t, n = a(), i = d(e); return (t = new Uint8Array(n.byteLength + i.byteLength)).set(n), t.set(i, n.byteLength), t } }, J = function (e, t) { var n = { size: 0, flags: { isLeading: 0, dependsOn: 1, isDependedOn: 0, hasRedundancy: 0, degradationPriority: 0, isNonSyncSample: 1 } }; return n.dataOffset = t, n.compositionTimeOffset = e.pts - e.dts, n.duration = e.duration, n.size = 4 * e.length, n.size += e.byteLength, e.keyFrame && (n.flags.dependsOn = 2, n.flags.isNonSyncSample = 0), n }, Z = { groupNalsIntoFrames: function (e) { var t, n, i = [], r = []; for (r.byteLength = 0, r.nalCount = 0, r.duration = 0, i.byteLength = 0, t = 0; t < e.length; t++)"access_unit_delimiter_rbsp" === (n = e[t]).nalUnitType ? (i.length && (i.duration = n.dts - i.dts, r.byteLength += i.byteLength, r.nalCount += i.length, r.duration += i.duration, r.push(i)), (i = [n]).byteLength = n.data.byteLength, i.pts = n.pts, i.dts = n.dts) : ("slice_layer_without_partitioning_rbsp_idr" === n.nalUnitType && (i.keyFrame = !0), i.duration = n.dts - i.dts, i.byteLength += n.data.byteLength, i.push(n)); return r.length && (!i.duration || i.duration <= 0) && (i.duration = r[r.length - 1].duration), r.byteLength += i.byteLength, r.nalCount += i.length, r.duration += i.duration, r.push(i), r }, groupFramesIntoGops: function (e) { var t, n, i = [], r = []; for (i.byteLength = 0, i.nalCount = 0, i.duration = 0, i.pts = e[0].pts, i.dts = e[0].dts, r.byteLength = 0, r.nalCount = 0, r.duration = 0, r.pts = e[0].pts, r.dts = e[0].dts, t = 0; t < e.length; t++)(n = e[t]).keyFrame ? (i.length && (r.push(i), r.byteLength += i.byteLength, r.nalCount += i.nalCount, r.duration += i.duration), (i = [n]).nalCount = n.length, i.byteLength = n.byteLength, i.pts = n.pts, i.dts = n.dts, i.duration = n.duration) : (i.duration += n.duration, i.nalCount += n.length, i.byteLength += n.byteLength, i.push(n)); return r.length && i.duration <= 0 && (i.duration = r[r.length - 1].duration), r.byteLength += i.byteLength, r.nalCount += i.nalCount, r.duration += i.duration, r.push(i), r }, extendFirstKeyFrame: function (e) { var t; return !e[0][0].keyFrame && e.length > 1 && (t = e.shift(), e.byteLength -= t.byteLength, e.nalCount -= t.nalCount, e[0][0].dts = t.dts, e[0][0].pts = t.pts, e[0][0].duration += t.duration), e }, generateSampleTable: function (e, t) { var n, i, r, s, a, o = t || 0, l = []; for (n = 0; n < e.length; n++)for (s = e[n], i = 0; i < s.length; i++)a = s[i], o += (r = J(a, o)).size, l.push(r); return l }, concatenateNalData: function (e) { var t, n, i, r, s, a, o = 0, l = e.byteLength, c = e.nalCount, u = new Uint8Array(l + 4 * c), d = new DataView(u.buffer); for (t = 0; t < e.length; t++)for (r = e[t], n = 0; n < r.length; n++)for (s = r[n], i = 0; i < s.length; i++)a = s[i], d.setUint32(o, a.data.byteLength), o += 4, u.set(a.data, o), o += a.data.byteLength; return u }, generateSampleTableForFrame: function (e, t) { var n, i = []; return n = J(e, t || 0), i.push(n), i }, concatenateNalDataForFrame: function (e) { var t, n, i = 0, r = e.byteLength, s = e.length, a = new Uint8Array(r + 4 * s), o = new DataView(a.buffer); for (t = 0; t < e.length; t++)n = e[t], o.setUint32(i, n.data.byteLength), i += 4, a.set(n.data, i), i += n.data.byteLength; return a } }, ee = [33, 16, 5, 32, 164, 27], te = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252], ne = function (e) { for (var t = []; e--;)t.push(0); return t }, ie = 9e4; K = function (e, t) { return W(X(e, t)) }, $ = function (e, t) { return q(G(e), t) }, Y = function (e, t, n) { return G(n ? e : e - t) }; var re = { ONE_SECOND_IN_TS: ie, secondsToVideoTs: W = function (e) { return e * ie }, secondsToAudioTs: q = function (e, t) { return e * t }, videoTsToSeconds: G = function (e) { return e / ie }, audioTsToSeconds: X = function (e, t) { return e / t }, audioTsToVideoTs: K, videoTsToAudioTs: $, metadataTsToSeconds: Y }, se = function () { if (!V) { var e = { 96e3: [ee, [227, 64], ne(154), [56]], 88200: [ee, [231], ne(170), [56]], 64e3: [ee, [248, 192], ne(240), [56]], 48e3: [ee, [255, 192], ne(268), [55, 148, 128], ne(54), [112]], 44100: [ee, [255, 192], ne(268), [55, 163, 128], ne(84), [112]], 32e3: [ee, [255, 192], ne(268), [55, 234], ne(226), [112]], 24e3: [ee, [255, 192], ne(268), [55, 255, 128], ne(268), [111, 112], ne(126), [224]], 16e3: [ee, [255, 192], ne(268), [55, 255, 128], ne(268), [111, 255], ne(269), [223, 108], ne(195), [1, 192]], 12e3: [te, ne(268), [3, 127, 248], ne(268), [6, 255, 240], ne(268), [13, 255, 224], ne(268), [27, 253, 128], ne(259), [56]], 11025: [te, ne(268), [3, 127, 248], ne(268), [6, 255, 240], ne(268), [13, 255, 224], ne(268), [27, 255, 192], ne(268), [55, 175, 128], ne(108), [112]], 8e3: [te, ne(268), [3, 121, 16], ne(47), [7]] }; t = e, V = Object.keys(t).reduce((function (e, n) { return e[n] = new Uint8Array(t[n].reduce((function (e, t) { return e.concat(t) }), [])), e }), {}) } var t; return V }, ae = re, oe = { prefixWithSilence: function (e, t, n, i) { var r, s, a, o, l, c = 0, u = 0, d = 0; if (t.length && (r = ae.audioTsToVideoTs(e.baseMediaDecodeTime, e.samplerate), s = Math.ceil(ae.ONE_SECOND_IN_TS / (e.samplerate / 1024)), n && i && (c = r - Math.max(n, i), d = (u = Math.floor(c / s)) * s), !(u < 1 || d > ae.ONE_SECOND_IN_TS / 2))) { for ((a = se()[e.samplerate]) || (a = t[0].data), o = 0; o < u; o++)l = t[0], t.splice(0, 0, { data: a, dts: l.dts - s, pts: l.pts - s }); return e.baseMediaDecodeTime -= Math.floor(ae.videoTsToAudioTs(d, e.samplerate)), d } }, trimAdtsFramesByEarliestDts: function (e, t, n) { return t.minSegmentDts >= n ? e : (t.minSegmentDts = 1 / 0, e.filter((function (e) { return e.dts >= n && (t.minSegmentDts = Math.min(t.minSegmentDts, e.dts), t.minSegmentPts = t.minSegmentDts, !0) }))) }, generateSampleTable: function (e) { var t, n, i = []; for (t = 0; t < e.length; t++)n = e[t], i.push({ size: n.data.byteLength, duration: 1024 }); return i }, concatenateFrameData: function (e) { var t, n, i = 0, r = new Uint8Array(function (e) { var t, n = 0; for (t = 0; t < e.length; t++)n += e[t].data.byteLength; return n }(e)); for (t = 0; t < e.length; t++)n = e[t], r.set(n.data, i), i += n.data.byteLength; return r } }, le = re.ONE_SECOND_IN_TS, ce = { clearDtsInfo: function (e) { delete e.minSegmentDts, delete e.maxSegmentDts, delete e.minSegmentPts, delete e.maxSegmentPts }, calculateTrackBaseMediaDecodeTime: function (e, t) { var n, i = e.minSegmentDts; return t || (i -= e.timelineStartInfo.dts), n = e.timelineStartInfo.baseMediaDecodeTime, n += i, n = Math.max(0, n), "audio" === e.type && (n *= e.samplerate / le, n = Math.floor(n)), n }, collectDtsInfo: function (e, t) { "number" === typeof t.pts && (void 0 === e.timelineStartInfo.pts && (e.timelineStartInfo.pts = t.pts), void 0 === e.minSegmentPts ? e.minSegmentPts = t.pts : e.minSegmentPts = Math.min(e.minSegmentPts, t.pts), void 0 === e.maxSegmentPts ? e.maxSegmentPts = t.pts : e.maxSegmentPts = Math.max(e.maxSegmentPts, t.pts)), "number" === typeof t.dts && (void 0 === e.timelineStartInfo.dts && (e.timelineStartInfo.dts = t.dts), void 0 === e.minSegmentDts ? e.minSegmentDts = t.dts : e.minSegmentDts = Math.min(e.minSegmentDts, t.dts), void 0 === e.maxSegmentDts ? e.maxSegmentDts = t.dts : e.maxSegmentDts = Math.max(e.maxSegmentDts, t.dts)) } }, ue = { parseSei: function (e) { for (var t = 0, n = { payloadType: -1, payloadSize: 0 }, i = 0, r = 0; t < e.byteLength && 128 !== e[t];) { for (; 255 === e[t];)i += 255, t++; for (i += e[t++]; 255 === e[t];)r += 255, t++; if (r += e[t++], !n.payload && 4 === i) { if ("GA94" === String.fromCharCode(e[t + 3], e[t + 4], e[t + 5], e[t + 6])) { n.payloadType = i, n.payloadSize = r, n.payload = e.subarray(t, t + r); break } n.payload = void 0 } t += r, i = 0, r = 0 } return n }, parseUserData: function (e) { return 181 !== e.payload[0] || 49 !== (e.payload[1] << 8 | e.payload[2]) || "GA94" !== String.fromCharCode(e.payload[3], e.payload[4], e.payload[5], e.payload[6]) || 3 !== e.payload[7] ? null : e.payload.subarray(8, e.payload.length - 1) }, parseCaptionPackets: function (e, t) { var n, i, r, s, a = []; if (!(64 & t[0])) return a; for (i = 31 & t[0], n = 0; n < i; n++)s = { type: 3 & t[(r = 3 * n) + 2], pts: e }, 4 & t[r + 2] && (s.ccData = t[r + 3] << 8 | t[r + 4], a.push(s)); return a }, discardEmulationPreventionBytes: function (e) { for (var t, n, i = e.byteLength, r = [], s = 1; s < i - 2;)0 === e[s] && 0 === e[s + 1] && 3 === e[s + 2] ? (r.push(s + 2), s += 2) : s++; if (0 === r.length) return e; t = i - r.length, n = new Uint8Array(t); var a = 0; for (s = 0; s < t; a++, s++)a === r[0] && (a++, r.shift()), n[s] = e[a]; return n }, USER_DATA_REGISTERED_ITU_T_T35: 4 }, de = B, he = ue, pe = function (e) { e = e || {}, pe.prototype.init.call(this), this.parse708captions_ = "boolean" !== typeof e.parse708captions || e.parse708captions, this.captionPackets_ = [], this.ccStreams_ = [new we(0, 0), new we(0, 1), new we(1, 0), new we(1, 1)], this.parse708captions_ && (this.cc708Stream_ = new ve({ captionServices: e.captionServices })), this.reset(), this.ccStreams_.forEach((function (e) { e.on("data", this.trigger.bind(this, "data")), e.on("partialdone", this.trigger.bind(this, "partialdone")), e.on("done", this.trigger.bind(this, "done")) }), this), this.parse708captions_ && (this.cc708Stream_.on("data", this.trigger.bind(this, "data")), this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone")), this.cc708Stream_.on("done", this.trigger.bind(this, "done"))) }; pe.prototype = new de, pe.prototype.push = function (e) { var t, n, i; if ("sei_rbsp" === e.nalUnitType && (t = he.parseSei(e.escapedRBSP)).payload && t.payloadType === he.USER_DATA_REGISTERED_ITU_T_T35 && (n = he.parseUserData(t))) if (e.dts < this.latestDts_) this.ignoreNextEqualDts_ = !0; else { if (e.dts === this.latestDts_ && this.ignoreNextEqualDts_) return this.numSameDts_--, void (this.numSameDts_ || (this.ignoreNextEqualDts_ = !1)); i = he.parseCaptionPackets(e.pts, n), this.captionPackets_ = this.captionPackets_.concat(i), this.latestDts_ !== e.dts && (this.numSameDts_ = 0), this.numSameDts_++, this.latestDts_ = e.dts } }, pe.prototype.flushCCStreams = function (e) { this.ccStreams_.forEach((function (t) { return "flush" === e ? t.flush() : t.partialFlush() }), this) }, pe.prototype.flushStream = function (e) { this.captionPackets_.length ? (this.captionPackets_.forEach((function (e, t) { e.presortIndex = t })), this.captionPackets_.sort((function (e, t) { return e.pts === t.pts ? e.presortIndex - t.presortIndex : e.pts - t.pts })), this.captionPackets_.forEach((function (e) { e.type < 2 ? this.dispatchCea608Packet(e) : this.dispatchCea708Packet(e) }), this), this.captionPackets_.length = 0, this.flushCCStreams(e)) : this.flushCCStreams(e) }, pe.prototype.flush = function () { return this.flushStream("flush") }, pe.prototype.partialFlush = function () { return this.flushStream("partialFlush") }, pe.prototype.reset = function () { this.latestDts_ = null, this.ignoreNextEqualDts_ = !1, this.numSameDts_ = 0, this.activeCea608Channel_ = [null, null], this.ccStreams_.forEach((function (e) { e.reset() })) }, pe.prototype.dispatchCea608Packet = function (e) { this.setsTextOrXDSActive(e) ? this.activeCea608Channel_[e.type] = null : this.setsChannel1Active(e) ? this.activeCea608Channel_[e.type] = 0 : this.setsChannel2Active(e) && (this.activeCea608Channel_[e.type] = 1), null !== this.activeCea608Channel_[e.type] && this.ccStreams_[(e.type << 1) + this.activeCea608Channel_[e.type]].push(e) }, pe.prototype.setsChannel1Active = function (e) { return 4096 === (30720 & e.ccData) }, pe.prototype.setsChannel2Active = function (e) { return 6144 === (30720 & e.ccData) }, pe.prototype.setsTextOrXDSActive = function (e) { return 256 === (28928 & e.ccData) || 4138 === (30974 & e.ccData) || 6186 === (30974 & e.ccData) }, pe.prototype.dispatchCea708Packet = function (e) { this.parse708captions_ && this.cc708Stream_.push(e) }; var fe = { 127: 9834, 4128: 32, 4129: 160, 4133: 8230, 4138: 352, 4140: 338, 4144: 9608, 4145: 8216, 4146: 8217, 4147: 8220, 4148: 8221, 4149: 8226, 4153: 8482, 4154: 353, 4156: 339, 4157: 8480, 4159: 376, 4214: 8539, 4215: 8540, 4216: 8541, 4217: 8542, 4218: 9168, 4219: 9124, 4220: 9123, 4221: 9135, 4222: 9126, 4223: 9121, 4256: 12600 }, me = function (e) { return 32 <= e && e <= 127 || 160 <= e && e <= 255 }, ge = function (e) { this.windowNum = e, this.reset() }; ge.prototype.reset = function () { this.clearText(), this.pendingNewLine = !1, this.winAttr = {}, this.penAttr = {}, this.penLoc = {}, this.penColor = {}, this.visible = 0, this.rowLock = 0, this.columnLock = 0, this.priority = 0, this.relativePositioning = 0, this.anchorVertical = 0, this.anchorHorizontal = 0, this.anchorPoint = 0, this.rowCount = 1, this.virtualRowCount = this.rowCount + 1, this.columnCount = 41, this.windowStyle = 0, this.penStyle = 0 }, ge.prototype.getText = function () { return this.rows.join("\n") }, ge.prototype.clearText = function () { this.rows = [""], this.rowIdx = 0 }, ge.prototype.newLine = function (e) { for (this.rows.length >= this.virtualRowCount && "function" === typeof this.beforeRowOverflow && this.beforeRowOverflow(e), this.rows.length > 0 && (this.rows.push(""), this.rowIdx++); this.rows.length > this.virtualRowCount;)this.rows.shift(), this.rowIdx-- }, ge.prototype.isEmpty = function () { return 0 === this.rows.length || 1 === this.rows.length && "" === this.rows[0] }, ge.prototype.addText = function (e) { this.rows[this.rowIdx] += e }, ge.prototype.backspace = function () { if (!this.isEmpty()) { var e = this.rows[this.rowIdx]; this.rows[this.rowIdx] = e.substr(0, e.length - 1) } }; var ye = function (e, t, n) { this.serviceNum = e, this.text = "", this.currentWindow = new ge(-1), this.windows = [], this.stream = n, "string" === typeof t && this.createTextDecoder(t) }; ye.prototype.init = function (e, t) { this.startPts = e; for (var n = 0; n < 8; n++)this.windows[n] = new ge(n), "function" === typeof t && (this.windows[n].beforeRowOverflow = t) }, ye.prototype.setCurrentWindow = function (e) { this.currentWindow = this.windows[e] }, ye.prototype.createTextDecoder = function (e) { if ("undefined" === typeof TextDecoder) this.stream.trigger("log", { level: "warn", message: "The `encoding` option is unsupported without TextDecoder support" }); else try { this.textDecoder_ = new TextDecoder(e) } catch (t) { this.stream.trigger("log", { level: "warn", message: "TextDecoder could not be created with " + e + " encoding. " + t }) } }; var ve = function (e) { e = e || {}, ve.prototype.init.call(this); var t, n = this, i = e.captionServices || {}, r = {}; Object.keys(i).forEach((e => { t = i[e], /^SERVICE/.test(e) && (r[e] = t.encoding) })), this.serviceEncodings = r, this.current708Packet = null, this.services = {}, this.push = function (e) { 3 === e.type ? (n.new708Packet(), n.add708Bytes(e)) : (null === n.current708Packet && n.new708Packet(), n.add708Bytes(e)) } }; ve.prototype = new de, ve.prototype.new708Packet = function () { null !== this.current708Packet && this.push708Packet(), this.current708Packet = { data: [], ptsVals: [] } }, ve.prototype.add708Bytes = function (e) { var t = e.ccData, n = t >>> 8, i = 255 & t; this.current708Packet.ptsVals.push(e.pts), this.current708Packet.data.push(n), this.current708Packet.data.push(i) }, ve.prototype.push708Packet = function () { var e = this.current708Packet, t = e.data, n = null, i = null, r = 0, s = t[r++]; for (e.seq = s >> 6, e.sizeCode = 63 & s; r < t.length; r++)i = 31 & (s = t[r++]), 7 === (n = s >> 5) && i > 0 && (n = s = t[r++]), this.pushServiceBlock(n, r, i), i > 0 && (r += i - 1) }, ve.prototype.pushServiceBlock = function (e, t, n) { var i, r = t, s = this.current708Packet.data, a = this.services[e]; for (a || (a = this.initService(e, r)); r < t + n && r < s.length; r++)i = s[r], me(i) ? r = this.handleText(r, a) : 24 === i ? r = this.multiByteCharacter(r, a) : 16 === i ? r = this.extendedCommands(r, a) : 128 <= i && i <= 135 ? r = this.setCurrentWindow(r, a) : 152 <= i && i <= 159 ? r = this.defineWindow(r, a) : 136 === i ? r = this.clearWindows(r, a) : 140 === i ? r = this.deleteWindows(r, a) : 137 === i ? r = this.displayWindows(r, a) : 138 === i ? r = this.hideWindows(r, a) : 139 === i ? r = this.toggleWindows(r, a) : 151 === i ? r = this.setWindowAttributes(r, a) : 144 === i ? r = this.setPenAttributes(r, a) : 145 === i ? r = this.setPenColor(r, a) : 146 === i ? r = this.setPenLocation(r, a) : 143 === i ? a = this.reset(r, a) : 8 === i ? a.currentWindow.backspace() : 12 === i ? a.currentWindow.clearText() : 13 === i ? a.currentWindow.pendingNewLine = !0 : 14 === i ? a.currentWindow.clearText() : 141 === i && r++ }, ve.prototype.extendedCommands = function (e, t) { var n = this.current708Packet.data[++e]; return me(n) && (e = this.handleText(e, t, { isExtended: !0 })), e }, ve.prototype.getPts = function (e) { return this.current708Packet.ptsVals[Math.floor(e / 2)] }, ve.prototype.initService = function (e, t) { var n, i, r = this; return (n = "SERVICE" + e) in this.serviceEncodings && (i = this.serviceEncodings[n]), this.services[e] = new ye(e, i, r), this.services[e].init(this.getPts(t), (function (t) { r.flushDisplayed(t, r.services[e]) })), this.services[e] }, ve.prototype.handleText = function (e, t, n) { var i, r, s = n && n.isExtended, a = n && n.isMultiByte, o = this.current708Packet.data, l = s ? 4096 : 0, c = o[e], u = o[e + 1], d = t.currentWindow; return t.textDecoder_ && !s ? (a ? (r = [c, u], e++) : r = [c], i = t.textDecoder_.decode(new Uint8Array(r))) : i = function (e) { var t = fe[e] || e; return 4096 & e && e === t ? "" : String.fromCharCode(t) }(l | c), d.pendingNewLine && !d.isEmpty() && d.newLine(this.getPts(e)), d.pendingNewLine = !1, d.addText(i), e }, ve.prototype.multiByteCharacter = function (e, t) { var n = this.current708Packet.data, i = n[e + 1], r = n[e + 2]; return me(i) && me(r) && (e = this.handleText(++e, t, { isMultiByte: !0 })), e }, ve.prototype.setCurrentWindow = function (e, t) { var n = 7 & this.current708Packet.data[e]; return t.setCurrentWindow(n), e }, ve.prototype.defineWindow = function (e, t) { var n = this.current708Packet.data, i = n[e], r = 7 & i; t.setCurrentWindow(r); var s = t.currentWindow; return i = n[++e], s.visible = (32 & i) >> 5, s.rowLock = (16 & i) >> 4, s.columnLock = (8 & i) >> 3, s.priority = 7 & i, i = n[++e], s.relativePositioning = (128 & i) >> 7, s.anchorVertical = 127 & i, i = n[++e], s.anchorHorizontal = i, i = n[++e], s.anchorPoint = (240 & i) >> 4, s.rowCount = 15 & i, i = n[++e], s.columnCount = 63 & i, i = n[++e], s.windowStyle = (56 & i) >> 3, s.penStyle = 7 & i, s.virtualRowCount = s.rowCount + 1, e }, ve.prototype.setWindowAttributes = function (e, t) { var n = this.current708Packet.data, i = n[e], r = t.currentWindow.winAttr; return i = n[++e], r.fillOpacity = (192 & i) >> 6, r.fillRed = (48 & i) >> 4, r.fillGreen = (12 & i) >> 2, r.fillBlue = 3 & i, i = n[++e], r.borderType = (192 & i) >> 6, r.borderRed = (48 & i) >> 4, r.borderGreen = (12 & i) >> 2, r.borderBlue = 3 & i, i = n[++e], r.borderType += (128 & i) >> 5, r.wordWrap = (64 & i) >> 6, r.printDirection = (48 & i) >> 4, r.scrollDirection = (12 & i) >> 2, r.justify = 3 & i, i = n[++e], r.effectSpeed = (240 & i) >> 4, r.effectDirection = (12 & i) >> 2, r.displayEffect = 3 & i, e }, ve.prototype.flushDisplayed = function (e, t) { for (var n = [], i = 0; i < 8; i++)t.windows[i].visible && !t.windows[i].isEmpty() && n.push(t.windows[i].getText()); t.endPts = e, t.text = n.join("\n\n"), this.pushCaption(t), t.startPts = e }, ve.prototype.pushCaption = function (e) { "" !== e.text && (this.trigger("data", { startPts: e.startPts, endPts: e.endPts, text: e.text, stream: "cc708_" + e.serviceNum }), e.text = "", e.startPts = e.endPts) }, ve.prototype.displayWindows = function (e, t) { var n = this.current708Packet.data[++e], i = this.getPts(e); this.flushDisplayed(i, t); for (var r = 0; r < 8; r++)n & 1 << r && (t.windows[r].visible = 1); return e }, ve.prototype.hideWindows = function (e, t) { var n = this.current708Packet.data[++e], i = this.getPts(e); this.flushDisplayed(i, t); for (var r = 0; r < 8; r++)n & 1 << r && (t.windows[r].visible = 0); return e }, ve.prototype.toggleWindows = function (e, t) { var n = this.current708Packet.data[++e], i = this.getPts(e); this.flushDisplayed(i, t); for (var r = 0; r < 8; r++)n & 1 << r && (t.windows[r].visible ^= 1); return e }, ve.prototype.clearWindows = function (e, t) { var n = this.current708Packet.data[++e], i = this.getPts(e); this.flushDisplayed(i, t); for (var r = 0; r < 8; r++)n & 1 << r && t.windows[r].clearText(); return e }, ve.prototype.deleteWindows = function (e, t) { var n = this.current708Packet.data[++e], i = this.getPts(e); this.flushDisplayed(i, t); for (var r = 0; r < 8; r++)n & 1 << r && t.windows[r].reset(); return e }, ve.prototype.setPenAttributes = function (e, t) { var n = this.current708Packet.data, i = n[e], r = t.currentWindow.penAttr; return i = n[++e], r.textTag = (240 & i) >> 4, r.offset = (12 & i) >> 2, r.penSize = 3 & i, i = n[++e], r.italics = (128 & i) >> 7, r.underline = (64 & i) >> 6, r.edgeType = (56 & i) >> 3, r.fontStyle = 7 & i, e }, ve.prototype.setPenColor = function (e, t) { var n = this.current708Packet.data, i = n[e], r = t.currentWindow.penColor; return i = n[++e], r.fgOpacity = (192 & i) >> 6, r.fgRed = (48 & i) >> 4, r.fgGreen = (12 & i) >> 2, r.fgBlue = 3 & i, i = n[++e], r.bgOpacity = (192 & i) >> 6, r.bgRed = (48 & i) >> 4, r.bgGreen = (12 & i) >> 2, r.bgBlue = 3 & i, i = n[++e], r.edgeRed = (48 & i) >> 4, r.edgeGreen = (12 & i) >> 2, r.edgeBlue = 3 & i, e }, ve.prototype.setPenLocation = function (e, t) { var n = this.current708Packet.data, i = n[e], r = t.currentWindow.penLoc; return t.currentWindow.pendingNewLine = !0, i = n[++e], r.row = 15 & i, i = n[++e], r.column = 63 & i, e }, ve.prototype.reset = function (e, t) { var n = this.getPts(e); return this.flushDisplayed(n, t), this.initService(t.serviceNum, e) }; var be = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 304: 174, 305: 176, 306: 189, 307: 191, 308: 8482, 309: 162, 310: 163, 311: 9834, 312: 224, 313: 160, 314: 232, 315: 226, 316: 234, 317: 238, 318: 244, 319: 251, 544: 193, 545: 201, 546: 211, 547: 218, 548: 220, 549: 252, 550: 8216, 551: 161, 552: 42, 553: 39, 554: 8212, 555: 169, 556: 8480, 557: 8226, 558: 8220, 559: 8221, 560: 192, 561: 194, 562: 199, 563: 200, 564: 202, 565: 203, 566: 235, 567: 206, 568: 207, 569: 239, 570: 212, 571: 217, 572: 249, 573: 219, 574: 171, 575: 187, 800: 195, 801: 227, 802: 205, 803: 204, 804: 236, 805: 210, 806: 242, 807: 213, 808: 245, 809: 123, 810: 125, 811: 92, 812: 94, 813: 95, 814: 124, 815: 126, 816: 196, 817: 228, 818: 214, 819: 246, 820: 223, 821: 165, 822: 164, 823: 9474, 824: 197, 825: 229, 826: 216, 827: 248, 828: 9484, 829: 9488, 830: 9492, 831: 9496 }, _e = function (e) { return null === e ? "" : (e = be[e] || e, String.fromCharCode(e)) }, Te = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152], Se = function () { for (var e = [], t = 15; t--;)e.push(""); return e }, we = function (e, t) { we.prototype.init.call(this), this.field_ = e || 0, this.dataChannel_ = t || 0, this.name_ = "CC" + (1 + (this.field_ << 1 | this.dataChannel_)), this.setConstants(), this.reset(), this.push = function (e) { var t, n, i, r, s; if ((t = 32639 & e.ccData) !== this.lastControlCode_) { if (4096 === (61440 & t) ? this.lastControlCode_ = t : t !== this.PADDING_ && (this.lastControlCode_ = null), i = t >>> 8, r = 255 & t, t !== this.PADDING_) if (t === this.RESUME_CAPTION_LOADING_) this.mode_ = "popOn"; else if (t === this.END_OF_CAPTION_) this.mode_ = "popOn", this.clearFormatting(e.pts), this.flushDisplayed(e.pts), n = this.displayed_, this.displayed_ = this.nonDisplayed_, this.nonDisplayed_ = n, this.startPts_ = e.pts; else if (t === this.ROLL_UP_2_ROWS_) this.rollUpRows_ = 2, this.setRollUp(e.pts); else if (t === this.ROLL_UP_3_ROWS_) this.rollUpRows_ = 3, this.setRollUp(e.pts); else if (t === this.ROLL_UP_4_ROWS_) this.rollUpRows_ = 4, this.setRollUp(e.pts); else if (t === this.CARRIAGE_RETURN_) this.clearFormatting(e.pts), this.flushDisplayed(e.pts), this.shiftRowsUp_(), this.startPts_ = e.pts; else if (t === this.BACKSPACE_) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1); else if (t === this.ERASE_DISPLAYED_MEMORY_) this.flushDisplayed(e.pts), this.displayed_ = Se(); else if (t === this.ERASE_NON_DISPLAYED_MEMORY_) this.nonDisplayed_ = Se(); else if (t === this.RESUME_DIRECT_CAPTIONING_) "paintOn" !== this.mode_ && (this.flushDisplayed(e.pts), this.displayed_ = Se()), this.mode_ = "paintOn", this.startPts_ = e.pts; else if (this.isSpecialCharacter(i, r)) s = _e((i = (3 & i) << 8) | r), this[this.mode_](e.pts, s), this.column_++; else if (this.isExtCharacter(i, r)) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1), s = _e((i = (3 & i) << 8) | r), this[this.mode_](e.pts, s), this.column_++; else if (this.isMidRowCode(i, r)) this.clearFormatting(e.pts), this[this.mode_](e.pts, " "), this.column_++, 14 === (14 & r) && this.addFormatting(e.pts, ["i"]), 1 === (1 & r) && this.addFormatting(e.pts, ["u"]); else if (this.isOffsetControlCode(i, r)) this.column_ += 3 & r; else if (this.isPAC(i, r)) { var a = Te.indexOf(7968 & t); "rollUp" === this.mode_ && (a - this.rollUpRows_ + 1 < 0 && (a = this.rollUpRows_ - 1), this.setRollUp(e.pts, a)), a !== this.row_ && (this.clearFormatting(e.pts), this.row_ = a), 1 & r && -1 === this.formatting_.indexOf("u") && this.addFormatting(e.pts, ["u"]), 16 === (16 & t) && (this.column_ = 4 * ((14 & t) >> 1)), this.isColorPAC(r) && 14 === (14 & r) && this.addFormatting(e.pts, ["i"]) } else this.isNormalChar(i) && (0 === r && (r = null), s = _e(i), s += _e(r), this[this.mode_](e.pts, s), this.column_ += s.length) } else this.lastControlCode_ = null } }; we.prototype = new de, we.prototype.flushDisplayed = function (e) { var t = this.displayed_.map((function (e, t) { try { return e.trim() } catch (n) { return this.trigger("log", { level: "warn", message: "Skipping a malformed 608 caption at index " + t + "." }), "" } }), this).join("\n").replace(/^\n+|\n+$/g, ""); t.length && this.trigger("data", { startPts: this.startPts_, endPts: e, text: t, stream: this.name_ }) }, we.prototype.reset = function () { this.mode_ = "popOn", this.topRow_ = 0, this.startPts_ = 0, this.displayed_ = Se(), this.nonDisplayed_ = Se(), this.lastControlCode_ = null, this.column_ = 0, this.row_ = 14, this.rollUpRows_ = 2, this.formatting_ = [] }, we.prototype.setConstants = function () { 0 === this.dataChannel_ ? (this.BASE_ = 16, this.EXT_ = 17, this.CONTROL_ = (20 | this.field_) << 8, this.OFFSET_ = 23) : 1 === this.dataChannel_ && (this.BASE_ = 24, this.EXT_ = 25, this.CONTROL_ = (28 | this.field_) << 8, this.OFFSET_ = 31), this.PADDING_ = 0, this.RESUME_CAPTION_LOADING_ = 32 | this.CONTROL_, this.END_OF_CAPTION_ = 47 | this.CONTROL_, this.ROLL_UP_2_ROWS_ = 37 | this.CONTROL_, this.ROLL_UP_3_ROWS_ = 38 | this.CONTROL_, this.ROLL_UP_4_ROWS_ = 39 | this.CONTROL_, this.CARRIAGE_RETURN_ = 45 | this.CONTROL_, this.RESUME_DIRECT_CAPTIONING_ = 41 | this.CONTROL_, this.BACKSPACE_ = 33 | this.CONTROL_, this.ERASE_DISPLAYED_MEMORY_ = 44 | this.CONTROL_, this.ERASE_NON_DISPLAYED_MEMORY_ = 46 | this.CONTROL_ }, we.prototype.isSpecialCharacter = function (e, t) { return e === this.EXT_ && t >= 48 && t <= 63 }, we.prototype.isExtCharacter = function (e, t) { return (e === this.EXT_ + 1 || e === this.EXT_ + 2) && t >= 32 && t <= 63 }, we.prototype.isMidRowCode = function (e, t) { return e === this.EXT_ && t >= 32 && t <= 47 }, we.prototype.isOffsetControlCode = function (e, t) { return e === this.OFFSET_ && t >= 33 && t <= 35 }, we.prototype.isPAC = function (e, t) { return e >= this.BASE_ && e < this.BASE_ + 8 && t >= 64 && t <= 127 }, we.prototype.isColorPAC = function (e) { return e >= 64 && e <= 79 || e >= 96 && e <= 127 }, we.prototype.isNormalChar = function (e) { return e >= 32 && e <= 127 }, we.prototype.setRollUp = function (e, t) { if ("rollUp" !== this.mode_ && (this.row_ = 14, this.mode_ = "rollUp", this.flushDisplayed(e), this.nonDisplayed_ = Se(), this.displayed_ = Se()), void 0 !== t && t !== this.row_) for (var n = 0; n < this.rollUpRows_; n++)this.displayed_[t - n] = this.displayed_[this.row_ - n], this.displayed_[this.row_ - n] = ""; void 0 === t && (t = this.row_), this.topRow_ = t - this.rollUpRows_ + 1 }, we.prototype.addFormatting = function (e, t) { this.formatting_ = this.formatting_.concat(t); var n = t.reduce((function (e, t) { return e + "<" + t + ">" }), ""); this[this.mode_](e, n) }, we.prototype.clearFormatting = function (e) { if (this.formatting_.length) { var t = this.formatting_.reverse().reduce((function (e, t) { return e + "</" + t + ">" }), ""); this.formatting_ = [], this[this.mode_](e, t) } }, we.prototype.popOn = function (e, t) { var n = this.nonDisplayed_[this.row_]; n += t, this.nonDisplayed_[this.row_] = n }, we.prototype.rollUp = function (e, t) { var n = this.displayed_[this.row_]; n += t, this.displayed_[this.row_] = n }, we.prototype.shiftRowsUp_ = function () { var e; for (e = 0; e < this.topRow_; e++)this.displayed_[e] = ""; for (e = this.row_ + 1; e < 15; e++)this.displayed_[e] = ""; for (e = this.topRow_; e < this.row_; e++)this.displayed_[e] = this.displayed_[e + 1]; this.displayed_[this.row_] = "" }, we.prototype.paintOn = function (e, t) { var n = this.displayed_[this.row_]; n += t, this.displayed_[this.row_] = n }; var xe = { CaptionStream: pe, Cea608Stream: we, Cea708Stream: ve }, ke = { H264_STREAM_TYPE: 27, ADTS_STREAM_TYPE: 15, METADATA_STREAM_TYPE: 21 }, Ee = B, Ce = "shared", Pe = function (e, t) { var n = 1; for (e > t && (n = -1); Math.abs(t - e) > 4294967296;)e += 8589934592 * n; return e }, Ie = function (e) { var t, n; Ie.prototype.init.call(this), this.type_ = e || Ce, this.push = function (e) { this.type_ !== Ce && e.type !== this.type_ || (void 0 === n && (n = e.dts), e.dts = Pe(e.dts, n), e.pts = Pe(e.pts, n), t = e.dts, this.trigger("data", e)) }, this.flush = function () { n = t, this.trigger("done") }, this.endTimeline = function () { this.flush(), this.trigger("endedtimeline") }, this.discontinuity = function () { n = void 0, t = void 0 }, this.reset = function () { this.discontinuity(), this.trigger("reset") } }; Ie.prototype = new Ee; var Le, Oe = { TimestampRolloverStream: Ie, handleRollover: Pe }, Ae = (e, t, n) => { if (!e) return -1; for (var i = n; i < e.length; i++)if (e[i] === t) return i; return -1 }, Ne = Ae, je = 3, De = function (e, t, n) { var i, r = ""; for (i = t; i < n; i++)r += "%" + ("00" + e[i].toString(16)).slice(-2); return r }, Me = function (e, t, n) { return decodeURIComponent(De(e, t, n)) }, Re = function (e, t, n) { return unescape(De(e, t, n)) }, Ue = function (e) { return e[0] << 21 | e[1] << 14 | e[2] << 7 | e[3] }, Be = { APIC: function (e) { var t, n, i = 1; e.data[0] === je && ((t = Ne(e.data, 0, i)) < 0 || (e.mimeType = Re(e.data, i, t), i = t + 1, e.pictureType = e.data[i], i++, (n = Ne(e.data, 0, i)) < 0 || (e.description = Me(e.data, i, n), i = n + 1, "--\x3e" === e.mimeType ? e.url = Re(e.data, i, e.data.length) : e.pictureData = e.data.subarray(i, e.data.length)))) }, "T*": function (e) { e.data[0] === je && (e.value = Me(e.data, 1, e.data.length).replace(/\0*$/, ""), e.values = e.value.split("\0")) }, TXXX: function (e) { var t; e.data[0] === je && -1 !== (t = Ne(e.data, 0, 1)) && (e.description = Me(e.data, 1, t), e.value = Me(e.data, t + 1, e.data.length).replace(/\0*$/, ""), e.data = e.value) }, "W*": function (e) { e.url = Re(e.data, 0, e.data.length).replace(/\0.*$/, "") }, WXXX: function (e) { var t; e.data[0] === je && -1 !== (t = Ne(e.data, 0, 1)) && (e.description = Me(e.data, 1, t), e.url = Re(e.data, t + 1, e.data.length).replace(/\0.*$/, "")) }, PRIV: function (e) { var t; for (t = 0; t < e.data.length; t++)if (0 === e.data[t]) { e.owner = Re(e.data, 0, t); break } e.privateData = e.data.subarray(t + 1), e.data = e.privateData } }, Fe = { parseId3Frames: function (e) { var t, n = 10, i = 0, r = []; if (!(e.length < 10 || e[0] !== "I".charCodeAt(0) || e[1] !== "D".charCodeAt(0) || e[2] !== "3".charCodeAt(0))) { i = Ue(e.subarray(6, 10)), i += 10, 64 & e[5] && (n += 4, n += Ue(e.subarray(10, 14)), i -= Ue(e.subarray(16, 20))); do { if ((t = Ue(e.subarray(n + 4, n + 8))) < 1) break; var s = { id: String.fromCharCode(e[n], e[n + 1], e[n + 2], e[n + 3]), data: e.subarray(n + 10, n + t + 10) }; s.key = s.id, Be[s.id] ? Be[s.id](s) : "T" === s.id[0] ? Be["T*"](s) : "W" === s.id[0] && Be["W*"](s), r.push(s), n += 10, n += t } while (n < i); return r } }, parseSyncSafeInteger: Ue, frameParsers: Be }, ze = ke, He = Fe; (Le = function (e) { var t, n = { descriptor: e && e.descriptor }, i = 0, r = [], s = 0; if (Le.prototype.init.call(this), this.dispatchType = ze.METADATA_STREAM_TYPE.toString(16), n.descriptor) for (t = 0; t < n.descriptor.length; t++)this.dispatchType += ("00" + n.descriptor[t].toString(16)).slice(-2); this.push = function (e) { var t, n, a, o, l; if ("timed-metadata" === e.type) if (e.dataAlignmentIndicator && (s = 0, r.length = 0), 0 === r.length && (e.data.length < 10 || e.data[0] !== "I".charCodeAt(0) || e.data[1] !== "D".charCodeAt(0) || e.data[2] !== "3".charCodeAt(0))) this.trigger("log", { level: "warn", message: "Skipping unrecognized metadata packet" }); else if (r.push(e), s += e.data.byteLength, 1 === r.length && (i = He.parseSyncSafeInteger(e.data.subarray(6, 10)), i += 10), !(s < i)) { for (t = { data: new Uint8Array(i), frames: [], pts: r[0].pts, dts: r[0].dts }, l = 0; l < i;)t.data.set(r[0].data.subarray(0, i - l), l), l += r[0].data.byteLength, s -= r[0].data.byteLength, r.shift(); n = 10, 64 & t.data[5] && (n += 4, n += He.parseSyncSafeInteger(t.data.subarray(10, 14)), i -= He.parseSyncSafeInteger(t.data.subarray(16, 20))); do { if ((a = He.parseSyncSafeInteger(t.data.subarray(n + 4, n + 8))) < 1) { this.trigger("log", { level: "warn", message: "Malformed ID3 frame encountered. Skipping remaining metadata parsing." }); break } if ((o = { id: String.fromCharCode(t.data[n], t.data[n + 1], t.data[n + 2], t.data[n + 3]), data: t.data.subarray(n + 10, n + a + 10) }).key = o.id, He.frameParsers[o.id] ? He.frameParsers[o.id](o) : "T" === o.id[0] ? He.frameParsers["T*"](o) : "W" === o.id[0] && He.frameParsers["W*"](o), "com.apple.streaming.transportStreamTimestamp" === o.owner) { var c = o.data, u = (1 & c[3]) << 30 | c[4] << 22 | c[5] << 14 | c[6] << 6 | c[7] >>> 2; u *= 4, u += 3 & c[7], o.timeStamp = u, void 0 === t.pts && void 0 === t.dts && (t.pts = o.timeStamp, t.dts = o.timeStamp), this.trigger("timestamp", o) } t.frames.push(o), n += 10, n += a } while (n < i); this.trigger("data", t) } } }).prototype = new B; var Ve, We, qe, Ge = Le, Xe = B, Ke = xe, $e = ke, Ye = Oe.TimestampRolloverStream, Qe = 188; (Ve = function () { var e = new Uint8Array(Qe), t = 0; Ve.prototype.init.call(this), this.push = function (n) { var i, r = 0, s = Qe; for (t ? ((i = new Uint8Array(n.byteLength + t)).set(e.subarray(0, t)), i.set(n, t), t = 0) : i = n; s < i.byteLength;)71 !== i[r] || 71 !== i[s] ? (r++, s++) : (this.trigger("data", i.subarray(r, s)), r += Qe, s += Qe); r < i.byteLength && (e.set(i.subarray(r), 0), t = i.byteLength - r) }, this.flush = function () { t === Qe && 71 === e[0] && (this.trigger("data", e), t = 0), this.trigger("done") }, this.endTimeline = function () { this.flush(), this.trigger("endedtimeline") }, this.reset = function () { t = 0, this.trigger("reset") } }).prototype = new Xe, We = function () { var e, t, n, i; We.prototype.init.call(this), i = this, this.packetsWaitingForPmt = [], this.programMapTable = void 0, e = function (e, i) { var r = 0; i.payloadUnitStartIndicator && (r += e[r] + 1), "pat" === i.type ? t(e.subarray(r), i) : n(e.subarray(r), i) }, t = function (e, t) { t.section_number = e[7], t.last_section_number = e[8], i.pmtPid = (31 & e[10]) << 8 | e[11], t.pmtPid = i.pmtPid }, n = function (e, t) { var n, r; if (1 & e[5]) { for (i.programMapTable = { video: null, audio: null, "timed-metadata": {} }, n = 3 + ((15 & e[1]) << 8 | e[2]) - 4, r = 12 + ((15 & e[10]) << 8 | e[11]); r < n;) { var s = e[r], a = (31 & e[r + 1]) << 8 | e[r + 2]; s === $e.H264_STREAM_TYPE && null === i.programMapTable.video ? i.programMapTable.video = a : s === $e.ADTS_STREAM_TYPE && null === i.programMapTable.audio ? i.programMapTable.audio = a : s === $e.METADATA_STREAM_TYPE && (i.programMapTable["timed-metadata"][a] = s), r += 5 + ((15 & e[r + 3]) << 8 | e[r + 4]) } t.programMapTable = i.programMapTable } }, this.push = function (t) { var n = {}, i = 4; if (n.payloadUnitStartIndicator = !!(64 & t[1]), n.pid = 31 & t[1], n.pid <<= 8, n.pid |= t[2], (48 & t[3]) >>> 4 > 1 && (i += t[i] + 1), 0 === n.pid) n.type = "pat", e(t.subarray(i), n), this.trigger("data", n); else if (n.pid === this.pmtPid) for (n.type = "pmt", e(t.subarray(i), n), this.trigger("data", n); this.packetsWaitingForPmt.length;)this.processPes_.apply(this, this.packetsWaitingForPmt.shift()); else void 0 === this.programMapTable ? this.packetsWaitingForPmt.push([t, i, n]) : this.processPes_(t, i, n) }, this.processPes_ = function (e, t, n) { n.pid === this.programMapTable.video ? n.streamType = $e.H264_STREAM_TYPE : n.pid === this.programMapTable.audio ? n.streamType = $e.ADTS_STREAM_TYPE : n.streamType = this.programMapTable["timed-metadata"][n.pid], n.type = "pes", n.data = e.subarray(t), this.trigger("data", n) } }, We.prototype = new Xe, We.STREAM_TYPES = { h264: 27, adts: 15 }, qe = function () { var e, t = this, n = !1, i = { data: [], size: 0 }, r = { data: [], size: 0 }, s = { data: [], size: 0 }, a = function (e, n, i) { var r, s, a = new Uint8Array(e.size), o = { type: n }, l = 0, c = 0; if (e.data.length && !(e.size < 9)) { for (o.trackId = e.data[0].pid, l = 0; l < e.data.length; l++)s = e.data[l], a.set(s.data, c), c += s.data.byteLength; !function (e, t) { var n; const i = e[0] << 16 | e[1] << 8 | e[2]; t.data = new Uint8Array, 1 === i && (t.packetLength = 6 + (e[4] << 8 | e[5]), t.dataAlignmentIndicator = 0 !== (4 & e[6]), 192 & (n = e[7]) && (t.pts = (14 & e[9]) << 27 | (255 & e[10]) << 20 | (254 & e[11]) << 12 | (255 & e[12]) << 5 | (254 & e[13]) >>> 3, t.pts *= 4, t.pts += (6 & e[13]) >>> 1, t.dts = t.pts, 64 & n && (t.dts = (14 & e[14]) << 27 | (255 & e[15]) << 20 | (254 & e[16]) << 12 | (255 & e[17]) << 5 | (254 & e[18]) >>> 3, t.dts *= 4, t.dts += (6 & e[18]) >>> 1)), t.data = e.subarray(9 + e[8])) }(a, o), r = "video" === n || o.packetLength <= e.size, (i || r) && (e.size = 0, e.data.length = 0), r && t.trigger("data", o) } }; qe.prototype.init.call(this), this.push = function (o) { ({ pat: function () { }, pes: function () { var e, t; switch (o.streamType) { case $e.H264_STREAM_TYPE: e = i, t = "video"; break; case $e.ADTS_STREAM_TYPE: e = r, t = "audio"; break; case $e.METADATA_STREAM_TYPE: e = s, t = "timed-metadata"; break; default: return }o.payloadUnitStartIndicator && a(e, t, !0), e.data.push(o), e.size += o.data.byteLength }, pmt: function () { var i = { type: "metadata", tracks: [] }; null !== (e = o.programMapTable).video && i.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +e.video, codec: "avc", type: "video" }), null !== e.audio && i.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +e.audio, codec: "adts", type: "audio" }), n = !0, t.trigger("data", i) } })[o.type]() }, this.reset = function () { i.size = 0, i.data.length = 0, r.size = 0, r.data.length = 0, this.trigger("reset") }, this.flushStreams_ = function () { a(i, "video"), a(r, "audio"), a(s, "timed-metadata") }, this.flush = function () { if (!n && e) { var i = { type: "metadata", tracks: [] }; null !== e.video && i.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +e.video, codec: "avc", type: "video" }), null !== e.audio && i.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +e.audio, codec: "adts", type: "audio" }), t.trigger("data", i) } n = !1, this.flushStreams_(), this.trigger("done") } }, qe.prototype = new Xe; var Je = { PAT_PID: 0, MP2T_PACKET_LENGTH: Qe, TransportPacketStream: Ve, TransportParseStream: We, ElementaryStream: qe, TimestampRolloverStream: Ye, CaptionStream: Ke.CaptionStream, Cea608Stream: Ke.Cea608Stream, Cea708Stream: Ke.Cea708Stream, MetadataStream: Ge }; for (var Ze in $e) $e.hasOwnProperty(Ze) && (Je[Ze] = $e[Ze]); var et, tt = Je, nt = re.ONE_SECOND_IN_TS, it = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350]; (et = function (e) { var t, n = 0; et.prototype.init.call(this), this.skipWarn_ = function (e, t) { this.trigger("log", { level: "warn", message: "adts skiping bytes ".concat(e, " to ").concat(t, " in frame ").concat(n, " outside syncword") }) }, this.push = function (i) { var r, s, a, o, l, c = 0; if (e || (n = 0), "audio" === i.type) { var u; for (t && t.length ? (a = t, (t = new Uint8Array(a.byteLength + i.data.byteLength)).set(a), t.set(i.data, a.byteLength)) : t = i.data; c + 7 < t.length;)if (255 === t[c] && 240 === (246 & t[c + 1])) { if ("number" === typeof u && (this.skipWarn_(u, c), u = null), s = 2 * (1 & ~t[c + 1]), r = (3 & t[c + 3]) << 11 | t[c + 4] << 3 | (224 & t[c + 5]) >> 5, l = (o = 1024 * (1 + (3 & t[c + 6]))) * nt / it[(60 & t[c + 2]) >>> 2], t.byteLength - c < r) break; this.trigger("data", { pts: i.pts + n * l, dts: i.dts + n * l, sampleCount: o, audioobjecttype: 1 + (t[c + 2] >>> 6 & 3), channelcount: (1 & t[c + 2]) << 2 | (192 & t[c + 3]) >>> 6, samplerate: it[(60 & t[c + 2]) >>> 2], samplingfrequencyindex: (60 & t[c + 2]) >>> 2, samplesize: 16, data: t.subarray(c + 7 + s, c + r) }), n++, c += r } else "number" !== typeof u && (u = c), c++; "number" === typeof u && (this.skipWarn_(u, c), u = null), t = t.subarray(c) } }, this.flush = function () { n = 0, this.trigger("done") }, this.reset = function () { t = void 0, this.trigger("reset") }, this.endTimeline = function () { t = void 0, this.trigger("endedtimeline") } }).prototype = new B; var rt, st, at, ot = et, lt = B, ct = function (e) { var t = e.byteLength, n = 0, i = 0; this.length = function () { return 8 * t }, this.bitsAvailable = function () { return 8 * t + i }, this.loadWord = function () { var r = e.byteLength - t, s = new Uint8Array(4), a = Math.min(4, t); if (0 === a) throw new Error("no bytes available"); s.set(e.subarray(r, r + a)), n = new DataView(s.buffer).getUint32(0), i = 8 * a, t -= a }, this.skipBits = function (e) { var r; i > e ? (n <<= e, i -= e) : (e -= i, e -= 8 * (r = Math.floor(e / 8)), t -= r, this.loadWord(), n <<= e, i -= e) }, this.readBits = function (e) { var r = Math.min(i, e), s = n >>> 32 - r; return (i -= r) > 0 ? n <<= r : t > 0 && this.loadWord(), (r = e - r) > 0 ? s << r | this.readBits(r) : s }, this.skipLeadingZeros = function () { var e; for (e = 0; e < i; ++e)if (0 !== (n & 2147483648 >>> e)) return n <<= e, i -= e, e; return this.loadWord(), e + this.skipLeadingZeros() }, this.skipUnsignedExpGolomb = function () { this.skipBits(1 + this.skipLeadingZeros()) }, this.skipExpGolomb = function () { this.skipBits(1 + this.skipLeadingZeros()) }, this.readUnsignedExpGolomb = function () { var e = this.skipLeadingZeros(); return this.readBits(e + 1) - 1 }, this.readExpGolomb = function () { var e = this.readUnsignedExpGolomb(); return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1) }, this.readBoolean = function () { return 1 === this.readBits(1) }, this.readUnsignedByte = function () { return this.readBits(8) }, this.loadWord() }; (st = function () { var e, t, n = 0; st.prototype.init.call(this), this.push = function (i) { var r; t ? ((r = new Uint8Array(t.byteLength + i.data.byteLength)).set(t), r.set(i.data, t.byteLength), t = r) : t = i.data; for (var s = t.byteLength; n < s - 3; n++)if (1 === t[n + 2]) { e = n + 5; break } for (; e < s;)switch (t[e]) { case 0: if (0 !== t[e - 1]) { e += 2; break } if (0 !== t[e - 2]) { e++; break } n + 3 !== e - 2 && this.trigger("data", t.subarray(n + 3, e - 2)); do { e++ } while (1 !== t[e] && e < s); n = e - 2, e += 3; break; case 1: if (0 !== t[e - 1] || 0 !== t[e - 2]) { e += 3; break } this.trigger("data", t.subarray(n + 3, e - 2)), n = e - 2, e += 3; break; default: e += 3 }t = t.subarray(n), e -= n, n = 0 }, this.reset = function () { t = null, n = 0, this.trigger("reset") }, this.flush = function () { t && t.byteLength > 3 && this.trigger("data", t.subarray(n + 3)), t = null, n = 0, this.trigger("done") }, this.endTimeline = function () { this.flush(), this.trigger("endedtimeline") } }).prototype = new lt, at = { 100: !0, 110: !0, 122: !0, 244: !0, 44: !0, 83: !0, 86: !0, 118: !0, 128: !0, 138: !0, 139: !0, 134: !0 }, rt = function () { var e, t, n, i, r, s, a, o = new st; rt.prototype.init.call(this), e = this, this.push = function (e) { "video" === e.type && (t = e.trackId, n = e.pts, i = e.dts, o.push(e)) }, o.on("data", (function (a) { var o = { trackId: t, pts: n, dts: i, data: a, nalUnitTypeCode: 31 & a[0] }; switch (o.nalUnitTypeCode) { case 5: o.nalUnitType = "slice_layer_without_partitioning_rbsp_idr"; break; case 6: o.nalUnitType = "sei_rbsp", o.escapedRBSP = r(a.subarray(1)); break; case 7: o.nalUnitType = "seq_parameter_set_rbsp", o.escapedRBSP = r(a.subarray(1)), o.config = s(o.escapedRBSP); break; case 8: o.nalUnitType = "pic_parameter_set_rbsp"; break; case 9: o.nalUnitType = "access_unit_delimiter_rbsp" }e.trigger("data", o) })), o.on("done", (function () { e.trigger("done") })), o.on("partialdone", (function () { e.trigger("partialdone") })), o.on("reset", (function () { e.trigger("reset") })), o.on("endedtimeline", (function () { e.trigger("endedtimeline") })), this.flush = function () { o.flush() }, this.partialFlush = function () { o.partialFlush() }, this.reset = function () { o.reset() }, this.endTimeline = function () { o.endTimeline() }, a = function (e, t) { var n, i = 8, r = 8; for (n = 0; n < e; n++)0 !== r && (r = (i + t.readExpGolomb() + 256) % 256), i = 0 === r ? i : r }, r = function (e) { for (var t, n, i = e.byteLength, r = [], s = 1; s < i - 2;)0 === e[s] && 0 === e[s + 1] && 3 === e[s + 2] ? (r.push(s + 2), s += 2) : s++; if (0 === r.length) return e; t = i - r.length, n = new Uint8Array(t); var a = 0; for (s = 0; s < t; a++, s++)a === r[0] && (a++, r.shift()), n[s] = e[a]; return n }, s = function (e) { var t, n, i, r, s, o, l, c, u, d, h, p, f = 0, m = 0, g = 0, y = 0, v = [1, 1]; if (n = (t = new ct(e)).readUnsignedByte(), r = t.readUnsignedByte(), i = t.readUnsignedByte(), t.skipUnsignedExpGolomb(), at[n] && (3 === (s = t.readUnsignedExpGolomb()) && t.skipBits(1), t.skipUnsignedExpGolomb(), t.skipUnsignedExpGolomb(), t.skipBits(1), t.readBoolean())) for (h = 3 !== s ? 8 : 12, p = 0; p < h; p++)t.readBoolean() && a(p < 6 ? 16 : 64, t); if (t.skipUnsignedExpGolomb(), 0 === (o = t.readUnsignedExpGolomb())) t.readUnsignedExpGolomb(); else if (1 === o) for (t.skipBits(1), t.skipExpGolomb(), t.skipExpGolomb(), l = t.readUnsignedExpGolomb(), p = 0; p < l; p++)t.skipExpGolomb(); if (t.skipUnsignedExpGolomb(), t.skipBits(1), c = t.readUnsignedExpGolomb(), u = t.readUnsignedExpGolomb(), 0 === (d = t.readBits(1)) && t.skipBits(1), t.skipBits(1), t.readBoolean() && (f = t.readUnsignedExpGolomb(), m = t.readUnsignedExpGolomb(), g = t.readUnsignedExpGolomb(), y = t.readUnsignedExpGolomb()), t.readBoolean() && t.readBoolean()) { switch (t.readUnsignedByte()) { case 1: v = [1, 1]; break; case 2: v = [12, 11]; break; case 3: v = [10, 11]; break; case 4: v = [16, 11]; break; case 5: v = [40, 33]; break; case 6: v = [24, 11]; break; case 7: v = [20, 11]; break; case 8: v = [32, 11]; break; case 9: v = [80, 33]; break; case 10: v = [18, 11]; break; case 11: v = [15, 11]; break; case 12: v = [64, 33]; break; case 13: v = [160, 99]; break; case 14: v = [4, 3]; break; case 15: v = [3, 2]; break; case 16: v = [2, 1]; break; case 255: v = [t.readUnsignedByte() << 8 | t.readUnsignedByte(), t.readUnsignedByte() << 8 | t.readUnsignedByte()] }v && (v[0], v[1]) } return { profileIdc: n, levelIdc: i, profileCompatibility: r, width: 16 * (c + 1) - 2 * f - 2 * m, height: (2 - d) * (u + 1) * 16 - 2 * g - 2 * y, sarRatio: v } } }, rt.prototype = new lt; var ut, dt = { H264Stream: rt, NalByteStream: st }, ht = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], pt = function (e, t) { var n = e[t + 6] << 21 | e[t + 7] << 14 | e[t + 8] << 7 | e[t + 9]; return n = n >= 0 ? n : 0, (16 & e[t + 5]) >> 4 ? n + 20 : n + 10 }, ft = function (e, t) { return e.length - t < 10 || e[t] !== "I".charCodeAt(0) || e[t + 1] !== "D".charCodeAt(0) || e[t + 2] !== "3".charCodeAt(0) ? t : (t += pt(e, t), ft(e, t)) }, mt = function (e) { return e[0] << 21 | e[1] << 14 | e[2] << 7 | e[3] }, gt = { isLikelyAacData: function (e) { var t = ft(e, 0); return e.length >= t + 2 && 255 === (255 & e[t]) && 240 === (240 & e[t + 1]) && 16 === (22 & e[t + 1]) }, parseId3TagSize: pt, parseAdtsSize: function (e, t) { var n = (224 & e[t + 5]) >> 5, i = e[t + 4] << 3; return 6144 & e[t + 3] | i | n }, parseType: function (e, t) { return e[t] === "I".charCodeAt(0) && e[t + 1] === "D".charCodeAt(0) && e[t + 2] === "3".charCodeAt(0) ? "timed-metadata" : !0 & e[t] && 240 === (240 & e[t + 1]) ? "audio" : null }, parseSampleRate: function (e) { for (var t = 0; t + 5 < e.length;) { if (255 === e[t] && 240 === (246 & e[t + 1])) return ht[(60 & e[t + 2]) >>> 2]; t++ } return null }, parseAacTimestamp: function (e) { var t, n, i; t = 10, 64 & e[5] && (t += 4, t += mt(e.subarray(10, 14))); do { if ((n = mt(e.subarray(t + 4, t + 8))) < 1) return null; if ("PRIV" === String.fromCharCode(e[t], e[t + 1], e[t + 2], e[t + 3])) { i = e.subarray(t + 10, t + n + 10); for (var r = 0; r < i.byteLength; r++)if (0 === i[r]) { var s = unescape(function (e, t, n) { var i, r = ""; for (i = t; i < n; i++)r += "%" + ("00" + e[i].toString(16)).slice(-2); return r }(i, 0, r)); if ("com.apple.streaming.transportStreamTimestamp" === s) { var a = i.subarray(r + 1), o = (1 & a[3]) << 30 | a[4] << 22 | a[5] << 14 | a[6] << 6 | a[7] >>> 2; return o *= 4, o += 3 & a[7] } break } } t += 10, t += n } while (t < e.byteLength); return null } }, yt = gt; (ut = function () { var e = new Uint8Array, t = 0; ut.prototype.init.call(this), this.setTimestamp = function (e) { t = e }, this.push = function (n) { var i, r, s, a, o = 0, l = 0; for (e.length ? (a = e.length, (e = new Uint8Array(n.byteLength + a)).set(e.subarray(0, a)), e.set(n, a)) : e = n; e.length - l >= 3;)if (e[l] !== "I".charCodeAt(0) || e[l + 1] !== "D".charCodeAt(0) || e[l + 2] !== "3".charCodeAt(0)) if (255 !== (255 & e[l]) || 240 !== (240 & e[l + 1])) l++; else { if (e.length - l < 7) break; if (l + (o = yt.parseAdtsSize(e, l)) > e.length) break; s = { type: "audio", data: e.subarray(l, l + o), pts: t, dts: t }, this.trigger("data", s), l += o } else { if (e.length - l < 10) break; if (l + (o = yt.parseId3TagSize(e, l)) > e.length) break; r = { type: "timed-metadata", data: e.subarray(l, l + o) }, this.trigger("data", r), l += o } i = e.length - l, e = i > 0 ? e.subarray(l) : new Uint8Array }, this.reset = function () { e = new Uint8Array, this.trigger("reset") }, this.endTimeline = function () { e = new Uint8Array, this.trigger("endedtimeline") } }).prototype = new B; var vt, bt, _t, Tt, St = B, wt = Q, xt = Z, kt = oe, Et = ce, Ct = tt, Pt = re, It = ot, Lt = dt.H264Stream, Ot = ut, At = gt.isLikelyAacData, Nt = re.ONE_SECOND_IN_TS, jt = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"], Dt = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"], Mt = function (e, t) { t.stream = e, this.trigger("log", t) }, Rt = function (e, t) { for (var n = Object.keys(t), i = 0; i < n.length; i++) { var r = n[i]; "headOfPipeline" !== r && t[r].on && t[r].on("log", Mt.bind(e, r)) } }, Ut = function (e, t) { var n; if (e.length !== t.length) return !1; for (n = 0; n < e.length; n++)if (e[n] !== t[n]) return !1; return !0 }, Bt = function (e, t, n, i, r, s) { return { start: { dts: e, pts: e + (n - t) }, end: { dts: e + (i - t), pts: e + (r - n) }, prependedContentDuration: s, baseMediaDecodeTime: e } }; bt = function (e, t) { var n, i = [], r = 0, s = 0, a = 1 / 0; n = (t = t || {}).firstSequenceNumber || 0, bt.prototype.init.call(this), this.push = function (t) { Et.collectDtsInfo(e, t), e && jt.forEach((function (n) { e[n] = t[n] })), i.push(t) }, this.setEarliestDts = function (e) { r = e }, this.setVideoBaseMediaDecodeTime = function (e) { a = e }, this.setAudioAppendStart = function (e) { s = e }, this.flush = function () { var o, l, c, u, d, h, p; 0 !== i.length ? (o = kt.trimAdtsFramesByEarliestDts(i, e, r), e.baseMediaDecodeTime = Et.calculateTrackBaseMediaDecodeTime(e, t.keepOriginalTimestamps), p = kt.prefixWithSilence(e, o, s, a), e.samples = kt.generateSampleTable(o), c = wt.mdat(kt.concatenateFrameData(o)), i = [], l = wt.moof(n, [e]), u = new Uint8Array(l.byteLength + c.byteLength), n++, u.set(l), u.set(c, l.byteLength), Et.clearDtsInfo(e), d = Math.ceil(1024 * Nt / e.samplerate), o.length && (h = o.length * d, this.trigger("segmentTimingInfo", Bt(Pt.audioTsToVideoTs(e.baseMediaDecodeTime, e.samplerate), o[0].dts, o[0].pts, o[0].dts + h, o[0].pts + h, p || 0)), this.trigger("timingInfo", { start: o[0].pts, end: o[0].pts + h })), this.trigger("data", { track: e, boxes: u }), this.trigger("done", "AudioSegmentStream")) : this.trigger("done", "AudioSegmentStream") }, this.reset = function () { Et.clearDtsInfo(e), i = [], this.trigger("reset") } }, bt.prototype = new St, vt = function (e, t) { var n, i, r, s = [], a = []; n = (t = t || {}).firstSequenceNumber || 0, vt.prototype.init.call(this), delete e.minPTS, this.gopCache_ = [], this.push = function (t) { Et.collectDtsInfo(e, t), "seq_parameter_set_rbsp" !== t.nalUnitType || i || (i = t.config, e.sps = [t.data], Dt.forEach((function (t) { e[t] = i[t] }), this)), "pic_parameter_set_rbsp" !== t.nalUnitType || r || (r = t.data, e.pps = [t.data]), s.push(t) }, this.flush = function () { for (var i, r, o, l, c, u, d, h, p = 0; s.length && "access_unit_delimiter_rbsp" !== s[0].nalUnitType;)s.shift(); if (0 === s.length) return this.resetStream_(), void this.trigger("done", "VideoSegmentStream"); if (i = xt.groupNalsIntoFrames(s), (o = xt.groupFramesIntoGops(i))[0][0].keyFrame || ((r = this.getGopForFusion_(s[0], e)) ? (p = r.duration, o.unshift(r), o.byteLength += r.byteLength, o.nalCount += r.nalCount, o.pts = r.pts, o.dts = r.dts, o.duration += r.duration) : o = xt.extendFirstKeyFrame(o)), a.length) { var f; if (!(f = t.alignGopsAtEnd ? this.alignGopsAtEnd_(o) : this.alignGopsAtStart_(o))) return this.gopCache_.unshift({ gop: o.pop(), pps: e.pps, sps: e.sps }), this.gopCache_.length = Math.min(6, this.gopCache_.length), s = [], this.resetStream_(), void this.trigger("done", "VideoSegmentStream"); Et.clearDtsInfo(e), o = f } Et.collectDtsInfo(e, o), e.samples = xt.generateSampleTable(o), c = wt.mdat(xt.concatenateNalData(o)), e.baseMediaDecodeTime = Et.calculateTrackBaseMediaDecodeTime(e, t.keepOriginalTimestamps), this.trigger("processedGopsInfo", o.map((function (e) { return { pts: e.pts, dts: e.dts, byteLength: e.byteLength } }))), d = o[0], h = o[o.length - 1], this.trigger("segmentTimingInfo", Bt(e.baseMediaDecodeTime, d.dts, d.pts, h.dts + h.duration, h.pts + h.duration, p)), this.trigger("timingInfo", { start: o[0].pts, end: o[o.length - 1].pts + o[o.length - 1].duration }), this.gopCache_.unshift({ gop: o.pop(), pps: e.pps, sps: e.sps }), this.gopCache_.length = Math.min(6, this.gopCache_.length), s = [], this.trigger("baseMediaDecodeTime", e.baseMediaDecodeTime), this.trigger("timelineStartInfo", e.timelineStartInfo), l = wt.moof(n, [e]), u = new Uint8Array(l.byteLength + c.byteLength), n++, u.set(l), u.set(c, l.byteLength), this.trigger("data", { track: e, boxes: u }), this.resetStream_(), this.trigger("done", "VideoSegmentStream") }, this.reset = function () { this.resetStream_(), s = [], this.gopCache_.length = 0, a.length = 0, this.trigger("reset") }, this.resetStream_ = function () { Et.clearDtsInfo(e), i = void 0, r = void 0 }, this.getGopForFusion_ = function (t) { var n, i, r, s, a, o = 1 / 0; for (a = 0; a < this.gopCache_.length; a++)r = (s = this.gopCache_[a]).gop, e.pps && Ut(e.pps[0], s.pps[0]) && e.sps && Ut(e.sps[0], s.sps[0]) && (r.dts < e.timelineStartInfo.dts || (n = t.dts - r.dts - r.duration) >= -1e4 && n <= 45e3 && (!i || o > n) && (i = s, o = n)); return i ? i.gop : null }, this.alignGopsAtStart_ = function (e) { var t, n, i, r, s, o, l, c; for (s = e.byteLength, o = e.nalCount, l = e.duration, t = n = 0; t < a.length && n < e.length && (i = a[t], r = e[n], i.pts !== r.pts);)r.pts > i.pts ? t++ : (n++, s -= r.byteLength, o -= r.nalCount, l -= r.duration); return 0 === n ? e : n === e.length ? null : ((c = e.slice(n)).byteLength = s, c.duration = l, c.nalCount = o, c.pts = c[0].pts, c.dts = c[0].dts, c) }, this.alignGopsAtEnd_ = function (e) { var t, n, i, r, s, o, l; for (t = a.length - 1, n = e.length - 1, s = null, o = !1; t >= 0 && n >= 0;) { if (i = a[t], r = e[n], i.pts === r.pts) { o = !0; break } i.pts > r.pts ? t-- : (t === a.length - 1 && (s = n), n--) } if (!o && null === s) return null; if (0 === (l = o ? n : s)) return e; var c = e.slice(l), u = c.reduce((function (e, t) { return e.byteLength += t.byteLength, e.duration += t.duration, e.nalCount += t.nalCount, e }), { byteLength: 0, duration: 0, nalCount: 0 }); return c.byteLength = u.byteLength, c.duration = u.duration, c.nalCount = u.nalCount, c.pts = c[0].pts, c.dts = c[0].dts, c }, this.alignGopsWith = function (e) { a = e } }, vt.prototype = new St, Tt = function (e, t) { this.numberOfTracks = 0, this.metadataStream = t, "undefined" !== typeof (e = e || {}).remux ? this.remuxTracks = !!e.remux : this.remuxTracks = !0, "boolean" === typeof e.keepOriginalTimestamps ? this.keepOriginalTimestamps = e.keepOriginalTimestamps : this.keepOriginalTimestamps = !1, this.pendingTracks = [], this.videoTrack = null, this.pendingBoxes = [], this.pendingCaptions = [], this.pendingMetadata = [], this.pendingBytes = 0, this.emittedTracks = 0, Tt.prototype.init.call(this), this.push = function (e) { return e.text ? this.pendingCaptions.push(e) : e.frames ? this.pendingMetadata.push(e) : (this.pendingTracks.push(e.track), this.pendingBytes += e.boxes.byteLength, "video" === e.track.type && (this.videoTrack = e.track, this.pendingBoxes.push(e.boxes)), void ("audio" === e.track.type && (this.audioTrack = e.track, this.pendingBoxes.unshift(e.boxes)))) } }, Tt.prototype = new St, Tt.prototype.flush = function (e) { var t, n, i, r, s = 0, a = { captions: [], captionStreams: {}, metadata: [], info: {} }, o = 0; if (this.pendingTracks.length < this.numberOfTracks) { if ("VideoSegmentStream" !== e && "AudioSegmentStream" !== e) return; if (this.remuxTracks) return; if (0 === this.pendingTracks.length) return this.emittedTracks++, void (this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0)) } if (this.videoTrack ? (o = this.videoTrack.timelineStartInfo.pts, Dt.forEach((function (e) { a.info[e] = this.videoTrack[e] }), this)) : this.audioTrack && (o = this.audioTrack.timelineStartInfo.pts, jt.forEach((function (e) { a.info[e] = this.audioTrack[e] }), this)), this.videoTrack || this.audioTrack) { for (1 === this.pendingTracks.length ? a.type = this.pendingTracks[0].type : a.type = "combined", this.emittedTracks += this.pendingTracks.length, i = wt.initSegment(this.pendingTracks), a.initSegment = new Uint8Array(i.byteLength), a.initSegment.set(i), a.data = new Uint8Array(this.pendingBytes), r = 0; r < this.pendingBoxes.length; r++)a.data.set(this.pendingBoxes[r], s), s += this.pendingBoxes[r].byteLength; for (r = 0; r < this.pendingCaptions.length; r++)(t = this.pendingCaptions[r]).startTime = Pt.metadataTsToSeconds(t.startPts, o, this.keepOriginalTimestamps), t.endTime = Pt.metadataTsToSeconds(t.endPts, o, this.keepOriginalTimestamps), a.captionStreams[t.stream] = !0, a.captions.push(t); for (r = 0; r < this.pendingMetadata.length; r++)(n = this.pendingMetadata[r]).cueTime = Pt.metadataTsToSeconds(n.pts, o, this.keepOriginalTimestamps), a.metadata.push(n); for (a.metadata.dispatchType = this.metadataStream.dispatchType, this.pendingTracks.length = 0, this.videoTrack = null, this.pendingBoxes.length = 0, this.pendingCaptions.length = 0, this.pendingBytes = 0, this.pendingMetadata.length = 0, this.trigger("data", a), r = 0; r < a.captions.length; r++)t = a.captions[r], this.trigger("caption", t); for (r = 0; r < a.metadata.length; r++)n = a.metadata[r], this.trigger("id3Frame", n) } this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0) }, Tt.prototype.setRemux = function (e) { this.remuxTracks = e }, (_t = function (e) { var t, n, i = this, r = !0; _t.prototype.init.call(this), e = e || {}, this.baseMediaDecodeTime = e.baseMediaDecodeTime || 0, this.transmuxPipeline_ = {}, this.setupAacPipeline = function () { var r = {}; this.transmuxPipeline_ = r, r.type = "aac", r.metadataStream = new Ct.MetadataStream, r.aacStream = new Ot, r.audioTimestampRolloverStream = new Ct.TimestampRolloverStream("audio"), r.timedMetadataTimestampRolloverStream = new Ct.TimestampRolloverStream("timed-metadata"), r.adtsStream = new It, r.coalesceStream = new Tt(e, r.metadataStream), r.headOfPipeline = r.aacStream, r.aacStream.pipe(r.audioTimestampRolloverStream).pipe(r.adtsStream), r.aacStream.pipe(r.timedMetadataTimestampRolloverStream).pipe(r.metadataStream).pipe(r.coalesceStream), r.metadataStream.on("timestamp", (function (e) { r.aacStream.setTimestamp(e.timeStamp) })), r.aacStream.on("data", (function (s) { "timed-metadata" !== s.type && "audio" !== s.type || r.audioSegmentStream || (n = n || { timelineStartInfo: { baseMediaDecodeTime: i.baseMediaDecodeTime }, codec: "adts", type: "audio" }, r.coalesceStream.numberOfTracks++, r.audioSegmentStream = new bt(n, e), r.audioSegmentStream.on("log", i.getLogTrigger_("audioSegmentStream")), r.audioSegmentStream.on("timingInfo", i.trigger.bind(i, "audioTimingInfo")), r.adtsStream.pipe(r.audioSegmentStream).pipe(r.coalesceStream), i.trigger("trackinfo", { hasAudio: !!n, hasVideo: !!t })) })), r.coalesceStream.on("data", this.trigger.bind(this, "data")), r.coalesceStream.on("done", this.trigger.bind(this, "done")), Rt(this, r) }, this.setupTsPipeline = function () { var r = {}; this.transmuxPipeline_ = r, r.type = "ts", r.metadataStream = new Ct.MetadataStream, r.packetStream = new Ct.TransportPacketStream, r.parseStream = new Ct.TransportParseStream, r.elementaryStream = new Ct.ElementaryStream, r.timestampRolloverStream = new Ct.TimestampRolloverStream, r.adtsStream = new It, r.h264Stream = new Lt, r.captionStream = new Ct.CaptionStream(e), r.coalesceStream = new Tt(e, r.metadataStream), r.headOfPipeline = r.packetStream, r.packetStream.pipe(r.parseStream).pipe(r.elementaryStream).pipe(r.timestampRolloverStream), r.timestampRolloverStream.pipe(r.h264Stream), r.timestampRolloverStream.pipe(r.adtsStream), r.timestampRolloverStream.pipe(r.metadataStream).pipe(r.coalesceStream), r.h264Stream.pipe(r.captionStream).pipe(r.coalesceStream), r.elementaryStream.on("data", (function (s) { var a; if ("metadata" === s.type) { for (a = s.tracks.length; a--;)t || "video" !== s.tracks[a].type ? n || "audio" !== s.tracks[a].type || ((n = s.tracks[a]).timelineStartInfo.baseMediaDecodeTime = i.baseMediaDecodeTime) : (t = s.tracks[a]).timelineStartInfo.baseMediaDecodeTime = i.baseMediaDecodeTime; t && !r.videoSegmentStream && (r.coalesceStream.numberOfTracks++, r.videoSegmentStream = new vt(t, e), r.videoSegmentStream.on("log", i.getLogTrigger_("videoSegmentStream")), r.videoSegmentStream.on("timelineStartInfo", (function (t) { n && !e.keepOriginalTimestamps && (n.timelineStartInfo = t, r.audioSegmentStream.setEarliestDts(t.dts - i.baseMediaDecodeTime)) })), r.videoSegmentStream.on("processedGopsInfo", i.trigger.bind(i, "gopInfo")), r.videoSegmentStream.on("segmentTimingInfo", i.trigger.bind(i, "videoSegmentTimingInfo")), r.videoSegmentStream.on("baseMediaDecodeTime", (function (e) { n && r.audioSegmentStream.setVideoBaseMediaDecodeTime(e) })), r.videoSegmentStream.on("timingInfo", i.trigger.bind(i, "videoTimingInfo")), r.h264Stream.pipe(r.videoSegmentStream).pipe(r.coalesceStream)), n && !r.audioSegmentStream && (r.coalesceStream.numberOfTracks++, r.audioSegmentStream = new bt(n, e), r.audioSegmentStream.on("log", i.getLogTrigger_("audioSegmentStream")), r.audioSegmentStream.on("timingInfo", i.trigger.bind(i, "audioTimingInfo")), r.audioSegmentStream.on("segmentTimingInfo", i.trigger.bind(i, "audioSegmentTimingInfo")), r.adtsStream.pipe(r.audioSegmentStream).pipe(r.coalesceStream)), i.trigger("trackinfo", { hasAudio: !!n, hasVideo: !!t }) } })), r.coalesceStream.on("data", this.trigger.bind(this, "data")), r.coalesceStream.on("id3Frame", (function (e) { e.dispatchType = r.metadataStream.dispatchType, i.trigger("id3Frame", e) })), r.coalesceStream.on("caption", this.trigger.bind(this, "caption")), r.coalesceStream.on("done", this.trigger.bind(this, "done")), Rt(this, r) }, this.setBaseMediaDecodeTime = function (i) { var r = this.transmuxPipeline_; e.keepOriginalTimestamps || (this.baseMediaDecodeTime = i), n && (n.timelineStartInfo.dts = void 0, n.timelineStartInfo.pts = void 0, Et.clearDtsInfo(n), r.audioTimestampRolloverStream && r.audioTimestampRolloverStream.discontinuity()), t && (r.videoSegmentStream && (r.videoSegmentStream.gopCache_ = []), t.timelineStartInfo.dts = void 0, t.timelineStartInfo.pts = void 0, Et.clearDtsInfo(t), r.captionStream.reset()), r.timestampRolloverStream && r.timestampRolloverStream.discontinuity() }, this.setAudioAppendStart = function (e) { n && this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(e) }, this.setRemux = function (t) { var n = this.transmuxPipeline_; e.remux = t, n && n.coalesceStream && n.coalesceStream.setRemux(t) }, this.alignGopsWith = function (e) { t && this.transmuxPipeline_.videoSegmentStream && this.transmuxPipeline_.videoSegmentStream.alignGopsWith(e) }, this.getLogTrigger_ = function (e) { var t = this; return function (n) { n.stream = e, t.trigger("log", n) } }, this.push = function (e) { if (r) { var t = At(e); t && "aac" !== this.transmuxPipeline_.type ? this.setupAacPipeline() : t || "ts" === this.transmuxPipeline_.type || this.setupTsPipeline(), r = !1 } this.transmuxPipeline_.headOfPipeline.push(e) }, this.flush = function () { r = !0, this.transmuxPipeline_.headOfPipeline.flush() }, this.endTimeline = function () { this.transmuxPipeline_.headOfPipeline.endTimeline() }, this.reset = function () { this.transmuxPipeline_.headOfPipeline && this.transmuxPipeline_.headOfPipeline.reset() }, this.resetCaptions = function () { this.transmuxPipeline_.captionStream && this.transmuxPipeline_.captionStream.reset() } }).prototype = new St; var Ft, zt, Ht, Vt, Wt = { Transmuxer: _t, VideoSegmentStream: vt, AudioSegmentStream: bt, AUDIO_PROPERTIES: jt, VIDEO_PROPERTIES: Dt, generateSegmentTimingInfo: Bt }, qt = function (e) { return e >>> 0 }, Gt = function (e) { var t = ""; return t += String.fromCharCode(e[0]), t += String.fromCharCode(e[1]), t += String.fromCharCode(e[2]), t += String.fromCharCode(e[3]) }, Xt = qt, Kt = Gt, $t = function (e, t) { var n, i, r, s, a, o = []; if (!t.length) return null; for (n = 0; n < e.byteLength;)i = Xt(e[n] << 24 | e[n + 1] << 16 | e[n + 2] << 8 | e[n + 3]), r = Kt(e.subarray(n + 4, n + 8)), s = i > 1 ? n + i : e.byteLength, r === t[0] && (1 === t.length ? o.push(e.subarray(n + 8, s)) : (a = $t(e.subarray(n + 8, s), t.slice(1))).length && (o = o.concat(a))), n = s; return o }, Yt = qt, Qt = z.getUint64, Jt = function (e) { var t = { version: e[0], flags: new Uint8Array(e.subarray(1, 4)) }; return 1 === t.version ? t.baseMediaDecodeTime = Qt(e.subarray(4)) : t.baseMediaDecodeTime = Yt(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7]), t }, Zt = function (e) { return { isLeading: (12 & e[0]) >>> 2, dependsOn: 3 & e[0], isDependedOn: (192 & e[1]) >>> 6, hasRedundancy: (48 & e[1]) >>> 4, paddingValue: (14 & e[1]) >>> 1, isNonSyncSample: 1 & e[1], degradationPriority: e[2] << 8 | e[3] } }, en = function (e) { var t, n = { version: e[0], flags: new Uint8Array(e.subarray(1, 4)), samples: [] }, i = new DataView(e.buffer, e.byteOffset, e.byteLength), r = 1 & n.flags[2], s = 4 & n.flags[2], a = 1 & n.flags[1], o = 2 & n.flags[1], l = 4 & n.flags[1], c = 8 & n.flags[1], u = i.getUint32(4), d = 8; for (r && (n.dataOffset = i.getInt32(d), d += 4), s && u && (t = { flags: Zt(e.subarray(d, d + 4)) }, d += 4, a && (t.duration = i.getUint32(d), d += 4), o && (t.size = i.getUint32(d), d += 4), c && (1 === n.version ? t.compositionTimeOffset = i.getInt32(d) : t.compositionTimeOffset = i.getUint32(d), d += 4), n.samples.push(t), u--); u--;)t = {}, a && (t.duration = i.getUint32(d), d += 4), o && (t.size = i.getUint32(d), d += 4), l && (t.flags = Zt(e.subarray(d, d + 4)), d += 4), c && (1 === n.version ? t.compositionTimeOffset = i.getInt32(d) : t.compositionTimeOffset = i.getUint32(d), d += 4), n.samples.push(t); return n }, tn = function (e) { var t, n = new DataView(e.buffer, e.byteOffset, e.byteLength), i = { version: e[0], flags: new Uint8Array(e.subarray(1, 4)), trackId: n.getUint32(4) }, r = 1 & i.flags[2], s = 2 & i.flags[2], a = 8 & i.flags[2], o = 16 & i.flags[2], l = 32 & i.flags[2], c = 65536 & i.flags[0], u = 131072 & i.flags[0]; return t = 8, r && (t += 4, i.baseDataOffset = n.getUint32(12), t += 4), s && (i.sampleDescriptionIndex = n.getUint32(t), t += 4), a && (i.defaultSampleDuration = n.getUint32(t), t += 4), o && (i.defaultSampleSize = n.getUint32(t), t += 4), l && (i.defaultSampleFlags = n.getUint32(t)), c && (i.durationIsEmpty = !0), !r && u && (i.baseDataOffsetIsMoof = !0), i }, nn = (Ft = "undefined" !== typeof window ? window : "undefined" !== typeof e ? e : "undefined" !== typeof self ? self : {}, ue.discardEmulationPreventionBytes), rn = xe.CaptionStream, sn = $t, an = Jt, on = en, ln = tn, cn = Ft, un = function (e, t) { for (var n = e, i = 0; i < t.length; i++) { var r = t[i]; if (n < r.size) return r; n -= r.size } return null }, dn = function (e, t) { var n = sn(e, ["moof", "traf"]), i = sn(e, ["mdat"]), r = {}, s = []; return i.forEach((function (e, t) { var i = n[t]; s.push({ mdat: e, traf: i }) })), s.forEach((function (e) { var n, i, s = e.mdat, a = e.traf, o = sn(a, ["tfhd"]), l = ln(o[0]), c = l.trackId, u = sn(a, ["tfdt"]), d = u.length > 0 ? an(u[0]).baseMediaDecodeTime : 0, h = sn(a, ["trun"]); t === c && h.length > 0 && (n = function (e, t, n) { var i = t, r = n.defaultSampleDuration || 0, s = n.defaultSampleSize || 0, a = n.trackId, o = []; return e.forEach((function (e) { var t = on(e).samples; t.forEach((function (e) { void 0 === e.duration && (e.duration = r), void 0 === e.size && (e.size = s), e.trackId = a, e.dts = i, void 0 === e.compositionTimeOffset && (e.compositionTimeOffset = 0), "bigint" === typeof i ? (e.pts = i + cn.BigInt(e.compositionTimeOffset), i += cn.BigInt(e.duration)) : (e.pts = i + e.compositionTimeOffset, i += e.duration) })), o = o.concat(t) })), o }(h, d, l), i = function (e, t, n) { var i, r, s, a, o = new DataView(e.buffer, e.byteOffset, e.byteLength), l = { logs: [], seiNals: [] }; for (r = 0; r + 4 < e.length; r += s)if (s = o.getUint32(r), r += 4, !(s <= 0)) switch (31 & e[r]) { case 6: var c = e.subarray(r + 1, r + 1 + s), u = un(r, t); if (i = { nalUnitType: "sei_rbsp", size: s, data: c, escapedRBSP: nn(c), trackId: n }, u) i.pts = u.pts, i.dts = u.dts, a = u; else { if (!a) { l.logs.push({ level: "warn", message: "We've encountered a nal unit without data at " + r + " for trackId " + n + ". See mux.js#223." }); break } i.pts = a.pts, i.dts = a.dts } l.seiNals.push(i) }return l }(s, n, c), r[c] || (r[c] = { seiNals: [], logs: [] }), r[c].seiNals = r[c].seiNals.concat(i.seiNals), r[c].logs = r[c].logs.concat(i.logs)) })), r }, hn = function () { var e, t, n, i, r, s, a = !1; this.isInitialized = function () { return a }, this.init = function (t) { e = new rn, a = !0, s = !!t && t.isPartial, e.on("data", (function (e) { e.startTime = e.startPts / i, e.endTime = e.endPts / i, r.captions.push(e), r.captionStreams[e.stream] = !0 })), e.on("log", (function (e) { r.logs.push(e) })) }, this.isNewInit = function (e, t) { return !(e && 0 === e.length || t && "object" === typeof t && 0 === Object.keys(t).length) && (n !== e[0] || i !== t[n]) }, this.parse = function (e, s, a) { var o; if (!this.isInitialized()) return null; if (!s || !a) return null; if (this.isNewInit(s, a)) n = s[0], i = a[n]; else if (null === n || !i) return t.push(e), null; for (; t.length > 0;) { var l = t.shift(); this.parse(l, s, a) } return o = function (e, t, n) { if (null === t) return null; var i = dn(e, t)[t] || {}; return { seiNals: i.seiNals, logs: i.logs, timescale: n } }(e, n, i), o && o.logs && (r.logs = r.logs.concat(o.logs)), null !== o && o.seiNals ? (this.pushNals(o.seiNals), this.flushStream(), r) : r.logs.length ? { logs: r.logs, captions: [], captionStreams: [] } : null }, this.pushNals = function (t) { if (!this.isInitialized() || !t || 0 === t.length) return null; t.forEach((function (t) { e.push(t) })) }, this.flushStream = function () { if (!this.isInitialized()) return null; s ? e.partialFlush() : e.flush() }, this.clearParsedCaptions = function () { r.captions = [], r.captionStreams = {}, r.logs = [] }, this.resetCaptionStream = function () { if (!this.isInitialized()) return null; e.reset() }, this.clearAllCaptions = function () { this.clearParsedCaptions(), this.resetCaptionStream() }, this.reset = function () { t = [], n = null, i = null, r ? this.clearParsedCaptions() : r = { captions: [], captionStreams: {}, logs: [] }, this.resetCaptionStream() }, this.reset() }, pn = function (e) { for (var t = 0, n = String.fromCharCode(e[t]), i = ""; "\0" !== n;)i += n, t++, n = String.fromCharCode(e[t]); return i += n }, fn = z.getUint64, mn = function (e, t) { var n = "\0" !== t.scheme_id_uri, i = 0 === e && gn(t.presentation_time_delta) && n, r = 1 === e && gn(t.presentation_time) && n; return !(e > 1) && i || r }, gn = function (e) { return void 0 !== e || null !== e }, yn = { parseEmsgBox: function (e) { var t, n, i, r, s, a, o, l = 4, c = e[0]; if (0 === c) l += (t = pn(e.subarray(l))).length, l += (n = pn(e.subarray(l))).length, i = (u = new DataView(e.buffer)).getUint32(l), l += 4, s = u.getUint32(l), l += 4, a = u.getUint32(l), l += 4, o = u.getUint32(l), l += 4; else if (1 === c) { var u; i = (u = new DataView(e.buffer)).getUint32(l), l += 4, r = fn(e.subarray(l)), l += 8, a = u.getUint32(l), l += 4, o = u.getUint32(l), l += 4, l += (t = pn(e.subarray(l))).length, l += (n = pn(e.subarray(l))).length } var d = { scheme_id_uri: t, value: n, timescale: i || 1, presentation_time: r, presentation_time_delta: s, event_duration: a, id: o, message_data: new Uint8Array(e.subarray(l, e.byteLength)) }; return mn(c, d) ? d : void 0 }, scaleTime: function (e, t, n, i) { return e || 0 === e ? e / t : i + n / t } }, vn = qt, bn = function (e) { return ("00" + e.toString(16)).slice(-2) }, _n = $t, Tn = Gt, Sn = yn, wn = tn, xn = en, kn = Jt, En = z.getUint64, Cn = Ft, Pn = Fe.parseId3Frames; zt = function (e, t) { var n = _n(t, ["moof", "traf"]).reduce((function (t, n) { var i, r = _n(n, ["tfhd"])[0], s = vn(r[4] << 24 | r[5] << 16 | r[6] << 8 | r[7]), a = e[s] || 9e4, o = _n(n, ["tfdt"])[0], l = new DataView(o.buffer, o.byteOffset, o.byteLength); let c; return "bigint" === typeof (i = 1 === o[0] ? En(o.subarray(4, 12)) : l.getUint32(4)) ? c = i / Cn.BigInt(a) : "number" !== typeof i || isNaN(i) || (c = i / a), c < Number.MAX_SAFE_INTEGER && (c = Number(c)), c < t && (t = c), t }), 1 / 0); return "bigint" === typeof n || isFinite(n) ? n : 0 }, Vt = function (e) { var t = 0 === e[0] ? 12 : 20; return vn(e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) }, Ht = function (e) { var t = _n(e, ["moov", "trak"]), n = []; return t.forEach((function (e) { var t, i, r = {}, s = _n(e, ["tkhd"])[0]; s && (i = (t = new DataView(s.buffer, s.byteOffset, s.byteLength)).getUint8(0), r.id = 0 === i ? t.getUint32(12) : t.getUint32(20)); var a = _n(e, ["mdia", "hdlr"])[0]; if (a) { var o = Tn(a.subarray(8, 12)); r.type = "vide" === o ? "video" : "soun" === o ? "audio" : o } var l = _n(e, ["mdia", "minf", "stbl", "stsd"])[0]; if (l) { var c = l.subarray(8); r.codec = Tn(c.subarray(4, 8)); var u, d = _n(c, [r.codec])[0]; d && (/^[asm]vc[1-9]$/i.test(r.codec) ? (u = d.subarray(78), "avcC" === Tn(u.subarray(4, 8)) && u.length > 11 ? (r.codec += ".", r.codec += bn(u[9]), r.codec += bn(u[10]), r.codec += bn(u[11])) : r.codec = "avc1.4d400d") : /^mp4[a,v]$/i.test(r.codec) ? (u = d.subarray(28), "esds" === Tn(u.subarray(4, 8)) && u.length > 20 && 0 !== u[19] ? (r.codec += "." + bn(u[19]), r.codec += "." + bn(u[20] >>> 2 & 63).replace(/^0/, "")) : r.codec = "mp4a.40.2") : r.codec = r.codec.toLowerCase()) } var h = _n(e, ["mdia", "mdhd"])[0]; h && (r.timescale = Vt(h)), n.push(r) })), n }; var In = zt, Ln = Ht, On = ke, An = function (e) { var t = 31 & e[1]; return t <<= 8, t |= e[2] }, Nn = function (e) { return !!(64 & e[1]) }, jn = function (e) { var t = 0; return (48 & e[3]) >>> 4 > 1 && (t += e[4] + 1), t }, Dn = function (e) { switch (e) { case 5: return "slice_layer_without_partitioning_rbsp_idr"; case 6: return "sei_rbsp"; case 7: return "seq_parameter_set_rbsp"; case 8: return "pic_parameter_set_rbsp"; case 9: return "access_unit_delimiter_rbsp"; default: return null } }, Mn = { parseType: function (e, t) { var n = An(e); return 0 === n ? "pat" : n === t ? "pmt" : t ? "pes" : null }, parsePat: function (e) { var t = Nn(e), n = 4 + jn(e); return t && (n += e[n] + 1), (31 & e[n + 10]) << 8 | e[n + 11] }, parsePmt: function (e) { var t = {}, n = Nn(e), i = 4 + jn(e); if (n && (i += e[i] + 1), 1 & e[i + 5]) { var r; r = 3 + ((15 & e[i + 1]) << 8 | e[i + 2]) - 4; for (var s = 12 + ((15 & e[i + 10]) << 8 | e[i + 11]); s < r;) { var a = i + s; t[(31 & e[a + 1]) << 8 | e[a + 2]] = e[a], s += 5 + ((15 & e[a + 3]) << 8 | e[a + 4]) } return t } }, parsePayloadUnitStartIndicator: Nn, parsePesType: function (e, t) { switch (t[An(e)]) { case On.H264_STREAM_TYPE: return "video"; case On.ADTS_STREAM_TYPE: return "audio"; case On.METADATA_STREAM_TYPE: return "timed-metadata"; default: return null } }, parsePesTime: function (e) { if (!Nn(e)) return null; var t = 4 + jn(e); if (t >= e.byteLength) return null; var n, i = null; return 192 & (n = e[t + 7]) && ((i = {}).pts = (14 & e[t + 9]) << 27 | (255 & e[t + 10]) << 20 | (254 & e[t + 11]) << 12 | (255 & e[t + 12]) << 5 | (254 & e[t + 13]) >>> 3, i.pts *= 4, i.pts += (6 & e[t + 13]) >>> 1, i.dts = i.pts, 64 & n && (i.dts = (14 & e[t + 14]) << 27 | (255 & e[t + 15]) << 20 | (254 & e[t + 16]) << 12 | (255 & e[t + 17]) << 5 | (254 & e[t + 18]) >>> 3, i.dts *= 4, i.dts += (6 & e[t + 18]) >>> 1)), i }, videoPacketContainsKeyFrame: function (e) { for (var t = 4 + jn(e), n = e.subarray(t), i = 0, r = 0, s = !1; r < n.byteLength - 3; r++)if (1 === n[r + 2]) { i = r + 5; break } for (; i < n.byteLength;)switch (n[i]) { case 0: if (0 !== n[i - 1]) { i += 2; break } if (0 !== n[i - 2]) { i++; break } r + 3 !== i - 2 && "slice_layer_without_partitioning_rbsp_idr" === Dn(31 & n[r + 3]) && (s = !0); do { i++ } while (1 !== n[i] && i < n.length); r = i - 2, i += 3; break; case 1: if (0 !== n[i - 1] || 0 !== n[i - 2]) { i += 3; break } "slice_layer_without_partitioning_rbsp_idr" === Dn(31 & n[r + 3]) && (s = !0), r = i - 2, i += 3; break; default: i += 3 }return n = n.subarray(r), i -= r, r = 0, n && n.byteLength > 3 && "slice_layer_without_partitioning_rbsp_idr" === Dn(31 & n[r + 3]) && (s = !0), s } }, Rn = ke, Un = Oe.handleRollover, Bn = {}; Bn.ts = Mn, Bn.aac = gt; var Fn = re.ONE_SECOND_IN_TS, zn = 188, Hn = 71, Vn = function (e, t, n) { for (var i, r, s, a, o = 0, l = zn, c = !1; l <= e.byteLength;)if (e[o] !== Hn || e[l] !== Hn && l !== e.byteLength) o++, l++; else { if (i = e.subarray(o, l), "pes" === Bn.ts.parseType(i, t.pid)) r = Bn.ts.parsePesType(i, t.table), s = Bn.ts.parsePayloadUnitStartIndicator(i), "audio" === r && s && (a = Bn.ts.parsePesTime(i)) && (a.type = "audio", n.audio.push(a), c = !0); if (c) break; o += zn, l += zn } for (o = (l = e.byteLength) - zn, c = !1; o >= 0;)if (e[o] !== Hn || e[l] !== Hn && l !== e.byteLength) o--, l--; else { if (i = e.subarray(o, l), "pes" === Bn.ts.parseType(i, t.pid)) r = Bn.ts.parsePesType(i, t.table), s = Bn.ts.parsePayloadUnitStartIndicator(i), "audio" === r && s && (a = Bn.ts.parsePesTime(i)) && (a.type = "audio", n.audio.push(a), c = !0); if (c) break; o -= zn, l -= zn } }, Wn = function (e, t, n) { for (var i, r, s, a, o, l, c, u = 0, d = zn, h = !1, p = { data: [], size: 0 }; d < e.byteLength;)if (e[u] !== Hn || e[d] !== Hn) u++, d++; else { if (i = e.subarray(u, d), "pes" === Bn.ts.parseType(i, t.pid)) if (r = Bn.ts.parsePesType(i, t.table), s = Bn.ts.parsePayloadUnitStartIndicator(i), "video" === r && (s && !h && (a = Bn.ts.parsePesTime(i)) && (a.type = "video", n.video.push(a), h = !0), !n.firstKeyFrame)) { if (s && 0 !== p.size) { for (o = new Uint8Array(p.size), l = 0; p.data.length;)c = p.data.shift(), o.set(c, l), l += c.byteLength; if (Bn.ts.videoPacketContainsKeyFrame(o)) { var f = Bn.ts.parsePesTime(o); f ? (n.firstKeyFrame = f, n.firstKeyFrame.type = "video") : console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.") } p.size = 0 } p.data.push(i), p.size += i.byteLength } if (h && n.firstKeyFrame) break; u += zn, d += zn } for (u = (d = e.byteLength) - zn, h = !1; u >= 0;)if (e[u] !== Hn || e[d] !== Hn) u--, d--; else { if (i = e.subarray(u, d), "pes" === Bn.ts.parseType(i, t.pid)) r = Bn.ts.parsePesType(i, t.table), s = Bn.ts.parsePayloadUnitStartIndicator(i), "video" === r && s && (a = Bn.ts.parsePesTime(i)) && (a.type = "video", n.video.push(a), h = !0); if (h) break; u -= zn, d -= zn } }, qn = function (e) { var t = { pid: null, table: null }, n = {}; for (var i in function (e, t) { for (var n, i = 0, r = zn; r < e.byteLength;)if (e[i] !== Hn || e[r] !== Hn) i++, r++; else { switch (n = e.subarray(i, r), Bn.ts.parseType(n, t.pid)) { case "pat": t.pid = Bn.ts.parsePat(n); break; case "pmt": var s = Bn.ts.parsePmt(n); t.table = t.table || {}, Object.keys(s).forEach((function (e) { t.table[e] = s[e] })) }i += zn, r += zn } }(e, t), t.table) { if (t.table.hasOwnProperty(i)) switch (t.table[i]) { case Rn.H264_STREAM_TYPE: n.video = [], Wn(e, t, n), 0 === n.video.length && delete n.video; break; case Rn.ADTS_STREAM_TYPE: n.audio = [], Vn(e, t, n), 0 === n.audio.length && delete n.audio } } return n }, Gn = function (e, t) { var n; return n = Bn.aac.isLikelyAacData(e) ? function (e) { for (var t, n = !1, i = 0, r = null, s = null, a = 0, o = 0; e.length - o >= 3;) { switch (Bn.aac.parseType(e, o)) { case "timed-metadata": if (e.length - o < 10) { n = !0; break } if ((a = Bn.aac.parseId3TagSize(e, o)) > e.length) { n = !0; break } null === s && (t = e.subarray(o, o + a), s = Bn.aac.parseAacTimestamp(t)), o += a; break; case "audio": if (e.length - o < 7) { n = !0; break } if ((a = Bn.aac.parseAdtsSize(e, o)) > e.length) { n = !0; break } null === r && (t = e.subarray(o, o + a), r = Bn.aac.parseSampleRate(t)), i++, o += a; break; default: o++ }if (n) return null } if (null === r || null === s) return null; var l = Fn / r; return { audio: [{ type: "audio", dts: s, pts: s }, { type: "audio", dts: s + 1024 * i * l, pts: s + 1024 * i * l }] } }(e) : qn(e), n && (n.audio || n.video) ? (function (e, t) { if (e.audio && e.audio.length) { var n = t; ("undefined" === typeof n || isNaN(n)) && (n = e.audio[0].dts), e.audio.forEach((function (e) { e.dts = Un(e.dts, n), e.pts = Un(e.pts, n), e.dtsTime = e.dts / Fn, e.ptsTime = e.pts / Fn })) } if (e.video && e.video.length) { var i = t; if (("undefined" === typeof i || isNaN(i)) && (i = e.video[0].dts), e.video.forEach((function (e) { e.dts = Un(e.dts, i), e.pts = Un(e.pts, i), e.dtsTime = e.dts / Fn, e.ptsTime = e.pts / Fn })), e.firstKeyFrame) { var r = e.firstKeyFrame; r.dts = Un(r.dts, i), r.pts = Un(r.pts, i), r.dtsTime = r.dts / Fn, r.ptsTime = r.pts / Fn } } }(n, t), n) : null }; class Xn { constructor(e, t) { this.options = t || {}, this.self = e, this.init() } init() { this.transmuxer && this.transmuxer.dispose(), this.transmuxer = new Wt.Transmuxer(this.options), function (e, t) { t.on("data", (function (t) { const n = t.initSegment; t.initSegment = { data: n.buffer, byteOffset: n.byteOffset, byteLength: n.byteLength }; const i = t.data; t.data = i.buffer, e.postMessage({ action: "data", segment: t, byteOffset: i.byteOffset, byteLength: i.byteLength }, [t.data]) })), t.on("done", (function (t) { e.postMessage({ action: "done" }) })), t.on("gopInfo", (function (t) { e.postMessage({ action: "gopInfo", gopInfo: t }) })), t.on("videoSegmentTimingInfo", (function (t) { const n = { start: { decode: re.videoTsToSeconds(t.start.dts), presentation: re.videoTsToSeconds(t.start.pts) }, end: { decode: re.videoTsToSeconds(t.end.dts), presentation: re.videoTsToSeconds(t.end.pts) }, baseMediaDecodeTime: re.videoTsToSeconds(t.baseMediaDecodeTime) }; t.prependedContentDuration && (n.prependedContentDuration = re.videoTsToSeconds(t.prependedContentDuration)), e.postMessage({ action: "videoSegmentTimingInfo", videoSegmentTimingInfo: n }) })), t.on("audioSegmentTimingInfo", (function (t) { const n = { start: { decode: re.videoTsToSeconds(t.start.dts), presentation: re.videoTsToSeconds(t.start.pts) }, end: { decode: re.videoTsToSeconds(t.end.dts), presentation: re.videoTsToSeconds(t.end.pts) }, baseMediaDecodeTime: re.videoTsToSeconds(t.baseMediaDecodeTime) }; t.prependedContentDuration && (n.prependedContentDuration = re.videoTsToSeconds(t.prependedContentDuration)), e.postMessage({ action: "audioSegmentTimingInfo", audioSegmentTimingInfo: n }) })), t.on("id3Frame", (function (t) { e.postMessage({ action: "id3Frame", id3Frame: t }) })), t.on("caption", (function (t) { e.postMessage({ action: "caption", caption: t }) })), t.on("trackinfo", (function (t) { e.postMessage({ action: "trackinfo", trackInfo: t }) })), t.on("audioTimingInfo", (function (t) { e.postMessage({ action: "audioTimingInfo", audioTimingInfo: { start: re.videoTsToSeconds(t.start), end: re.videoTsToSeconds(t.end) } }) })), t.on("videoTimingInfo", (function (t) { e.postMessage({ action: "videoTimingInfo", videoTimingInfo: { start: re.videoTsToSeconds(t.start), end: re.videoTsToSeconds(t.end) } }) })), t.on("log", (function (t) { e.postMessage({ action: "log", log: t }) })) }(this.self, this.transmuxer) } pushMp4Captions(e) { this.captionParser || (this.captionParser = new hn, this.captionParser.init()); const t = new Uint8Array(e.data, e.byteOffset, e.byteLength), n = this.captionParser.parse(t, e.trackIds, e.timescales); this.self.postMessage({ action: "mp4Captions", captions: n && n.captions || [], logs: n && n.logs || [], data: t.buffer }, [t.buffer]) } probeMp4StartTime(e) { let { timescales: t, data: n } = e; const i = In(t, n); this.self.postMessage({ action: "probeMp4StartTime", startTime: i, data: n }, [n.buffer]) } probeMp4Tracks(e) { let { data: t } = e; const n = Ln(t); this.self.postMessage({ action: "probeMp4Tracks", tracks: n, data: t }, [t.buffer]) } probeTs(e) { let { data: t, baseStartTime: n } = e; const i = "number" !== typeof n || isNaN(n) ? void 0 : n * re.ONE_SECOND_IN_TS, r = Gn(t, i); let s = null; r && (s = { hasVideo: r.video && 2 === r.video.length || !1, hasAudio: r.audio && 2 === r.audio.length || !1 }, s.hasVideo && (s.videoStart = r.video[0].ptsTime), s.hasAudio && (s.audioStart = r.audio[0].ptsTime)), this.self.postMessage({ action: "probeTs", result: s, data: t }, [t.buffer]) } clearAllMp4Captions() { this.captionParser && this.captionParser.clearAllCaptions() } clearParsedMp4Captions() { this.captionParser && this.captionParser.clearParsedCaptions() } push(e) { const t = new Uint8Array(e.data, e.byteOffset, e.byteLength); this.transmuxer.push(t) } reset() { this.transmuxer.reset() } setTimestampOffset(e) { const t = e.timestampOffset || 0; this.transmuxer.setBaseMediaDecodeTime(Math.round(re.secondsToVideoTs(t))) } setAudioAppendStart(e) { this.transmuxer.setAudioAppendStart(Math.ceil(re.secondsToVideoTs(e.appendStart))) } setRemux(e) { this.transmuxer.setRemux(e.remux) } flush(e) { this.transmuxer.flush(), self.postMessage({ action: "done", type: "transmuxed" }) } endTimeline() { this.transmuxer.endTimeline(), self.postMessage({ action: "endedtimeline", type: "transmuxed" }) } alignGopsWith(e) { this.transmuxer.alignGopsWith(e.gopsToAlignWith.slice()) } } self.onmessage = function (e) { "init" === e.data.action && e.data.options ? this.messageHandlers = new Xn(self, e.data.options) : (this.messageHandlers || (this.messageHandlers = new Xn(self)), e.data && e.data.action && "init" !== e.data.action && this.messageHandlers[e.data.action] && this.messageHandlers[e.data.action](e.data)) } }))); var Ad = Pd(Od); const Nd = e => { const { transmuxer: t, bytes: n, audioAppendStart: i, gopsToAlignWith: r, remux: s, onData: a, onTrackInfo: o, onAudioTimingInfo: l, onVideoTimingInfo: c, onVideoSegmentTimingInfo: u, onAudioSegmentTimingInfo: d, onId3: h, onCaptions: p, onDone: f, onEndedTimeline: m, onTransmuxerLog: g, isEndOfTimeline: y } = e, v = { buffer: [] }; let b = y; if (t.onmessage = n => { t.currentTransmux === e && ("data" === n.data.action && ((e, t, n) => { const { type: i, initSegment: r, captions: s, captionStreams: a, metadata: o, videoFrameDtsTime: l, videoFramePtsTime: c } = e.data.segment; t.buffer.push({ captions: s, captionStreams: a, metadata: o }); const u = e.data.segment.boxes || { data: e.data.segment.data }, d = { type: i, data: new Uint8Array(u.data, u.data.byteOffset, u.data.byteLength), initSegment: new Uint8Array(r.data, r.byteOffset, r.byteLength) }; "undefined" !== typeof l && (d.videoFrameDtsTime = l), "undefined" !== typeof c && (d.videoFramePtsTime = c), n(d) })(n, v, a), "trackinfo" === n.data.action && o(n.data.trackInfo), "gopInfo" === n.data.action && ((e, t) => { t.gopInfo = e.data.gopInfo })(n, v), "audioTimingInfo" === n.data.action && l(n.data.audioTimingInfo), "videoTimingInfo" === n.data.action && c(n.data.videoTimingInfo), "videoSegmentTimingInfo" === n.data.action && u(n.data.videoSegmentTimingInfo), "audioSegmentTimingInfo" === n.data.action && d(n.data.audioSegmentTimingInfo), "id3Frame" === n.data.action && h([n.data.id3Frame], n.data.id3Frame.dispatchType), "caption" === n.data.action && p(n.data.caption), "endedtimeline" === n.data.action && (b = !1, m()), "log" === n.data.action && g(n.data.log), "transmuxed" === n.data.type && (b || (t.onmessage = null, (e => { let { transmuxedData: t, callback: n } = e; t.buffer = [], n(t) })({ transmuxedData: v, callback: f }), jd(t)))) }, i && t.postMessage({ action: "setAudioAppendStart", appendStart: i }), Array.isArray(r) && t.postMessage({ action: "alignGopsWith", gopsToAlignWith: r }), "undefined" !== typeof s && t.postMessage({ action: "setRemux", remux: s }), n.byteLength) { const e = n instanceof ArrayBuffer ? n : n.buffer, i = n instanceof ArrayBuffer ? 0 : n.byteOffset; t.postMessage({ action: "push", data: e, byteOffset: i, byteLength: n.byteLength }, [e]) } y && t.postMessage({ action: "endTimeline" }), t.postMessage({ action: "flush" }) }, jd = e => { e.currentTransmux = null, e.transmuxQueue.length && (e.currentTransmux = e.transmuxQueue.shift(), "function" === typeof e.currentTransmux ? e.currentTransmux() : Nd(e.currentTransmux)) }, Dd = (e, t) => { e.postMessage({ action: t }), jd(e) }, Md = (e, t) => { if (!t.currentTransmux) return t.currentTransmux = e, void Dd(t, e); t.transmuxQueue.push(Dd.bind(null, t, e)) }, Rd = e => { if (!e.transmuxer.currentTransmux) return e.transmuxer.currentTransmux = e, void Nd(e); e.transmuxer.transmuxQueue.push(e) }; var Ud = e => { Md("reset", e) }, Bd = e => { const t = new Ad; t.currentTransmux = null, t.transmuxQueue = []; const n = t.terminate; return t.terminate = () => (t.currentTransmux = null, t.transmuxQueue.length = 0, n.call(t)), t.postMessage({ action: "init", options: e }), t }; const Fd = function (e) { const t = e.transmuxer, n = e.endAction || e.action, i = e.callback, r = Zn({}, e, { endAction: null, transmuxer: null, callback: null }), s = r => { r.data.action === n && (t.removeEventListener("message", s), r.data.data && (r.data.data = new Uint8Array(r.data.data, e.byteOffset || 0, e.byteLength || r.data.data.byteLength), e.data && (e.data = r.data.data)), i(r.data)) }; if (t.addEventListener("message", s), e.data) { const n = e.data instanceof ArrayBuffer; r.byteOffset = n ? 0 : e.data.byteOffset, r.byteLength = e.data.byteLength; const i = [n ? e.data : e.data.buffer]; t.postMessage(r, i) } else t.postMessage(r) }, zd = 2, Hd = -101, Vd = -102, Wd = e => { e.forEach((e => { e.abort() })) }, qd = (e, t) => t.timedout ? { status: t.status, message: "HLS request timed-out at URL: " + t.uri, code: Hd, xhr: t } : t.aborted ? { status: t.status, message: "HLS request aborted at URL: " + t.uri, code: Vd, xhr: t } : e ? { status: t.status, message: "HLS request errored at URL: " + t.uri, code: zd, xhr: t } : "arraybuffer" === t.responseType && 0 === t.response.byteLength ? { status: t.status, message: "Empty HLS response at URL: " + t.uri, code: zd, xhr: t } : null, Gd = (e, t, n) => (i, r) => { const s = r.response, a = qd(i, r); if (a) return n(a, e); if (16 !== s.byteLength) return n({ status: r.status, message: "Invalid HLS key at URL: " + r.uri, code: zd, xhr: r }, e); const o = new DataView(s), l = new Uint32Array([o.getUint32(0), o.getUint32(4), o.getUint32(8), o.getUint32(12)]); for (let e = 0; e < t.length; e++)t[e].bytes = l; return n(null, e) }, Xd = (e, t) => { const n = rs(e.map.bytes); if ("mp4" !== n) { const i = e.map.resolvedUri || e.map.uri; return t({ internal: !0, message: "Found unsupported ".concat(n || "unknown", " container for initialization segment at URL: ").concat(i), code: zd }) } Fd({ action: "probeMp4Tracks", data: e.map.bytes, transmuxer: e.transmuxer, callback: n => { let { tracks: i, data: r } = n; return e.map.bytes = r, i.forEach((function (t) { e.map.tracks = e.map.tracks || {}, e.map.tracks[t.type] || (e.map.tracks[t.type] = t, "number" === typeof t.id && t.timescale && (e.map.timescales = e.map.timescales || {}, e.map.timescales[t.id] = t.timescale)) })), t(null) } }) }, Kd = e => { let { segment: t, finishProcessingFn: n, responseType: i } = e; return (e, r) => { const s = qd(e, r); if (s) return n(s, t); const a = "arraybuffer" !== i && r.responseText ? (e => { const t = new Uint8Array(new ArrayBuffer(e.length)); for (let n = 0; n < e.length; n++)t[n] = e.charCodeAt(n); return t.buffer })(r.responseText.substring(t.lastReachedChar || 0)) : r.response; return t.stats = (e => ({ bandwidth: e.bandwidth, bytesReceived: e.bytesReceived || 0, roundTripTime: e.roundTripTime || 0 }))(r), t.key ? t.encryptedBytes = new Uint8Array(a) : t.bytes = new Uint8Array(a), n(null, t) } }, $d = e => { let { segment: t, bytes: n, trackInfoFn: i, timingInfoFn: r, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: l, isEndOfTimeline: c, endedTimelineFn: u, dataFn: d, doneFn: h, onTransmuxerLog: p } = e; const f = t.map && t.map.tracks || {}, m = Boolean(f.audio && f.video); let g = r.bind(null, t, "audio", "start"); const y = r.bind(null, t, "audio", "end"); let v = r.bind(null, t, "video", "start"); const b = r.bind(null, t, "video", "end"); Fd({ action: "probeTs", transmuxer: t.transmuxer, data: n, baseStartTime: t.baseStartTime, callback: e => { t.bytes = n = e.data; const r = e.result; r && (i(t, { hasAudio: r.hasAudio, hasVideo: r.hasVideo, isMuxed: m }), i = null, r.hasAudio && !m && g(r.audioStart), r.hasVideo && v(r.videoStart), g = null, v = null), Rd({ bytes: n, transmuxer: t.transmuxer, audioAppendStart: t.audioAppendStart, gopsToAlignWith: t.gopsToAlignWith, remux: m, onData: e => { e.type = "combined" === e.type ? "video" : e.type, d(t, e) }, onTrackInfo: e => { i && (m && (e.isMuxed = !0), i(t, e)) }, onAudioTimingInfo: e => { g && "undefined" !== typeof e.start && (g(e.start), g = null), y && "undefined" !== typeof e.end && y(e.end) }, onVideoTimingInfo: e => { v && "undefined" !== typeof e.start && (v(e.start), v = null), b && "undefined" !== typeof e.end && b(e.end) }, onVideoSegmentTimingInfo: e => { s(e) }, onAudioSegmentTimingInfo: e => { a(e) }, onId3: (e, n) => { o(t, e, n) }, onCaptions: e => { l(t, [e]) }, isEndOfTimeline: c, onEndedTimeline: () => { u() }, onTransmuxerLog: p, onDone: e => { h && (e.type = "combined" === e.type ? "video" : e.type, h(null, t, e)) } }) } }) }, Yd = e => { let { segment: t, bytes: n, trackInfoFn: i, timingInfoFn: r, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: l, isEndOfTimeline: c, endedTimelineFn: u, dataFn: d, doneFn: h, onTransmuxerLog: p } = e, f = new Uint8Array(n); if (function (e) { return Hr(e, ["moof"]).length > 0 }(f)) { t.isFmp4 = !0; const { tracks: e } = t.map, s = { isFmp4: !0, hasVideo: !!e.video, hasAudio: !!e.audio }; e.audio && e.audio.codec && "enca" !== e.audio.codec && (s.audioCodec = e.audio.codec), e.video && e.video.codec && "encv" !== e.video.codec && (s.videoCodec = e.video.codec), e.video && e.audio && (s.isMuxed = !0), i(t, s); const a = e => { d(t, { data: f, type: s.hasAudio && !s.isMuxed ? "audio" : "video" }), e && e.length && l(t, e), h(null, t, {}) }; Fd({ action: "probeMp4StartTime", timescales: t.map.timescales, data: f, transmuxer: t.transmuxer, callback: i => { let { data: o, startTime: l } = i; n = o.buffer, t.bytes = f = o, s.hasAudio && !s.isMuxed && r(t, "audio", "start", l), s.hasVideo && r(t, "video", "start", l), e.video && o.byteLength && t.transmuxer ? Fd({ action: "pushMp4Captions", endAction: "mp4Captions", transmuxer: t.transmuxer, data: f, timescales: t.map.timescales, trackIds: [e.video.id], callback: e => { n = e.data.buffer, t.bytes = f = e.data, e.logs.forEach((function (e) { p(mu(e, { stream: "mp4CaptionParser" })) })), a(e.captions) } }) : a() } }) } else if (t.transmuxer) { if ("undefined" === typeof t.container && (t.container = rs(f)), "ts" !== t.container && "aac" !== t.container) return i(t, { hasAudio: !1, hasVideo: !1 }), void h(null, t, {}); $d({ segment: t, bytes: n, trackInfoFn: i, timingInfoFn: r, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: l, isEndOfTimeline: c, endedTimelineFn: u, dataFn: d, doneFn: h, onTransmuxerLog: p }) } else h(null, t, {}) }, Qd = function (e, t) { let { id: n, key: i, encryptedBytes: r, decryptionWorker: s } = e; const a = e => { if (e.data.source === n) { s.removeEventListener("message", a); const n = e.data.decrypted; t(new Uint8Array(n.bytes, n.byteOffset, n.byteLength)) } }; let o; s.addEventListener("message", a), o = i.bytes.slice ? i.bytes.slice() : new Uint32Array(Array.prototype.slice.call(i.bytes)), s.postMessage(dd({ source: n, encrypted: r, key: o, iv: i.iv }), [r.buffer, o.buffer]) }, Jd = e => { let { activeXhrs: t, decryptionWorker: n, trackInfoFn: i, timingInfoFn: r, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: l, isEndOfTimeline: c, endedTimelineFn: u, dataFn: d, doneFn: h, onTransmuxerLog: p } = e, f = 0, m = !1; return (e, g) => { if (!m) { if (e) return m = !0, Wd(t), h(e, g); if (f += 1, f === t.length) { const e = function () { if (g.encryptedBytes) return (e => { let { decryptionWorker: t, segment: n, trackInfoFn: i, timingInfoFn: r, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: l, isEndOfTimeline: c, endedTimelineFn: u, dataFn: d, doneFn: h, onTransmuxerLog: p } = e; Qd({ id: n.requestId, key: n.key, encryptedBytes: n.encryptedBytes, decryptionWorker: t }, (e => { n.bytes = e, Yd({ segment: n, bytes: n.bytes, trackInfoFn: i, timingInfoFn: r, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: l, isEndOfTimeline: c, endedTimelineFn: u, dataFn: d, doneFn: h, onTransmuxerLog: p }) })) })({ decryptionWorker: n, segment: g, trackInfoFn: i, timingInfoFn: r, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: l, isEndOfTimeline: c, endedTimelineFn: u, dataFn: d, doneFn: h, onTransmuxerLog: p }); Yd({ segment: g, bytes: g.bytes, trackInfoFn: i, timingInfoFn: r, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: l, isEndOfTimeline: c, endedTimelineFn: u, dataFn: d, doneFn: h, onTransmuxerLog: p }) }; if (g.endOfAllRequests = Date.now(), g.map && g.map.encryptedBytes && !g.map.bytes) return Qd({ decryptionWorker: n, id: g.requestId + "-init", encryptedBytes: g.map.encryptedBytes, key: g.map.key }, (n => { g.map.bytes = n, Xd(g, (n => { if (n) return Wd(t), h(n, g); e() })) })); e() } } } }, Zd = e => { let { segment: t, progressFn: n, trackInfoFn: i, timingInfoFn: r, videoSegmentTimingInfoFn: s, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: l, isEndOfTimeline: c, endedTimelineFn: u, dataFn: d } = e; return e => { if (!e.target.aborted) return t.stats = mu(t.stats, (e => { const t = e.target, n = { bandwidth: 1 / 0, bytesReceived: 0, roundTripTime: Date.now() - t.requestTime || 0 }; return n.bytesReceived = e.loaded, n.bandwidth = Math.floor(n.bytesReceived / n.roundTripTime * 8 * 1e3), n })(e)), !t.stats.firstBytesReceivedAt && t.stats.bytesReceived && (t.stats.firstBytesReceivedAt = Date.now()), n(e, t) } }, eh = e => { let { xhr: t, xhrOptions: n, decryptionWorker: i, segment: r, abortFn: s, progressFn: a, trackInfoFn: o, timingInfoFn: l, videoSegmentTimingInfoFn: c, audioSegmentTimingInfoFn: u, id3Fn: d, captionsFn: h, isEndOfTimeline: p, endedTimelineFn: f, dataFn: m, doneFn: g, onTransmuxerLog: y } = e; const v = [], b = Jd({ activeXhrs: v, decryptionWorker: i, trackInfoFn: o, timingInfoFn: l, videoSegmentTimingInfoFn: c, audioSegmentTimingInfoFn: u, id3Fn: d, captionsFn: h, isEndOfTimeline: p, endedTimelineFn: f, dataFn: m, doneFn: g, onTransmuxerLog: y }); if (r.key && !r.key.bytes) { const e = [r.key]; r.map && !r.map.bytes && r.map.key && r.map.key.resolvedUri === r.key.resolvedUri && e.push(r.map.key); const i = t(mu(n, { uri: r.key.resolvedUri, responseType: "arraybuffer" }), Gd(r, e, b)); v.push(i) } if (r.map && !r.map.bytes) { if (r.map.key && (!r.key || r.key.resolvedUri !== r.map.key.resolvedUri)) { const e = t(mu(n, { uri: r.map.key.resolvedUri, responseType: "arraybuffer" }), Gd(r, [r.map.key], b)); v.push(e) } const e = mu(n, { uri: r.map.resolvedUri, responseType: "arraybuffer", headers: od(r.map) }), i = (e => { let { segment: t, finishProcessingFn: n } = e; return (e, i) => { const r = qd(e, i); if (r) return n(r, t); const s = new Uint8Array(i.response); if (t.map.key) return t.map.encryptedBytes = s, n(null, t); t.map.bytes = s, Xd(t, (function (e) { if (e) return e.xhr = i, e.status = i.status, n(e, t); n(null, t) })) } })({ segment: r, finishProcessingFn: b }), s = t(e, i); v.push(s) } const _ = mu(n, { uri: r.part && r.part.resolvedUri || r.resolvedUri, responseType: "arraybuffer", headers: od(r) }), T = t(_, Kd({ segment: r, finishProcessingFn: b, responseType: _.responseType })); T.addEventListener("progress", Zd({ segment: r, progressFn: a, trackInfoFn: o, timingInfoFn: l, videoSegmentTimingInfoFn: c, audioSegmentTimingInfoFn: u, id3Fn: d, captionsFn: h, isEndOfTimeline: p, endedTimelineFn: f, dataFn: m })), v.push(T); const S = {}; return v.forEach((e => { e.addEventListener("loadend", (e => { let { loadendState: t, abortFn: n } = e; return e => { e.target.aborted && n && !t.calledAbortFn && (n(), t.calledAbortFn = !0) } })({ loadendState: S, abortFn: s })) })), () => Wd(v) }, th = fu("CodecUtils"), nh = (e, t) => { const n = t.attributes || {}; return e && e.mediaGroups && e.mediaGroups.AUDIO && n.AUDIO && e.mediaGroups.AUDIO[n.AUDIO] }, ih = function (e) { const t = {}; return e.forEach((e => { let { mediaType: n, type: i, details: r } = e; t[n] = t[n] || [], t[n].push(pi("".concat(i).concat(r))) })), Object.keys(t).forEach((function (e) { if (t[e].length > 1) return th("multiple ".concat(e, " codecs found as attributes: ").concat(t[e].join(", "), ". Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.")), void (t[e] = null); t[e] = t[e][0] })), t }, rh = function (e) { let t = 0; return e.audio && t++, e.video && t++, t }, sh = function (e, t) { const n = t.attributes || {}, i = ih(function (e) { const t = e.attributes || {}; if (t.CODECS) return fi(t.CODECS) }(t) || []); if (nh(e, t) && !i.audio && !((e, t) => { if (!nh(e, t)) return !0; const n = t.attributes || {}, i = e.mediaGroups.AUDIO[n.AUDIO]; for (const r in i) if (!i[r].uri && !i[r].playlists) return !0; return !1 })(e, t)) { const t = ih(function (e, t) { if (!e.mediaGroups.AUDIO || !t) return null; var n = e.mediaGroups.AUDIO[t]; if (!n) return null; for (var i in n) { var r = n[i]; if (r.default && r.playlists) return fi(r.playlists[0].attributes.CODECS) } return null }(e, n.AUDIO) || []); t.audio && (i.audio = t.audio) } return i }, ah = fu("PlaylistSelector"), oh = function (e) { if (!e || !e.playlist) return; const t = e.playlist; return JSON.stringify({ id: t.id, bandwidth: e.bandwidth, width: e.width, height: e.height, codecs: t.attributes && t.attributes.CODECS || "" }) }, lh = function (e, t) { if (!e) return ""; const n = Un().getComputedStyle(e); return n ? n[t] : "" }, ch = function (e, t) { const n = e.slice(); e.sort((function (e, i) { const r = t(e, i); return 0 === r ? n.indexOf(e) - n.indexOf(i) : r })) }, uh = function (e, t) { let n, i; return e.attributes.BANDWIDTH && (n = e.attributes.BANDWIDTH), n = n || Un().Number.MAX_VALUE, t.attributes.BANDWIDTH && (i = t.attributes.BANDWIDTH), i = i || Un().Number.MAX_VALUE, n - i }; let dh = function (e, t, n, i, r, s) { if (!e) return; const a = { bandwidth: t, width: n, height: i, limitRenditionByPlayerDimensions: r }; let o = e.playlists; Vu.isAudioOnly(e) && (o = s.getAudioTrackPlaylists_(), a.audioOnly = !0); let l = o.map((e => { let t; const n = e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.width, i = e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.height; return t = e.attributes && e.attributes.BANDWIDTH, t = t || Un().Number.MAX_VALUE, { bandwidth: t, width: n, height: i, playlist: e } })); ch(l, ((e, t) => e.bandwidth - t.bandwidth)), l = l.filter((e => !Vu.isIncompatible(e.playlist))); let c = l.filter((e => Vu.isEnabled(e.playlist))); c.length || (c = l.filter((e => !Vu.isDisabled(e.playlist)))); const u = c.filter((e => e.bandwidth * Ed.BANDWIDTH_VARIANCE < t)); let d = u[u.length - 1]; const h = u.filter((e => e.bandwidth === d.bandwidth))[0]; if (!1 === r) { const e = h || c[0] || l[0]; if (e && e.playlist) { let t = "sortedPlaylistReps"; return h && (t = "bandwidthBestRep"), c[0] && (t = "enabledPlaylistReps"), ah("choosing ".concat(oh(e), " using ").concat(t, " with options"), a), e.playlist } return ah("could not choose a playlist with options", a), null } const p = u.filter((e => e.width && e.height)); ch(p, ((e, t) => e.width - t.width)); const f = p.filter((e => e.width === n && e.height === i)); d = f[f.length - 1]; const m = f.filter((e => e.bandwidth === d.bandwidth))[0]; let g, y, v, b; if (m || (g = p.filter((e => e.width > n || e.height > i)), y = g.filter((e => e.width === g[0].width && e.height === g[0].height)), d = y[y.length - 1], v = y.filter((e => e.bandwidth === d.bandwidth))[0]), s.leastPixelDiffSelector) { const e = p.map((e => (e.pixelDiff = Math.abs(e.width - n) + Math.abs(e.height - i), e))); ch(e, ((e, t) => e.pixelDiff === t.pixelDiff ? t.bandwidth - e.bandwidth : e.pixelDiff - t.pixelDiff)), b = e[0] } const _ = b || v || m || h || c[0] || l[0]; if (_ && _.playlist) { let e = "sortedPlaylistReps"; return b ? e = "leastPixelDiffRep" : v ? e = "resolutionPlusOneRep" : m ? e = "resolutionBestRep" : h ? e = "bandwidthBestRep" : c[0] && (e = "enabledPlaylistReps"), ah("choosing ".concat(oh(_), " using ").concat(e, " with options"), a), _.playlist } return ah("could not choose a playlist with options", a), null }; const hh = function () { const e = this.useDevicePixelRatio && Un().devicePixelRatio || 1; return dh(this.playlists.main, this.systemBandwidth, parseInt(lh(this.tech_.el(), "width"), 10) * e, parseInt(lh(this.tech_.el(), "height"), 10) * e, this.limitRenditionByPlayerDimensions, this.playlistController_) }, ph = e => { let { inbandTextTracks: t, metadataArray: n, timestampOffset: i, videoDuration: r } = e; if (!n) return; const s = Un().WebKitDataCue || Un().VTTCue, a = t.metadataTrack_; if (!a) return; if (n.forEach((e => { const t = e.cueTime + i; !("number" !== typeof t || Un().isNaN(t) || t < 0) && t < 1 / 0 && e.frames.forEach((e => { const n = new s(t, t, e.value || e.url || e.data || ""); n.frame = e, n.value = e, function (e) { Object.defineProperties(e.frame, { id: { get: () => (au.log.warn("cue.frame.id is deprecated. Use cue.value.key instead."), e.value.key) }, value: { get: () => (au.log.warn("cue.frame.value is deprecated. Use cue.value.data instead."), e.value.data) }, privateData: { get: () => (au.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead."), e.value.data) } }) }(n), a.addCue(n) })) })), !a.cues || !a.cues.length) return; const o = a.cues, l = []; for (let d = 0; d < o.length; d++)o[d] && l.push(o[d]); const c = l.reduce(((e, t) => { const n = e[t.startTime] || []; return n.push(t), e[t.startTime] = n, e }), {}), u = Object.keys(c).sort(((e, t) => Number(e) - Number(t))); u.forEach(((e, t) => { const n = c[e], i = Number(u[t + 1]) || r; n.forEach((e => { e.endTime = i })) })) }, fh = function (e, t, n) { let i, r; if (n && n.cues) for (i = n.cues.length; i--;)r = n.cues[i], r.startTime >= e && r.endTime <= t && n.removeCue(r) }, mh = e => "number" === typeof e && isFinite(e), gh = 1 / 60, yh = e => { const { startOfSegment: t, duration: n, segment: i, part: r, playlist: { mediaSequence: s, id: a, segments: o = [] }, mediaIndex: l, partIndex: c, timeline: u } = e, d = o.length - 1; let h = "mediaIndex/partIndex increment"; e.getMediaInfoForTime ? h = "getMediaInfoForTime (".concat(e.getMediaInfoForTime, ")") : e.isSyncRequest && (h = "getSyncSegmentCandidate (isSyncRequest)"), e.independent && (h += " with independent ".concat(e.independent)); const p = "number" === typeof c, f = e.segment.uri ? "segment" : "pre-segment", m = p ? Iu({ preloadSegment: i }) - 1 : 0; return "".concat(f, " [").concat(s + l, "/").concat(s + d, "]") + (p ? " part [".concat(c, "/").concat(m, "]") : "") + " segment start/end [".concat(i.start, " => ").concat(i.end, "]") + (p ? " part start/end [".concat(r.start, " => ").concat(r.end, "]") : "") + " startOfSegment [".concat(t, "]") + " duration [".concat(n, "]") + " timeline [".concat(u, "]") + " selected by [".concat(h, "]") + " playlist [".concat(a, "]") }, vh = e => "".concat(e, "TimingInfo"), bh = e => { let { timelineChangeController: t, currentTimeline: n, segmentTimeline: i, loaderType: r, audioDisabled: s } = e; if (n === i) return !1; if ("audio" === r) { const e = t.lastTimelineChange({ type: "main" }); return !e || e.to !== i } if ("main" === r && s) { const e = t.pendingTimelineChange({ type: "audio" }); return !e || e.to !== i } return !1 }, _h = e => { let { segmentDuration: t, maxDuration: n } = e; return !!t && Math.round(t) > n + yu }, Th = (e, t) => { if ("hls" !== t) return null; const n = (e => { let t = 0; return ["video", "audio"].forEach((function (n) { const i = e["".concat(n, "TimingInfo")]; if (!i) return; const { start: r, end: s } = i; let a; "bigint" === typeof r || "bigint" === typeof s ? a = Un().BigInt(s) - Un().BigInt(r) : "number" === typeof r && "number" === typeof s && (a = s - r), "undefined" !== typeof a && a > t && (t = a) })), "bigint" === typeof t && t < Number.MAX_SAFE_INTEGER && (t = Number(t)), t })({ audioTimingInfo: e.audioTimingInfo, videoTimingInfo: e.videoTimingInfo }); if (!n) return null; const i = e.playlist.targetDuration, r = _h({ segmentDuration: n, maxDuration: 2 * i }), s = _h({ segmentDuration: n, maxDuration: i }), a = "Segment with index ".concat(e.mediaIndex, " ") + "from playlist ".concat(e.playlist.id, " ") + "has a duration of ".concat(n, " ") + "when the reported duration is ".concat(e.duration, " ") + "and the target duration is ".concat(i, ". ") + "For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1"; return r || s ? { severity: r ? "warn" : "info", message: a } : null }; class Sh extends au.EventTarget { constructor(e) { if (super(), !e) throw new TypeError("Initialization settings are required"); if ("function" !== typeof e.currentTime) throw new TypeError("No currentTime getter specified"); if (!e.mediaSource) throw new TypeError("No MediaSource specified"); this.bandwidth = e.bandwidth, this.throughput = { rate: 0, count: 0 }, this.roundTrip = NaN, this.resetStats_(), this.mediaIndex = null, this.partIndex = null, this.hasPlayed_ = e.hasPlayed, this.currentTime_ = e.currentTime, this.seekable_ = e.seekable, this.seeking_ = e.seeking, this.duration_ = e.duration, this.mediaSource_ = e.mediaSource, this.vhs_ = e.vhs, this.loaderType_ = e.loaderType, this.currentMediaInfo_ = void 0, this.startingMediaInfo_ = void 0, this.segmentMetadataTrack_ = e.segmentMetadataTrack, this.goalBufferLength_ = e.goalBufferLength, this.sourceType_ = e.sourceType, this.sourceUpdater_ = e.sourceUpdater, this.inbandTextTracks_ = e.inbandTextTracks, this.state_ = "INIT", this.timelineChangeController_ = e.timelineChangeController, this.shouldSaveSegmentTimingInfo_ = !0, this.parse708captions_ = e.parse708captions, this.useDtsForTimestampOffset_ = e.useDtsForTimestampOffset, this.captionServices_ = e.captionServices, this.exactManifestTimings = e.exactManifestTimings, this.checkBufferTimeout_ = null, this.error_ = void 0, this.currentTimeline_ = -1, this.pendingSegment_ = null, this.xhrOptions_ = null, this.pendingSegments_ = [], this.audioDisabled_ = !1, this.isPendingTimestampOffset_ = !1, this.gopBuffer_ = [], this.timeMapping_ = 0, this.safeAppend_ = au.browser.IE_VERSION >= 11, this.appendInitSegment_ = { audio: !0, video: !0 }, this.playlistOfLastInitSegment_ = { audio: null, video: null }, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_ = { id3: [], caption: [] }, this.waitingOnRemove_ = !1, this.quotaExceededErrorRetryTimeout_ = null, this.activeInitSegmentId_ = null, this.initSegments_ = {}, this.cacheEncryptionKeys_ = e.cacheEncryptionKeys, this.keyCache_ = {}, this.decrypter_ = e.decrypter, this.syncController_ = e.syncController, this.syncPoint_ = { segmentIndex: 0, time: 0 }, this.transmuxer_ = this.createTransmuxer_(), this.triggerSyncInfoUpdate_ = () => this.trigger("syncinfoupdate"), this.syncController_.on("syncinfoupdate", this.triggerSyncInfoUpdate_), this.mediaSource_.addEventListener("sourceopen", (() => { this.isEndOfStream_() || (this.ended_ = !1) })), this.fetchAtBuffer_ = !1, this.logger_ = fu("SegmentLoader[".concat(this.loaderType_, "]")), Object.defineProperty(this, "state", { get() { return this.state_ }, set(e) { e !== this.state_ && (this.logger_("".concat(this.state_, " -> ").concat(e)), this.state_ = e, this.trigger("statechange")) } }), this.sourceUpdater_.on("ready", (() => { this.hasEnoughInfoToAppend_() && this.processCallQueue_() })), "main" === this.loaderType_ && this.timelineChangeController_.on("pendingtimelinechange", (() => { this.hasEnoughInfoToAppend_() && this.processCallQueue_() })), "audio" === this.loaderType_ && this.timelineChangeController_.on("timelinechange", (() => { this.hasEnoughInfoToLoad_() && this.processLoadQueue_(), this.hasEnoughInfoToAppend_() && this.processCallQueue_() })) } createTransmuxer_() { return Bd({ remux: !1, alignGopsAtEnd: this.safeAppend_, keepOriginalTimestamps: !0, parse708captions: this.parse708captions_, captionServices: this.captionServices_ }) } resetStats_() { this.mediaBytesTransferred = 0, this.mediaRequests = 0, this.mediaRequestsAborted = 0, this.mediaRequestsTimedout = 0, this.mediaRequestsErrored = 0, this.mediaTransferDuration = 0, this.mediaSecondsLoaded = 0, this.mediaAppends = 0 } dispose() { this.trigger("dispose"), this.state = "DISPOSED", this.pause(), this.abort_(), this.transmuxer_ && this.transmuxer_.terminate(), this.resetStats_(), this.checkBufferTimeout_ && Un().clearTimeout(this.checkBufferTimeout_), this.syncController_ && this.triggerSyncInfoUpdate_ && this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_), this.off() } setAudio(e) { this.audioDisabled_ = !e, e ? this.appendInitSegment_.audio = !0 : this.sourceUpdater_.removeAudio(0, this.duration_()) } abort() { "WAITING" === this.state ? (this.abort_(), this.state = "READY", this.paused() || this.monitorBuffer_()) : this.pendingSegment_ && (this.pendingSegment_ = null) } abort_() { this.pendingSegment_ && this.pendingSegment_.abortRequests && this.pendingSegment_.abortRequests(), this.pendingSegment_ = null, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_), this.waitingOnRemove_ = !1, Un().clearTimeout(this.quotaExceededErrorRetryTimeout_), this.quotaExceededErrorRetryTimeout_ = null } checkForAbort_(e) { return "APPENDING" !== this.state || this.pendingSegment_ ? !this.pendingSegment_ || this.pendingSegment_.requestId !== e : (this.state = "READY", !0) } error(e) { return "undefined" !== typeof e && (this.logger_("error occurred:", e), this.error_ = e), this.pendingSegment_ = null, this.error_ } endOfStream() { this.ended_ = !0, this.transmuxer_ && Ud(this.transmuxer_), this.gopBuffer_.length = 0, this.pause(), this.trigger("ended") } buffered_() { const e = this.getMediaInfo_(); if (!this.sourceUpdater_ || !e) return gu(); if ("main" === this.loaderType_) { const { hasAudio: t, hasVideo: n, isMuxed: i } = e; if (n && t && !this.audioDisabled_ && !i) return this.sourceUpdater_.buffered(); if (n) return this.sourceUpdater_.videoBuffered() } return this.sourceUpdater_.audioBuffered() } initSegmentForMap(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (!e) return null; const n = hd(e); let i = this.initSegments_[n]; return t && !i && e.bytes && (this.initSegments_[n] = i = { resolvedUri: e.resolvedUri, byterange: e.byterange, bytes: e.bytes, tracks: e.tracks, timescales: e.timescales }), i || e } segmentKey(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (!e) return null; const n = pd(e); let i = this.keyCache_[n]; this.cacheEncryptionKeys_ && t && !i && e.bytes && (this.keyCache_[n] = i = { resolvedUri: e.resolvedUri, bytes: e.bytes }); const r = { resolvedUri: (i || e).resolvedUri }; return i && (r.bytes = i.bytes), r } couldBeginLoading_() { return this.playlist_ && !this.paused() } load() { if (this.monitorBuffer_(), this.playlist_) return "INIT" === this.state && this.couldBeginLoading_() ? this.init_() : void (!this.couldBeginLoading_() || "READY" !== this.state && "INIT" !== this.state || (this.state = "READY")) } init_() { return this.state = "READY", this.resetEverything(), this.monitorBuffer_() } playlist(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!e) return; const n = this.playlist_, i = this.pendingSegment_; this.playlist_ = e, this.xhrOptions_ = t, "INIT" === this.state && (e.syncInfo = { mediaSequence: e.mediaSequence, time: 0 }, "main" === this.loaderType_ && this.syncController_.setDateTimeMappingForStart(e)); let r = null; if (n && (n.id ? r = n.id : n.uri && (r = n.uri)), this.logger_("playlist update [".concat(r, " => ").concat(e.id || e.uri, "]")), this.trigger("syncinfoupdate"), "INIT" === this.state && this.couldBeginLoading_()) return this.init_(); if (!n || n.uri !== e.uri) return null !== this.mediaIndex && (e.endList ? this.resyncLoader() : this.resetLoader()), this.currentMediaInfo_ = void 0, void this.trigger("playlistupdate"); const s = e.mediaSequence - n.mediaSequence; if (this.logger_("live window shift [".concat(s, "]")), null !== this.mediaIndex) if (this.mediaIndex -= s, this.mediaIndex < 0) this.mediaIndex = null, this.partIndex = null; else { const e = this.playlist_.segments[this.mediaIndex]; if (this.partIndex && (!e.parts || !e.parts.length || !e.parts[this.partIndex])) { const e = this.mediaIndex; this.logger_("currently processing part (index ".concat(this.partIndex, ") no longer exists.")), this.resetLoader(), this.mediaIndex = e } } i && (i.mediaIndex -= s, i.mediaIndex < 0 ? (i.mediaIndex = null, i.partIndex = null) : (i.mediaIndex >= 0 && (i.segment = e.segments[i.mediaIndex]), i.partIndex >= 0 && i.segment.parts && (i.part = i.segment.parts[i.partIndex]))), this.syncController_.saveExpiredSegmentInfo(n, e) } pause() { this.checkBufferTimeout_ && (Un().clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = null) } paused() { return null === this.checkBufferTimeout_ } resetEverything(e) { this.ended_ = !1, this.activeInitSegmentId_ = null, this.appendInitSegment_ = { audio: !0, video: !0 }, this.resetLoader(), this.remove(0, 1 / 0, e), this.transmuxer_ && (this.transmuxer_.postMessage({ action: "clearAllMp4Captions" }), this.transmuxer_.postMessage({ action: "reset" })) } resetLoader() { this.fetchAtBuffer_ = !1, this.resyncLoader() } resyncLoader() { this.transmuxer_ && Ud(this.transmuxer_), this.mediaIndex = null, this.partIndex = null, this.syncPoint_ = null, this.isPendingTimestampOffset_ = !1, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.abort(), this.transmuxer_ && this.transmuxer_.postMessage({ action: "clearParsedMp4Captions" }) } remove(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : () => { }, i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; if (t === 1 / 0 && (t = this.duration_()), t <= e) return void this.logger_("skipping remove because end ${end} is <= start ${start}"); if (!this.sourceUpdater_ || !this.getMediaInfo_()) return void this.logger_("skipping remove because no source updater or starting media info"); let r = 1; const s = () => { r--, 0 === r && n() }; !i && this.audioDisabled_ || (r++, this.sourceUpdater_.removeAudio(e, t, s)), (i || "main" === this.loaderType_) && (this.gopBuffer_ = ((e, t, n, i) => { const r = Math.ceil((t - i) * ss.ONE_SECOND_IN_TS), s = Math.ceil((n - i) * ss.ONE_SECOND_IN_TS), a = e.slice(); let o = e.length; for (; o-- && !(e[o].pts <= s);); if (-1 === o) return a; let l = o + 1; for (; l-- && !(e[l].pts <= r);); return l = Math.max(l, 0), a.splice(l, o - l + 1), a })(this.gopBuffer_, e, t, this.timeMapping_), r++, this.sourceUpdater_.removeVideo(e, t, s)); for (const a in this.inbandTextTracks_) fh(e, t, this.inbandTextTracks_[a]); fh(e, t, this.segmentMetadataTrack_), s() } monitorBuffer_() { this.checkBufferTimeout_ && Un().clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = Un().setTimeout(this.monitorBufferTick_.bind(this), 1) } monitorBufferTick_() { "READY" === this.state && this.fillBuffer_(), this.checkBufferTimeout_ && Un().clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = Un().setTimeout(this.monitorBufferTick_.bind(this), 500) } fillBuffer_() { if (this.sourceUpdater_.updating()) return; const e = this.chooseNextRequest_(); e && ("number" === typeof e.timestampOffset && (this.isPendingTimestampOffset_ = !1, this.timelineChangeController_.pendingTimelineChange({ type: this.loaderType_, from: this.currentTimeline_, to: e.timeline })), this.loadSegment_(e)) } isEndOfStream_() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.mediaIndex, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.playlist_, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.partIndex; if (!t || !this.mediaSource_) return !1; const i = "number" === typeof e && t.segments[e], r = e + 1 === t.segments.length, s = !i || !i.parts || n + 1 === i.parts.length; return t.endList && "open" === this.mediaSource_.readyState && r && s } chooseNextRequest_() { const e = this.buffered_(), t = xu(e) || 0, n = ku(e, this.currentTime_()), i = !this.hasPlayed_() && n >= 1, r = n >= this.goalBufferLength_(), s = this.playlist_.segments; if (!s.length || i || r) return null; this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_()); const a = { partIndex: null, mediaIndex: null, startOfSegment: null, playlist: this.playlist_, isSyncRequest: Boolean(!this.syncPoint_) }; if (a.isSyncRequest) a.mediaIndex = function (e, t, n) { t = t || []; const i = []; let r = 0; for (let s = 0; s < t.length; s++) { const a = t[s]; if (e === a.timeline && (i.push(s), r += a.duration, r > n)) return s } return 0 === i.length ? 0 : i[i.length - 1] }(this.currentTimeline_, s, t); else if (null !== this.mediaIndex) { const e = s[this.mediaIndex], n = "number" === typeof this.partIndex ? this.partIndex : -1; a.startOfSegment = e.end ? e.end : t, e.parts && e.parts[n + 1] ? (a.mediaIndex = this.mediaIndex, a.partIndex = n + 1) : a.mediaIndex = this.mediaIndex + 1 } else { const { segmentIndex: e, startTime: n, partIndex: i } = Vu.getMediaInfoForTime({ exactManifestTimings: this.exactManifestTimings, playlist: this.playlist_, currentTime: this.fetchAtBuffer_ ? t : this.currentTime_(), startingPartIndex: this.syncPoint_.partIndex, startingSegmentIndex: this.syncPoint_.segmentIndex, startTime: this.syncPoint_.time }); a.getMediaInfoForTime = this.fetchAtBuffer_ ? "bufferedEnd ".concat(t) : "currentTime ".concat(this.currentTime_()), a.mediaIndex = e, a.startOfSegment = n, a.partIndex = i } const o = s[a.mediaIndex]; let l = o && "number" === typeof a.partIndex && o.parts && o.parts[a.partIndex]; if (!o || "number" === typeof a.partIndex && !l) return null; if ("number" !== typeof a.partIndex && o.parts && (a.partIndex = 0, l = o.parts[0]), !n && l && !l.independent) if (0 === a.partIndex) { const e = s[a.mediaIndex - 1], t = e.parts && e.parts.length && e.parts[e.parts.length - 1]; t && t.independent && (a.mediaIndex -= 1, a.partIndex = e.parts.length - 1, a.independent = "previous segment") } else o.parts[a.partIndex - 1].independent && (a.partIndex -= 1, a.independent = "previous part"); const c = this.mediaSource_ && "ended" === this.mediaSource_.readyState; return a.mediaIndex >= s.length - 1 && c && !this.seeking_() ? null : this.generateSegmentInfo_(a) } generateSegmentInfo_(e) { const { independent: t, playlist: n, mediaIndex: i, startOfSegment: r, isSyncRequest: s, partIndex: a, forceTimestampOffset: o, getMediaInfoForTime: l } = e, c = n.segments[i], u = "number" === typeof a && c.parts[a], d = { requestId: "segment-loader-" + Math.random(), uri: u && u.resolvedUri || c.resolvedUri, mediaIndex: i, partIndex: u ? a : null, isSyncRequest: s, startOfSegment: r, playlist: n, bytes: null, encryptedBytes: null, timestampOffset: null, timeline: c.timeline, duration: u && u.duration || c.duration, segment: c, part: u, byteLength: 0, transmuxer: this.transmuxer_, getMediaInfoForTime: l, independent: t }, h = "undefined" !== typeof o ? o : this.isPendingTimestampOffset_; d.timestampOffset = this.timestampOffsetForSegment_({ segmentTimeline: c.timeline, currentTimeline: this.currentTimeline_, startOfSegment: r, buffered: this.buffered_(), overrideCheck: h }); const p = xu(this.sourceUpdater_.audioBuffered()); return "number" === typeof p && (d.audioAppendStart = p - this.sourceUpdater_.audioTimestampOffset()), this.sourceUpdater_.videoBuffered().length && (d.gopsToAlignWith = ((e, t, n) => { if ("undefined" === typeof t || null === t || !e.length) return []; const i = Math.ceil((t - n + 3) * ss.ONE_SECOND_IN_TS); let r; for (r = 0; r < e.length && !(e[r].pts > i); r++); return e.slice(r) })(this.gopBuffer_, this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_)), d } timestampOffsetForSegment_(e) { return (e => { let { segmentTimeline: t, currentTimeline: n, startOfSegment: i, buffered: r, overrideCheck: s } = e; return s || t !== n ? t < n ? i : r.length ? r.end(r.length - 1) : i : null })(e) } earlyAbortWhenNeeded_(e) { if (this.vhs_.tech_.paused() || !this.xhrOptions_.timeout || !this.playlist_.attributes.BANDWIDTH) return; if (Date.now() - (e.firstBytesReceivedAt || Date.now()) < 1e3) return; const t = this.currentTime_(), n = e.bandwidth, i = this.pendingSegment_.duration, r = Vu.estimateSegmentRequestTime(i, n, this.playlist_, e.bytesReceived), s = function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1; return ((e.length ? e.end(e.length - 1) : 0) - t) / n }(this.buffered_(), t, this.vhs_.tech_.playbackRate()) - 1; if (r <= s) return; const a = function (e) { const { main: t, currentTime: n, bandwidth: i, duration: r, segmentDuration: s, timeUntilRebuffer: a, currentTimeline: o, syncController: l } = e, c = t.playlists.filter((e => !Vu.isIncompatible(e))); let u = c.filter(Vu.isEnabled); u.length || (u = c.filter((e => !Vu.isDisabled(e)))); const d = u.filter(Vu.hasAttribute.bind(null, "BANDWIDTH")).map((e => { const t = l.getSyncPoint(e, r, o, n) ? 1 : 2; return { playlist: e, rebufferingImpact: Vu.estimateSegmentRequestTime(s, i, e) * t - a } })), h = d.filter((e => e.rebufferingImpact <= 0)); return ch(h, ((e, t) => uh(t.playlist, e.playlist))), h.length ? h[0] : (ch(d, ((e, t) => e.rebufferingImpact - t.rebufferingImpact)), d[0] || null) }({ main: this.vhs_.playlists.main, currentTime: t, bandwidth: n, duration: this.duration_(), segmentDuration: i, timeUntilRebuffer: s, currentTimeline: this.currentTimeline_, syncController: this.syncController_ }); if (!a) return; const o = r - s - a.rebufferingImpact; let l = .5; s <= yu && (l = 1), !a.playlist || a.playlist.uri === this.playlist_.uri || o < l || (this.bandwidth = a.playlist.attributes.BANDWIDTH * Ed.BANDWIDTH_VARIANCE + 1, this.trigger("earlyabort")) } handleAbort_(e) { this.logger_("Aborting ".concat(yh(e))), this.mediaRequestsAborted += 1 } handleProgress_(e, t) { this.earlyAbortWhenNeeded_(t.stats), this.checkForAbort_(t.requestId) || this.trigger("progress") } handleTrackInfo_(e, t) { this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId) || this.checkForIllegalMediaSwitch(t) || (t = t || {}, function (e, t) { if (!e && !t || !e && t || e && !t) return !1; if (e === t) return !0; const n = Object.keys(e).sort(), i = Object.keys(t).sort(); if (n.length !== i.length) return !1; for (let r = 0; r < n.length; r++) { const s = n[r]; if (s !== i[r]) return !1; if (e[s] !== t[s]) return !1 } return !0 }(this.currentMediaInfo_, t) || (this.appendInitSegment_ = { audio: !0, video: !0 }, this.startingMediaInfo_ = t, this.currentMediaInfo_ = t, this.logger_("trackinfo update", t), this.trigger("trackinfo")), this.checkForAbort_(e.requestId) || (this.pendingSegment_.trackInfo = t, this.hasEnoughInfoToAppend_() && this.processCallQueue_())) } handleTimingInfo_(e, t, n, i) { if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId)) return; const r = this.pendingSegment_, s = vh(t); r[s] = r[s] || {}, r[s][n] = i, this.logger_("timinginfo: ".concat(t, " - ").concat(n, " - ").concat(i)), this.hasEnoughInfoToAppend_() && this.processCallQueue_() } handleCaptions_(e, t) { if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId)) return; if (0 === t.length) return void this.logger_("SegmentLoader received no captions from a caption event"); if (!this.pendingSegment_.hasAppendedData_) return void this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, e, t)); const n = null === this.sourceUpdater_.videoTimestampOffset() ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(), i = {}; t.forEach((e => { i[e.stream] = i[e.stream] || { startTime: 1 / 0, captions: [], endTime: 0 }; const t = i[e.stream]; t.startTime = Math.min(t.startTime, e.startTime + n), t.endTime = Math.max(t.endTime, e.endTime + n), t.captions.push(e) })), Object.keys(i).forEach((e => { const { startTime: t, endTime: r, captions: s } = i[e], a = this.inbandTextTracks_; this.logger_("adding cues from ".concat(t, " -> ").concat(r, " for ").concat(e)), function (e, t, n) { if (!e[n]) { t.trigger({ type: "usage", name: "vhs-608" }); let i = n; /^cc708_/.test(n) && (i = "SERVICE" + n.split("_")[1]); const r = t.textTracks().getTrackById(i); if (r) e[n] = r; else { let r = n, s = n, a = !1; const o = (t.options_.vhs && t.options_.vhs.captionServices || {})[i]; o && (r = o.label, s = o.language, a = o.default), e[n] = t.addRemoteTextTrack({ kind: "captions", id: i, default: a, label: r, language: s }, !1).track } } }(a, this.vhs_.tech_, e), fh(t, r, a[e]), function (e) { let { inbandTextTracks: t, captionArray: n, timestampOffset: i } = e; if (!n) return; const r = Un().WebKitDataCue || Un().VTTCue; n.forEach((e => { const n = e.stream; t[n].addCue(new r(e.startTime + i, e.endTime + i, e.text)) })) }({ captionArray: s, inbandTextTracks: a, timestampOffset: n }) })), this.transmuxer_ && this.transmuxer_.postMessage({ action: "clearParsedMp4Captions" }) } handleId3_(e, t, n) { if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId)) return; if (!this.pendingSegment_.hasAppendedData_) return void this.metadataQueue_.id3.push(this.handleId3_.bind(this, e, t, n)); const i = null === this.sourceUpdater_.videoTimestampOffset() ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(); ((e, t, n) => { e.metadataTrack_ || (e.metadataTrack_ = n.addRemoteTextTrack({ kind: "metadata", label: "Timed Metadata" }, !1).track, e.metadataTrack_.inBandMetadataTrackDispatchType = t) })(this.inbandTextTracks_, n, this.vhs_.tech_), ph({ inbandTextTracks: this.inbandTextTracks_, metadataArray: t, timestampOffset: i, videoDuration: this.duration_() }) } processMetadataQueue_() { this.metadataQueue_.id3.forEach((e => e())), this.metadataQueue_.caption.forEach((e => e())), this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [] } processCallQueue_() { const e = this.callQueue_; this.callQueue_ = [], e.forEach((e => e())) } processLoadQueue_() { const e = this.loadQueue_; this.loadQueue_ = [], e.forEach((e => e())) } hasEnoughInfoToLoad_() { if ("audio" !== this.loaderType_) return !0; const e = this.pendingSegment_; return !!e && (!this.getCurrentMediaInfo_() || !bh({ timelineChangeController: this.timelineChangeController_, currentTimeline: this.currentTimeline_, segmentTimeline: e.timeline, loaderType: this.loaderType_, audioDisabled: this.audioDisabled_ })) } getCurrentMediaInfo_() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.pendingSegment_; return e && e.trackInfo || this.currentMediaInfo_ } getMediaInfo_() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.pendingSegment_; return this.getCurrentMediaInfo_(e) || this.startingMediaInfo_ } getPendingSegmentPlaylist() { return this.pendingSegment_ ? this.pendingSegment_.playlist : null } hasEnoughInfoToAppend_() { if (!this.sourceUpdater_.ready()) return !1; if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) return !1; const e = this.pendingSegment_, t = this.getCurrentMediaInfo_(); if (!e || !t) return !1; const { hasAudio: n, hasVideo: i, isMuxed: r } = t; return !(i && !e.videoTimingInfo) && (!(n && !this.audioDisabled_ && !r && !e.audioTimingInfo) && !bh({ timelineChangeController: this.timelineChangeController_, currentTimeline: this.currentTimeline_, segmentTimeline: e.timeline, loaderType: this.loaderType_, audioDisabled: this.audioDisabled_ })) } handleData_(e, t) { if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId)) return; if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) return void this.callQueue_.push(this.handleData_.bind(this, e, t)); const n = this.pendingSegment_; if (this.setTimeMapping_(n.timeline), this.updateMediaSecondsLoaded_(n.part || n.segment), "closed" !== this.mediaSource_.readyState) { if (e.map && (e.map = this.initSegmentForMap(e.map, !0), n.segment.map = e.map), e.key && this.segmentKey(e.key, !0), n.isFmp4 = e.isFmp4, n.timingInfo = n.timingInfo || {}, n.isFmp4) this.trigger("fmp4"), n.timingInfo.start = n[vh(t.type)].start; else { const e = this.getCurrentMediaInfo_(), t = "main" === this.loaderType_ && e && e.hasVideo; let i; t && (i = n.videoTimingInfo.start), n.timingInfo.start = this.trueSegmentStart_({ currentStart: n.timingInfo.start, playlist: n.playlist, mediaIndex: n.mediaIndex, currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(), useVideoTimingInfo: t, firstVideoFrameTimeForData: i, videoTimingInfo: n.videoTimingInfo, audioTimingInfo: n.audioTimingInfo }) } if (this.updateAppendInitSegmentStatus(n, t.type), this.updateSourceBufferTimestampOffset_(n), n.isSyncRequest) { this.updateTimingInfoEnd_(n), this.syncController_.saveSegmentTimingInfo({ segmentInfo: n, shouldSaveTimelineMapping: "main" === this.loaderType_ }); const e = this.chooseNextRequest_(); if (e.mediaIndex !== n.mediaIndex || e.partIndex !== n.partIndex) return void this.logger_("sync segment was incorrect, not appending"); this.logger_("sync segment was correct, appending") } n.hasAppendedData_ = !0, this.processMetadataQueue_(), this.appendData_(n, t) } } updateAppendInitSegmentStatus(e, t) { "main" !== this.loaderType_ || "number" !== typeof e.timestampOffset || e.changedTimestampOffset || (this.appendInitSegment_ = { audio: !0, video: !0 }), this.playlistOfLastInitSegment_[t] !== e.playlist && (this.appendInitSegment_[t] = !0) } getInitSegmentAndUpdateState_(e) { let { type: t, initSegment: n, map: i, playlist: r } = e; if (i) { const e = hd(i); if (this.activeInitSegmentId_ === e) return null; n = this.initSegmentForMap(i, !0).bytes, this.activeInitSegmentId_ = e } return n && this.appendInitSegment_[t] ? (this.playlistOfLastInitSegment_[t] = r, this.appendInitSegment_[t] = !1, this.activeInitSegmentId_ = null, n) : null } handleQuotaExceededError_(e, t) { let { segmentInfo: n, type: i, bytes: r } = e; const s = this.sourceUpdater_.audioBuffered(), a = this.sourceUpdater_.videoBuffered(); s.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + wu(s).join(", ")), a.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + wu(a).join(", ")); const o = s.length ? s.start(0) : 0, l = s.length ? s.end(s.length - 1) : 0, c = a.length ? a.start(0) : 0, u = a.length ? a.end(a.length - 1) : 0; if (l - o <= 1 && u - c <= 1) return this.logger_("On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. " + "Appended byte length: ".concat(r.byteLength, ", ") + "audio buffer: ".concat(wu(s).join(", "), ", ") + "video buffer: ".concat(wu(a).join(", "), ", ")), this.error({ message: "Quota exceeded error with append of a single segment of content", excludeUntil: 1 / 0 }), void this.trigger("error"); this.waitingOnRemove_ = !0, this.callQueue_.push(this.appendToSourceBuffer_.bind(this, { segmentInfo: n, type: i, bytes: r })); const d = this.currentTime_() - 1; this.logger_("On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to ".concat(d)), this.remove(0, d, (() => { this.logger_("On QUOTA_EXCEEDED_ERR, retrying append in ".concat(1, "s")), this.waitingOnRemove_ = !1, this.quotaExceededErrorRetryTimeout_ = Un().setTimeout((() => { this.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue"), this.quotaExceededErrorRetryTimeout_ = null, this.processCallQueue_() }), 1e3) }), !0) } handleAppendError_(e, t) { let { segmentInfo: n, type: i, bytes: r } = e; t && (22 !== t.code ? (this.logger_("Received non QUOTA_EXCEEDED_ERR on append", t), this.error("".concat(i, " append of ").concat(r.length, "b failed for segment ") + "#".concat(n.mediaIndex, " in playlist ").concat(n.playlist.id)), this.trigger("appenderror")) : this.handleQuotaExceededError_({ segmentInfo: n, type: i, bytes: r })) } appendToSourceBuffer_(e) { let { segmentInfo: t, type: n, initSegment: i, data: r, bytes: s } = e; if (!s) { const e = [r]; let t = r.byteLength; i && (e.unshift(i), t += i.byteLength), s = (e => { let t, n = 0; return e.bytes && (t = new Uint8Array(e.bytes), e.segments.forEach((e => { t.set(e, n), n += e.byteLength }))), t })({ bytes: t, segments: e }) } this.sourceUpdater_.appendBuffer({ segmentInfo: t, type: n, bytes: s }, this.handleAppendError_.bind(this, { segmentInfo: t, type: n, bytes: s })) } handleSegmentTimingInfo_(e, t, n) { if (!this.pendingSegment_ || t !== this.pendingSegment_.requestId) return; const i = this.pendingSegment_.segment, r = "".concat(e, "TimingInfo"); i[r] || (i[r] = {}), i[r].transmuxerPrependedSeconds = n.prependedContentDuration || 0, i[r].transmuxedPresentationStart = n.start.presentation, i[r].transmuxedDecodeStart = n.start.decode, i[r].transmuxedPresentationEnd = n.end.presentation, i[r].transmuxedDecodeEnd = n.end.decode, i[r].baseMediaDecodeTime = n.baseMediaDecodeTime } appendData_(e, t) { const { type: n, data: i } = t; if (!i || !i.byteLength) return; if ("audio" === n && this.audioDisabled_) return; const r = this.getInitSegmentAndUpdateState_({ type: n, initSegment: t.initSegment, playlist: e.playlist, map: e.isFmp4 ? e.segment.map : null }); this.appendToSourceBuffer_({ segmentInfo: e, type: n, initSegment: r, data: i }) } loadSegment_(e) { this.state = "WAITING", this.pendingSegment_ = e, this.trimBackBuffer_(e), "number" === typeof e.timestampOffset && this.transmuxer_ && this.transmuxer_.postMessage({ action: "clearAllMp4Captions" }), this.hasEnoughInfoToLoad_() ? this.updateTransmuxerAndRequestSegment_(e) : this.loadQueue_.push((() => { const t = Zn({}, e, { forceTimestampOffset: !0 }); Zn(e, this.generateSegmentInfo_(t)), this.isPendingTimestampOffset_ = !1, this.updateTransmuxerAndRequestSegment_(e) })) } updateTransmuxerAndRequestSegment_(e) { this.shouldUpdateTransmuxerTimestampOffset_(e.timestampOffset) && (this.gopBuffer_.length = 0, e.gopsToAlignWith = [], this.timeMapping_ = 0, this.transmuxer_.postMessage({ action: "reset" }), this.transmuxer_.postMessage({ action: "setTimestampOffset", timestampOffset: e.timestampOffset })); const t = this.createSimplifiedSegmentObj_(e), n = this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex), i = null !== this.mediaIndex, r = e.timeline !== this.currentTimeline_ && e.timeline > 0, s = n || i && r; this.logger_("Requesting ".concat(yh(e))), t.map && !t.map.bytes && (this.logger_("going to request init segment."), this.appendInitSegment_ = { video: !0, audio: !0 }), e.abortRequests = eh({ xhr: this.vhs_.xhr, xhrOptions: this.xhrOptions_, decryptionWorker: this.decrypter_, segment: t, abortFn: this.handleAbort_.bind(this, e), progressFn: this.handleProgress_.bind(this), trackInfoFn: this.handleTrackInfo_.bind(this), timingInfoFn: this.handleTimingInfo_.bind(this), videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", e.requestId), audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", e.requestId), captionsFn: this.handleCaptions_.bind(this), isEndOfTimeline: s, endedTimelineFn: () => { this.logger_("received endedtimeline callback") }, id3Fn: this.handleId3_.bind(this), dataFn: this.handleData_.bind(this), doneFn: this.segmentRequestFinished_.bind(this), onTransmuxerLog: t => { let { message: n, level: i, stream: r } = t; this.logger_("".concat(yh(e), " logged from transmuxer stream ").concat(r, " as a ").concat(i, ": ").concat(n)) } }) } trimBackBuffer_(e) { const t = ((e, t, n) => { let i = t - Ed.BACK_BUFFER_LENGTH; e.length && (i = Math.max(i, e.start(0))); const r = t - n; return Math.min(r, i) })(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10); t > 0 && this.remove(0, t) } createSimplifiedSegmentObj_(e) { const t = e.segment, n = e.part, i = { resolvedUri: n ? n.resolvedUri : t.resolvedUri, byterange: n ? n.byterange : t.byterange, requestId: e.requestId, transmuxer: e.transmuxer, audioAppendStart: e.audioAppendStart, gopsToAlignWith: e.gopsToAlignWith, part: e.part }, r = e.playlist.segments[e.mediaIndex - 1]; if (r && r.timeline === t.timeline && (r.videoTimingInfo ? i.baseStartTime = r.videoTimingInfo.transmuxedDecodeEnd : r.audioTimingInfo && (i.baseStartTime = r.audioTimingInfo.transmuxedDecodeEnd)), t.key) { const n = t.key.iv || new Uint32Array([0, 0, 0, e.mediaIndex + e.playlist.mediaSequence]); i.key = this.segmentKey(t.key), i.key.iv = n } return t.map && (i.map = this.initSegmentForMap(t.map)), i } saveTransferStats_(e) { this.mediaRequests += 1, e && (this.mediaBytesTransferred += e.bytesReceived, this.mediaTransferDuration += e.roundTripTime) } saveBandwidthRelatedStats_(e, t) { this.pendingSegment_.byteLength = t.bytesReceived, e < gh ? this.logger_("Ignoring segment's bandwidth because its duration of ".concat(e) + " is less than the min to record ".concat(gh)) : (this.bandwidth = t.bandwidth, this.roundTrip = t.roundTripTime) } handleTimeout_() { this.mediaRequestsTimedout += 1, this.bandwidth = 1, this.roundTrip = NaN, this.trigger("bandwidthupdate"), this.trigger("timeout") } segmentRequestFinished_(e, t, n) { if (this.callQueue_.length) return void this.callQueue_.push(this.segmentRequestFinished_.bind(this, e, t, n)); if (this.saveTransferStats_(t.stats), !this.pendingSegment_) return; if (t.requestId !== this.pendingSegment_.requestId) return; if (e) { if (this.pendingSegment_ = null, this.state = "READY", e.code === Vd) return; return this.pause(), e.code === Hd ? void this.handleTimeout_() : (this.mediaRequestsErrored += 1, this.error(e), void this.trigger("error")) } const i = this.pendingSegment_; this.saveBandwidthRelatedStats_(i.duration, t.stats), i.endOfAllRequests = t.endOfAllRequests, n.gopInfo && (this.gopBuffer_ = ((e, t, n) => { if (!t.length) return e; if (n) return t.slice(); const i = t[0].pts; let r = 0; for (; r < e.length && !(e[r].pts >= i); r++); return e.slice(0, r).concat(t) })(this.gopBuffer_, n.gopInfo, this.safeAppend_)), this.state = "APPENDING", this.trigger("appending"), this.waitForAppendsToComplete_(i) } setTimeMapping_(e) { const t = this.syncController_.mappingForTimeline(e); null !== t && (this.timeMapping_ = t) } updateMediaSecondsLoaded_(e) { "number" === typeof e.start && "number" === typeof e.end ? this.mediaSecondsLoaded += e.end - e.start : this.mediaSecondsLoaded += e.duration } shouldUpdateTransmuxerTimestampOffset_(e) { return null !== e && ("main" === this.loaderType_ && e !== this.sourceUpdater_.videoTimestampOffset() || !this.audioDisabled_ && e !== this.sourceUpdater_.audioTimestampOffset()) } trueSegmentStart_(e) { let { currentStart: t, playlist: n, mediaIndex: i, firstVideoFrameTimeForData: r, currentVideoTimestampOffset: s, useVideoTimingInfo: a, videoTimingInfo: o, audioTimingInfo: l } = e; if ("undefined" !== typeof t) return t; if (!a) return l.start; const c = n.segments[i - 1]; return 0 !== i && c && "undefined" !== typeof c.start && c.end === r + s ? o.start : r } waitForAppendsToComplete_(e) { const t = this.getCurrentMediaInfo_(e); if (!t) return this.error({ message: "No starting media returned, likely due to an unsupported media format.", playlistExclusionDuration: 1 / 0 }), void this.trigger("error"); const { hasAudio: n, hasVideo: i, isMuxed: r } = t, s = "main" === this.loaderType_ && i, a = !this.audioDisabled_ && n && !r; if (e.waitingOnAppends = 0, !e.hasAppendedData_) return e.timingInfo || "number" !== typeof e.timestampOffset || (this.isPendingTimestampOffset_ = !0), e.timingInfo = { start: 0 }, e.waitingOnAppends++, this.isPendingTimestampOffset_ || (this.updateSourceBufferTimestampOffset_(e), this.processMetadataQueue_()), void this.checkAppendsDone_(e); s && e.waitingOnAppends++, a && e.waitingOnAppends++, s && this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, e)), a && this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, e)) } checkAppendsDone_(e) { this.checkForAbort_(e.requestId) || (e.waitingOnAppends--, 0 === e.waitingOnAppends && this.handleAppendsDone_()) } checkForIllegalMediaSwitch(e) { const t = ((e, t, n) => "main" === e && t && n ? n.hasAudio || n.hasVideo ? t.hasVideo && !n.hasVideo ? "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest." : !t.hasVideo && n.hasVideo ? "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest." : null : "Neither audio nor video found in segment." : null)(this.loaderType_, this.getCurrentMediaInfo_(), e); return !!t && (this.error({ message: t, playlistExclusionDuration: 1 / 0 }), this.trigger("error"), !0) } updateSourceBufferTimestampOffset_(e) { if (null === e.timestampOffset || "number" !== typeof e.timingInfo.start || e.changedTimestampOffset || "main" !== this.loaderType_) return; let t = !1; e.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({ videoTimingInfo: e.segment.videoTimingInfo, audioTimingInfo: e.segment.audioTimingInfo, timingInfo: e.timingInfo }), e.changedTimestampOffset = !0, e.timestampOffset !== this.sourceUpdater_.videoTimestampOffset() && (this.sourceUpdater_.videoTimestampOffset(e.timestampOffset), t = !0), e.timestampOffset !== this.sourceUpdater_.audioTimestampOffset() && (this.sourceUpdater_.audioTimestampOffset(e.timestampOffset), t = !0), t && this.trigger("timestampoffset") } getSegmentStartTimeForTimestampOffsetCalculation_(e) { let { videoTimingInfo: t, audioTimingInfo: n, timingInfo: i } = e; return this.useDtsForTimestampOffset_ ? t && "number" === typeof t.transmuxedDecodeStart ? t.transmuxedDecodeStart : n && "number" === typeof n.transmuxedDecodeStart ? n.transmuxedDecodeStart : i.start : i.start } updateTimingInfoEnd_(e) { e.timingInfo = e.timingInfo || {}; const t = this.getMediaInfo_(), n = "main" === this.loaderType_ && t && t.hasVideo && e.videoTimingInfo ? e.videoTimingInfo : e.audioTimingInfo; n && (e.timingInfo.end = "number" === typeof n.end ? n.end : n.start + e.duration) } handleAppendsDone_() { if (this.pendingSegment_ && this.trigger("appendsdone"), !this.pendingSegment_) return this.state = "READY", void (this.paused() || this.monitorBuffer_()); const e = this.pendingSegment_; this.updateTimingInfoEnd_(e), this.shouldSaveSegmentTimingInfo_ && this.syncController_.saveSegmentTimingInfo({ segmentInfo: e, shouldSaveTimelineMapping: "main" === this.loaderType_ }); const t = Th(e, this.sourceType_); if (t && ("warn" === t.severity ? au.log.warn(t.message) : this.logger_(t.message)), this.recordThroughput_(e), this.pendingSegment_ = null, this.state = "READY", e.isSyncRequest && (this.trigger("syncinfoupdate"), !e.hasAppendedData_)) return void this.logger_("Throwing away un-appended sync request ".concat(yh(e))); this.logger_("Appended ".concat(yh(e))), this.addSegmentMetadataCue_(e), this.fetchAtBuffer_ = !0, this.currentTimeline_ !== e.timeline && (this.timelineChangeController_.lastTimelineChange({ type: this.loaderType_, from: this.currentTimeline_, to: e.timeline }), "main" !== this.loaderType_ || this.audioDisabled_ || this.timelineChangeController_.lastTimelineChange({ type: "audio", from: this.currentTimeline_, to: e.timeline })), this.currentTimeline_ = e.timeline, this.trigger("syncinfoupdate"); const n = e.segment, i = e.part, r = n.end && this.currentTime_() - n.end > 3 * e.playlist.targetDuration, s = i && i.end && this.currentTime_() - i.end > 3 * e.playlist.partTargetDuration; if (r || s) return this.logger_("bad ".concat(r ? "segment" : "part", " ").concat(yh(e))), void this.resetEverything(); null !== this.mediaIndex && this.trigger("bandwidthupdate"), this.trigger("progress"), this.mediaIndex = e.mediaIndex, this.partIndex = e.partIndex, this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex) && this.endOfStream(), this.trigger("appended"), e.hasAppendedData_ && this.mediaAppends++, this.paused() || this.monitorBuffer_() } recordThroughput_(e) { if (e.duration < gh) return void this.logger_("Ignoring segment's throughput because its duration of ".concat(e.duration) + " is less than the min to record ".concat(gh)); const t = this.throughput.rate, n = Date.now() - e.endOfAllRequests + 1, i = Math.floor(e.byteLength / n * 8 * 1e3); this.throughput.rate += (i - t) / ++this.throughput.count } addSegmentMetadataCue_(e) { if (!this.segmentMetadataTrack_) return; const t = e.segment, n = t.start, i = t.end; if (!mh(n) || !mh(i)) return; fh(n, i, this.segmentMetadataTrack_); const r = Un().WebKitDataCue || Un().VTTCue, s = { custom: t.custom, dateTimeObject: t.dateTimeObject, dateTimeString: t.dateTimeString, bandwidth: e.playlist.attributes.BANDWIDTH, resolution: e.playlist.attributes.RESOLUTION, codecs: e.playlist.attributes.CODECS, byteLength: e.byteLength, uri: e.uri, timeline: e.timeline, playlist: e.playlist.id, start: n, end: i }, a = new r(n, i, JSON.stringify(s)); a.value = s, this.segmentMetadataTrack_.addCue(a) } } function wh() { } const xh = function (e) { return "string" !== typeof e ? e : e.replace(/./, (e => e.toUpperCase())) }, kh = ["video", "audio"], Eh = (e, t) => { const n = t["".concat(e, "Buffer")]; return n && n.updating || t.queuePending[e] }, Ch = (e, t) => { if (0 === t.queue.length) return; let n = 0, i = t.queue[n]; if ("mediaSource" !== i.type) { if ("mediaSource" !== e && t.ready() && "closed" !== t.mediaSource.readyState && !Eh(e, t)) { if (i.type !== e) { if (n = ((e, t) => { for (let n = 0; n < t.length; n++) { const i = t[n]; if ("mediaSource" === i.type) return null; if (i.type === e) return n } return null })(e, t.queue), null === n) return; i = t.queue[n] } return t.queue.splice(n, 1), t.queuePending[e] = i, i.action(e, t), i.doneFn ? void 0 : (t.queuePending[e] = null, void Ch(e, t)) } } else t.updating() || "closed" === t.mediaSource.readyState || (t.queue.shift(), i.action(t), i.doneFn && i.doneFn(), Ch("audio", t), Ch("video", t)) }, Ph = (e, t) => { const n = t["".concat(e, "Buffer")], i = xh(e); n && (n.removeEventListener("updateend", t["on".concat(i, "UpdateEnd_")]), n.removeEventListener("error", t["on".concat(i, "Error_")]), t.codecs[e] = null, t["".concat(e, "Buffer")] = null) }, Ih = (e, t) => e && t && -1 !== Array.prototype.indexOf.call(e.sourceBuffers, t), Lh = (e, t, n) => (i, r) => { const s = r["".concat(i, "Buffer")]; if (Ih(r.mediaSource, s)) { r.logger_("Appending segment ".concat(t.mediaIndex, "'s ").concat(e.length, " bytes to ").concat(i, "Buffer")); try { s.appendBuffer(e) } catch (a) { r.logger_("Error with code ".concat(a.code, " ") + (22 === a.code ? "(QUOTA_EXCEEDED_ERR) " : "") + "when appending segment ".concat(t.mediaIndex, " to ").concat(i, "Buffer")), r.queuePending[i] = null, n(a) } } }, Oh = (e, t) => (n, i) => { const r = i["".concat(n, "Buffer")]; if (Ih(i.mediaSource, r)) { i.logger_("Removing ".concat(e, " to ").concat(t, " from ").concat(n, "Buffer")); try { r.remove(e, t) } catch (s) { i.logger_("Remove ".concat(e, " to ").concat(t, " from ").concat(n, "Buffer failed")) } } }, Ah = e => (t, n) => { const i = n["".concat(t, "Buffer")]; Ih(n.mediaSource, i) && (n.logger_("Setting ".concat(t, "timestampOffset to ").concat(e)), i.timestampOffset = e) }, Nh = e => (t, n) => { e() }, jh = e => t => { if ("open" === t.mediaSource.readyState) { t.logger_("Calling mediaSource endOfStream(".concat(e || "", ")")); try { t.mediaSource.endOfStream(e) } catch (n) { au.log.warn("Failed to call media source endOfStream", n) } } }, Dh = e => t => { t.logger_("Setting mediaSource duration to ".concat(e)); try { t.mediaSource.duration = e } catch (n) { au.log.warn("Failed to set media source duration", n) } }, Mh = () => (e, t) => { if ("open" !== t.mediaSource.readyState) return; const n = t["".concat(e, "Buffer")]; if (Ih(t.mediaSource, n)) { t.logger_("calling abort on ".concat(e, "Buffer")); try { n.abort() } catch (i) { au.log.warn("Failed to abort on ".concat(e, "Buffer"), i) } } }, Rh = (e, t) => n => { const i = xh(e), r = gi(t); n.logger_("Adding ".concat(e, "Buffer with codec ").concat(t, " to mediaSource")); const s = n.mediaSource.addSourceBuffer(r); s.addEventListener("updateend", n["on".concat(i, "UpdateEnd_")]), s.addEventListener("error", n["on".concat(i, "Error_")]), n.codecs[e] = t, n["".concat(e, "Buffer")] = s }, Uh = e => t => { const n = t["".concat(e, "Buffer")]; if (Ph(e, t), Ih(t.mediaSource, n)) { t.logger_("Removing ".concat(e, "Buffer with codec ").concat(t.codecs[e], " from mediaSource")); try { t.mediaSource.removeSourceBuffer(n) } catch (i) { au.log.warn("Failed to removeSourceBuffer ".concat(e, "Buffer"), i) } } }, Bh = e => (t, n) => { const i = n["".concat(t, "Buffer")], r = gi(e); Ih(n.mediaSource, i) && n.codecs[t] !== e && (n.logger_("changing ".concat(t, "Buffer codec from ").concat(n.codecs[t], " to ").concat(e)), i.changeType(r), n.codecs[t] = e) }, Fh = e => { let { type: t, sourceUpdater: n, action: i, doneFn: r, name: s } = e; n.queue.push({ type: t, action: i, doneFn: r, name: s }), Ch(t, n) }, zh = (e, t) => n => { if (t.queuePending[e]) { const n = t.queuePending[e].doneFn; t.queuePending[e] = null, n && n(t["".concat(e, "Error_")]) } Ch(e, t) }; class Hh extends au.EventTarget { constructor(e) { super(), this.mediaSource = e, this.sourceopenListener_ = () => Ch("mediaSource", this), this.mediaSource.addEventListener("sourceopen", this.sourceopenListener_), this.logger_ = fu("SourceUpdater"), this.audioTimestampOffset_ = 0, this.videoTimestampOffset_ = 0, this.queue = [], this.queuePending = { audio: null, video: null }, this.delayedAudioAppendQueue_ = [], this.videoAppendQueued_ = !1, this.codecs = {}, this.onVideoUpdateEnd_ = zh("video", this), this.onAudioUpdateEnd_ = zh("audio", this), this.onVideoError_ = e => { this.videoError_ = e }, this.onAudioError_ = e => { this.audioError_ = e }, this.createdSourceBuffers_ = !1, this.initializedEme_ = !1, this.triggeredReady_ = !1 } initializedEme() { this.initializedEme_ = !0, this.triggerReady() } hasCreatedSourceBuffers() { return this.createdSourceBuffers_ } hasInitializedAnyEme() { return this.initializedEme_ } ready() { return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme() } createSourceBuffers(e) { this.hasCreatedSourceBuffers() || (this.addOrChangeSourceBuffers(e), this.createdSourceBuffers_ = !0, this.trigger("createdsourcebuffers"), this.triggerReady()) } triggerReady() { this.ready() && !this.triggeredReady_ && (this.triggeredReady_ = !0, this.trigger("ready")) } addSourceBuffer(e, t) { Fh({ type: "mediaSource", sourceUpdater: this, action: Rh(e, t), name: "addSourceBuffer" }) } abort(e) { Fh({ type: e, sourceUpdater: this, action: Mh(e), name: "abort" }) } removeSourceBuffer(e) { this.canRemoveSourceBuffer() ? Fh({ type: "mediaSource", sourceUpdater: this, action: Uh(e), name: "removeSourceBuffer" }) : au.log.error("removeSourceBuffer is not supported!") } canRemoveSourceBuffer() { return !au.browser.IE_VERSION && !au.browser.IS_FIREFOX && Un().MediaSource && Un().MediaSource.prototype && "function" === typeof Un().MediaSource.prototype.removeSourceBuffer } static canChangeType() { return Un().SourceBuffer && Un().SourceBuffer.prototype && "function" === typeof Un().SourceBuffer.prototype.changeType } canChangeType() { return this.constructor.canChangeType() } changeType(e, t) { this.canChangeType() ? Fh({ type: e, sourceUpdater: this, action: Bh(t), name: "changeType" }) : au.log.error("changeType is not supported!") } addOrChangeSourceBuffers(e) { if (!e || "object" !== typeof e || 0 === Object.keys(e).length) throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs"); Object.keys(e).forEach((t => { const n = e[t]; if (!this.hasCreatedSourceBuffers()) return this.addSourceBuffer(t, n); this.canChangeType() && this.changeType(t, n) })) } appendBuffer(e, t) { const { segmentInfo: n, type: i, bytes: r } = e; if (this.processedAppend_ = !0, "audio" === i && this.videoBuffer && !this.videoAppendQueued_) return this.delayedAudioAppendQueue_.push([e, t]), void this.logger_("delayed audio append of ".concat(r.length, " until video append")); if (Fh({ type: i, sourceUpdater: this, action: Lh(r, n || { mediaIndex: -1 }, t), doneFn: t, name: "appendBuffer" }), "video" === i) { if (this.videoAppendQueued_ = !0, !this.delayedAudioAppendQueue_.length) return; const e = this.delayedAudioAppendQueue_.slice(); this.logger_("queuing delayed audio ".concat(e.length, " appendBuffers")), this.delayedAudioAppendQueue_.length = 0, e.forEach((e => { this.appendBuffer.apply(this, e) })) } } audioBuffered() { return Ih(this.mediaSource, this.audioBuffer) && this.audioBuffer.buffered ? this.audioBuffer.buffered : gu() } videoBuffered() { return Ih(this.mediaSource, this.videoBuffer) && this.videoBuffer.buffered ? this.videoBuffer.buffered : gu() } buffered() { const e = Ih(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null, t = Ih(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null; return t && !e ? this.audioBuffered() : e && !t ? this.videoBuffered() : function (e, t) { let n = null, i = null, r = 0; const s = [], a = []; if (!e || !e.length || !t || !t.length) return gu(); let o = e.length; for (; o--;)s.push({ time: e.start(o), type: "start" }), s.push({ time: e.end(o), type: "end" }); for (o = t.length; o--;)s.push({ time: t.start(o), type: "start" }), s.push({ time: t.end(o), type: "end" }); for (s.sort((function (e, t) { return e.time - t.time })), o = 0; o < s.length; o++)"start" === s[o].type ? (r++, 2 === r && (n = s[o].time)) : "end" === s[o].type && (r--, 1 === r && (i = s[o].time)), null !== n && null !== i && (a.push([n, i]), n = null, i = null); return gu(a) }(this.audioBuffered(), this.videoBuffered()) } setDuration(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : wh; Fh({ type: "mediaSource", sourceUpdater: this, action: Dh(e), name: "duration", doneFn: t }) } endOfStream() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : wh; "string" !== typeof e && (e = void 0), Fh({ type: "mediaSource", sourceUpdater: this, action: jh(e), name: "endOfStream", doneFn: t }) } removeAudio(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : wh; this.audioBuffered().length && 0 !== this.audioBuffered().end(0) ? Fh({ type: "audio", sourceUpdater: this, action: Oh(e, t), doneFn: n, name: "remove" }) : n() } removeVideo(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : wh; this.videoBuffered().length && 0 !== this.videoBuffered().end(0) ? Fh({ type: "video", sourceUpdater: this, action: Oh(e, t), doneFn: n, name: "remove" }) : n() } updating() { return !(!Eh("audio", this) && !Eh("video", this)) } audioTimestampOffset(e) { return "undefined" !== typeof e && this.audioBuffer && this.audioTimestampOffset_ !== e && (Fh({ type: "audio", sourceUpdater: this, action: Ah(e), name: "timestampOffset" }), this.audioTimestampOffset_ = e), this.audioTimestampOffset_ } videoTimestampOffset(e) { return "undefined" !== typeof e && this.videoBuffer && this.videoTimestampOffset !== e && (Fh({ type: "video", sourceUpdater: this, action: Ah(e), name: "timestampOffset" }), this.videoTimestampOffset_ = e), this.videoTimestampOffset_ } audioQueueCallback(e) { this.audioBuffer && Fh({ type: "audio", sourceUpdater: this, action: Nh(e), name: "callback" }) } videoQueueCallback(e) { this.videoBuffer && Fh({ type: "video", sourceUpdater: this, action: Nh(e), name: "callback" }) } dispose() { this.trigger("dispose"), kh.forEach((e => { this.abort(e), this.canRemoveSourceBuffer() ? this.removeSourceBuffer(e) : this["".concat(e, "QueueCallback")]((() => Ph(e, this))) })), this.videoAppendQueued_ = !1, this.delayedAudioAppendQueue_.length = 0, this.sourceopenListener_ && this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_), this.off() } } const Vh = e => decodeURIComponent(escape(String.fromCharCode.apply(null, e))), Wh = new Uint8Array("\n\n".split("").map((e => e.charCodeAt(0)))); class qh extends Error { constructor() { super("Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.") } } class Gh extends Sh { constructor(e) { super(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}), this.mediaSource_ = null, this.subtitlesTrack_ = null, this.loaderType_ = "subtitle", this.featuresNativeTextTracks_ = e.featuresNativeTextTracks, this.loadVttJs = e.loadVttJs, this.shouldSaveSegmentTimingInfo_ = !1 } createTransmuxer_() { return null } buffered_() { if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) return gu(); const e = this.subtitlesTrack_.cues; return gu([[e[0].startTime, e[e.length - 1].startTime]]) } initSegmentForMap(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (!e) return null; const n = hd(e); let i = this.initSegments_[n]; if (t && !i && e.bytes) { const t = Wh.byteLength + e.bytes.byteLength, r = new Uint8Array(t); r.set(e.bytes), r.set(Wh, e.bytes.byteLength), this.initSegments_[n] = i = { resolvedUri: e.resolvedUri, byterange: e.byterange, bytes: r } } return i || e } couldBeginLoading_() { return this.playlist_ && this.subtitlesTrack_ && !this.paused() } init_() { return this.state = "READY", this.resetEverything(), this.monitorBuffer_() } track(e) { return "undefined" === typeof e || (this.subtitlesTrack_ = e, "INIT" === this.state && this.couldBeginLoading_() && this.init_()), this.subtitlesTrack_ } remove(e, t) { fh(e, t, this.subtitlesTrack_) } fillBuffer_() { const e = this.chooseNextRequest_(); if (e) { if (null === this.syncController_.timestampOffsetForTimeline(e.timeline)) { const e = () => { this.state = "READY", this.paused() || this.monitorBuffer_() }; return this.syncController_.one("timestampoffset", e), void (this.state = "WAITING_ON_TIMELINE") } this.loadSegment_(e) } } timestampOffsetForSegment_() { return null } chooseNextRequest_() { return this.skipEmptySegments_(super.chooseNextRequest_()) } skipEmptySegments_(e) { for (; e && e.segment.empty;) { if (e.mediaIndex + 1 >= e.playlist.segments.length) { e = null; break } e = this.generateSegmentInfo_({ playlist: e.playlist, mediaIndex: e.mediaIndex + 1, startOfSegment: e.startOfSegment + e.duration, isSyncRequest: e.isSyncRequest }) } return e } stopForError(e) { this.error(e), this.state = "READY", this.pause(), this.trigger("error") } segmentRequestFinished_(e, t, n) { if (!this.subtitlesTrack_) return void (this.state = "READY"); if (this.saveTransferStats_(t.stats), !this.pendingSegment_) return this.state = "READY", void (this.mediaRequestsAborted += 1); if (e) return e.code === Hd && this.handleTimeout_(), e.code === Vd ? this.mediaRequestsAborted += 1 : this.mediaRequestsErrored += 1, void this.stopForError(e); const i = this.pendingSegment_; this.saveBandwidthRelatedStats_(i.duration, t.stats), t.key && this.segmentKey(t.key, !0), this.state = "APPENDING", this.trigger("appending"); const r = i.segment; if (r.map && (r.map.bytes = t.map.bytes), i.bytes = t.bytes, "function" !== typeof Un().WebVTT && "function" === typeof this.loadVttJs) return this.state = "WAITING_ON_VTTJS", void this.loadVttJs().then((() => this.segmentRequestFinished_(e, t, n)), (() => this.stopForError({ message: "Error loading vtt.js" }))); r.requested = !0; try { this.parseVTTCues_(i) } catch (s) { return void this.stopForError({ message: s.message }) } if (this.updateTimeMapping_(i, this.syncController_.timelines[i.timeline], this.playlist_), i.cues.length ? i.timingInfo = { start: i.cues[0].startTime, end: i.cues[i.cues.length - 1].endTime } : i.timingInfo = { start: i.startOfSegment, end: i.startOfSegment + i.duration }, i.isSyncRequest) return this.trigger("syncinfoupdate"), this.pendingSegment_ = null, void (this.state = "READY"); i.byteLength = i.bytes.byteLength, this.mediaSecondsLoaded += r.duration, i.cues.forEach((e => { this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new (Un().VTTCue)(e.startTime, e.endTime, e.text) : e) })), function (e) { const t = e.cues; if (t) for (let n = 0; n < t.length; n++) { const i = []; let r = 0; for (let e = 0; e < t.length; e++)t[n].startTime === t[e].startTime && t[n].endTime === t[e].endTime && t[n].text === t[e].text && (r++, r > 1 && i.push(t[e])); i.length && i.forEach((t => e.removeCue(t))) } }(this.subtitlesTrack_), this.handleAppendsDone_() } handleData_() { } updateTimingInfoEnd_() { } parseVTTCues_(e) { let t, n = !1; if ("function" !== typeof Un().WebVTT) throw new qh; "function" === typeof Un().TextDecoder ? t = new (Un().TextDecoder)("utf8") : (t = Un().WebVTT.StringDecoder(), n = !0); const i = new (Un().WebVTT.Parser)(Un(), Un().vttjs, t); if (e.cues = [], e.timestampmap = { MPEGTS: 0, LOCAL: 0 }, i.oncue = e.cues.push.bind(e.cues), i.ontimestampmap = t => { e.timestampmap = t }, i.onparsingerror = e => { au.log.warn("Error encountered when parsing cues: " + e.message) }, e.segment.map) { let t = e.segment.map.bytes; n && (t = Vh(t)), i.parse(t) } let r = e.bytes; n && (r = Vh(r)), i.parse(r), i.flush() } updateTimeMapping_(e, t, n) { const i = e.segment; if (!t) return; if (!e.cues.length) return void (i.empty = !0); const r = e.timestampmap, s = r.MPEGTS / ss.ONE_SECOND_IN_TS - r.LOCAL + t.mapping; if (e.cues.forEach((e => { e.startTime += s, e.endTime += s })), !n.syncInfo) { const t = e.cues[0].startTime, r = e.cues[e.cues.length - 1].startTime; n.syncInfo = { mediaSequence: n.mediaSequence + e.mediaIndex, time: Math.min(t, r - i.duration) } } } } const Xh = function (e, t) { const n = e.cues; for (let i = 0; i < n.length; i++) { const e = n[i]; if (t >= e.adStartTime && t <= e.adEndTime) return e } return null }, Kh = [{ name: "VOD", run: (e, t, n, i, r) => { if (n !== 1 / 0) { return { time: 0, segmentIndex: 0, partIndex: null } } return null } }, { name: "ProgramDateTime", run: (e, t, n, i, r) => { if (!Object.keys(e.timelineToDatetimeMappings).length) return null; let s = null, a = null; const o = Cu(t); r = r || 0; for (let l = 0; l < o.length; l++) { const n = o[t.endList || 0 === r ? l : o.length - (l + 1)], i = n.segment, c = e.timelineToDatetimeMappings[i.timeline]; if (!c || !i.dateTimeObject) continue; let u = i.dateTimeObject.getTime() / 1e3 + c; if (i.parts && "number" === typeof n.partIndex) for (let e = 0; e < n.partIndex; e++)u += i.parts[e].duration; const d = Math.abs(r - u); if (null !== a && (0 === d || a < d)) break; a = d, s = { time: u, segmentIndex: n.segmentIndex, partIndex: n.partIndex } } return s } }, { name: "Segment", run: (e, t, n, i, r) => { let s = null, a = null; r = r || 0; const o = Cu(t); for (let l = 0; l < o.length; l++) { const e = o[t.endList || 0 === r ? l : o.length - (l + 1)], n = e.segment, c = e.part && e.part.start || n && n.start; if (n.timeline === i && "undefined" !== typeof c) { const t = Math.abs(r - c); if (null !== a && a < t) break; (!s || null === a || a >= t) && (a = t, s = { time: c, segmentIndex: e.segmentIndex, partIndex: e.partIndex }) } } return s } }, { name: "Discontinuity", run: (e, t, n, i, r) => { let s = null; if (r = r || 0, t.discontinuityStarts && t.discontinuityStarts.length) { let n = null; for (let i = 0; i < t.discontinuityStarts.length; i++) { const a = t.discontinuityStarts[i], o = t.discontinuitySequence + i + 1, l = e.discontinuities[o]; if (l) { const e = Math.abs(r - l.time); if (null !== n && n < e) break; (!s || null === n || n >= e) && (n = e, s = { time: l.time, segmentIndex: a, partIndex: null }) } } } return s } }, { name: "Playlist", run: (e, t, n, i, r) => { if (t.syncInfo) { return { time: t.syncInfo.time, segmentIndex: t.syncInfo.mediaSequence - t.mediaSequence, partIndex: null } } return null } }]; class $h extends au.EventTarget { constructor() { super(), this.timelines = [], this.discontinuities = [], this.timelineToDatetimeMappings = {}, this.logger_ = fu("SyncController") } getSyncPoint(e, t, n, i) { const r = this.runStrategies_(e, t, n, i); return r.length ? this.selectSyncPoint_(r, { key: "time", value: i }) : null } getExpiredTime(e, t) { if (!e || !e.segments) return null; const n = this.runStrategies_(e, t, e.discontinuitySequence, 0); if (!n.length) return null; const i = this.selectSyncPoint_(n, { key: "segmentIndex", value: 0 }); return i.segmentIndex > 0 && (i.time *= -1), Math.abs(i.time + Nu({ defaultDuration: e.targetDuration, durationList: e.segments, startIndex: i.segmentIndex, endIndex: 0 })) } runStrategies_(e, t, n, i) { const r = []; for (let s = 0; s < Kh.length; s++) { const a = Kh[s], o = a.run(this, e, t, n, i); o && (o.strategy = a.name, r.push({ strategy: a.name, syncPoint: o })) } return r } selectSyncPoint_(e, t) { let n = e[0].syncPoint, i = Math.abs(e[0].syncPoint[t.key] - t.value), r = e[0].strategy; for (let s = 1; s < e.length; s++) { const a = Math.abs(e[s].syncPoint[t.key] - t.value); a < i && (i = a, n = e[s].syncPoint, r = e[s].strategy) } return this.logger_("syncPoint for [".concat(t.key, ": ").concat(t.value, "] chosen with strategy") + " [".concat(r, "]: [time:").concat(n.time, ",") + " segmentIndex:".concat(n.segmentIndex) + ("number" === typeof n.partIndex ? ",partIndex:".concat(n.partIndex) : "") + "]"), n } saveExpiredSegmentInfo(e, t) { const n = t.mediaSequence - e.mediaSequence; if (n > 86400) au.log.warn("Not saving expired segment info. Media sequence gap ".concat(n, " is too large.")); else for (let i = n - 1; i >= 0; i--) { const n = e.segments[i]; if (n && "undefined" !== typeof n.start) { t.syncInfo = { mediaSequence: e.mediaSequence + i, time: n.start }, this.logger_("playlist refresh sync: [time:".concat(t.syncInfo.time, ",") + " mediaSequence: ".concat(t.syncInfo.mediaSequence, "]")), this.trigger("syncinfoupdate"); break } } } setDateTimeMappingForStart(e) { if (this.timelineToDatetimeMappings = {}, e.segments && e.segments.length && e.segments[0].dateTimeObject) { const t = e.segments[0], n = t.dateTimeObject.getTime() / 1e3; this.timelineToDatetimeMappings[t.timeline] = -n } } saveSegmentTimingInfo(e) { let { segmentInfo: t, shouldSaveTimelineMapping: n } = e; const i = this.calculateSegmentTimeMapping_(t, t.timingInfo, n), r = t.segment; i && (this.saveDiscontinuitySyncInfo_(t), t.playlist.syncInfo || (t.playlist.syncInfo = { mediaSequence: t.playlist.mediaSequence + t.mediaIndex, time: r.start })); const s = r.dateTimeObject; r.discontinuity && n && s && (this.timelineToDatetimeMappings[r.timeline] = -s.getTime() / 1e3) } timestampOffsetForTimeline(e) { return "undefined" === typeof this.timelines[e] ? null : this.timelines[e].time } mappingForTimeline(e) { return "undefined" === typeof this.timelines[e] ? null : this.timelines[e].mapping } calculateSegmentTimeMapping_(e, t, n) { const i = e.segment, r = e.part; let s, a, o = this.timelines[e.timeline]; if ("number" === typeof e.timestampOffset) o = { time: e.startOfSegment, mapping: e.startOfSegment - t.start }, n && (this.timelines[e.timeline] = o, this.trigger("timestampoffset"), this.logger_("time mapping for timeline ".concat(e.timeline, ": ") + "[time: ".concat(o.time, "] [mapping: ").concat(o.mapping, "]"))), s = e.startOfSegment, a = t.end + o.mapping; else { if (!o) return !1; s = t.start + o.mapping, a = t.end + o.mapping } return r && (r.start = s, r.end = a), (!i.start || s < i.start) && (i.start = s), i.end = a, !0 } saveDiscontinuitySyncInfo_(e) { const t = e.playlist, n = e.segment; if (n.discontinuity) this.discontinuities[n.timeline] = { time: n.start, accuracy: 0 }; else if (t.discontinuityStarts && t.discontinuityStarts.length) for (let i = 0; i < t.discontinuityStarts.length; i++) { const r = t.discontinuityStarts[i], s = t.discontinuitySequence + i + 1, a = r - e.mediaIndex, o = Math.abs(a); if (!this.discontinuities[s] || this.discontinuities[s].accuracy > o) { let i; i = a < 0 ? n.start - Nu({ defaultDuration: t.targetDuration, durationList: t.segments, startIndex: e.mediaIndex, endIndex: r }) : n.end + Nu({ defaultDuration: t.targetDuration, durationList: t.segments, startIndex: e.mediaIndex + 1, endIndex: r }), this.discontinuities[s] = { time: i, accuracy: o } } } } dispose() { this.trigger("dispose"), this.off() } } class Yh extends au.EventTarget { constructor() { super(), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {} } clearPendingTimelineChange(e) { this.pendingTimelineChanges_[e] = null, this.trigger("pendingtimelinechange") } pendingTimelineChange(e) { let { type: t, from: n, to: i } = e; return "number" === typeof n && "number" === typeof i && (this.pendingTimelineChanges_[t] = { type: t, from: n, to: i }, this.trigger("pendingtimelinechange")), this.pendingTimelineChanges_[t] } lastTimelineChange(e) { let { type: t, from: n, to: i } = e; return "number" === typeof n && "number" === typeof i && (this.lastTimelineChanges_[t] = { type: t, from: n, to: i }, delete this.pendingTimelineChanges_[t], this.trigger("timelinechange")), this.lastTimelineChanges_[t] } dispose() { this.trigger("dispose"), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {}, this.off() } } const Qh = Id(Ld((function () { var e = function () { function e() { this.listeners = {} } var t = e.prototype; return t.on = function (e, t) { this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t) }, t.off = function (e, t) { if (!this.listeners[e]) return !1; var n = this.listeners[e].indexOf(t); return this.listeners[e] = this.listeners[e].slice(0), this.listeners[e].splice(n, 1), n > -1 }, t.trigger = function (e) { var t = this.listeners[e]; if (t) if (2 === arguments.length) for (var n = t.length, i = 0; i < n; ++i)t[i].call(this, arguments[1]); else for (var r = Array.prototype.slice.call(arguments, 1), s = t.length, a = 0; a < s; ++a)t[a].apply(this, r) }, t.dispose = function () { this.listeners = {} }, t.pipe = function (e) { this.on("data", (function (t) { e.push(t) })) }, e }(); let t = null; class i { constructor(e) { let n, i, r; t || (t = function () { const e = [[[], [], [], [], []], [[], [], [], [], []]], t = e[0], n = e[1], i = t[4], r = n[4]; let s, a, o; const l = [], c = []; let u, d, h, p, f, m; for (s = 0; s < 256; s++)c[(l[s] = s << 1 ^ 283 * (s >> 7)) ^ s] = s; for (a = o = 0; !i[a]; a ^= u || 1, o = c[o] || 1)for (p = o ^ o << 1 ^ o << 2 ^ o << 3 ^ o << 4, p = p >> 8 ^ 255 & p ^ 99, i[a] = p, r[p] = a, h = l[d = l[u = l[a]]], m = 16843009 * h ^ 65537 * d ^ 257 * u ^ 16843008 * a, f = 257 * l[p] ^ 16843008 * p, s = 0; s < 4; s++)t[s][a] = f = f << 24 ^ f >>> 8, n[s][p] = m = m << 24 ^ m >>> 8; for (s = 0; s < 5; s++)t[s] = t[s].slice(0), n[s] = n[s].slice(0); return e }()), this._tables = [[t[0][0].slice(), t[0][1].slice(), t[0][2].slice(), t[0][3].slice(), t[0][4].slice()], [t[1][0].slice(), t[1][1].slice(), t[1][2].slice(), t[1][3].slice(), t[1][4].slice()]]; const s = this._tables[0][4], a = this._tables[1], o = e.length; let l = 1; if (4 !== o && 6 !== o && 8 !== o) throw new Error("Invalid aes key size"); const c = e.slice(0), u = []; for (this._key = [c, u], n = o; n < 4 * o + 28; n++)r = c[n - 1], (n % o === 0 || 8 === o && n % o === 4) && (r = s[r >>> 24] << 24 ^ s[r >> 16 & 255] << 16 ^ s[r >> 8 & 255] << 8 ^ s[255 & r], n % o === 0 && (r = r << 8 ^ r >>> 24 ^ l << 24, l = l << 1 ^ 283 * (l >> 7))), c[n] = c[n - o] ^ r; for (i = 0; n; i++, n--)r = c[3 & i ? n : n - 4], u[i] = n <= 4 || i < 4 ? r : a[0][s[r >>> 24]] ^ a[1][s[r >> 16 & 255]] ^ a[2][s[r >> 8 & 255]] ^ a[3][s[255 & r]] } decrypt(e, t, n, i, r, s) { const a = this._key[1]; let o, l, c, u = e ^ a[0], d = i ^ a[1], h = n ^ a[2], p = t ^ a[3]; const f = a.length / 4 - 2; let m, g = 4; const y = this._tables[1], v = y[0], b = y[1], _ = y[2], T = y[3], S = y[4]; for (m = 0; m < f; m++)o = v[u >>> 24] ^ b[d >> 16 & 255] ^ _[h >> 8 & 255] ^ T[255 & p] ^ a[g], l = v[d >>> 24] ^ b[h >> 16 & 255] ^ _[p >> 8 & 255] ^ T[255 & u] ^ a[g + 1], c = v[h >>> 24] ^ b[p >> 16 & 255] ^ _[u >> 8 & 255] ^ T[255 & d] ^ a[g + 2], p = v[p >>> 24] ^ b[u >> 16 & 255] ^ _[d >> 8 & 255] ^ T[255 & h] ^ a[g + 3], g += 4, u = o, d = l, h = c; for (m = 0; m < 4; m++)r[(3 & -m) + s] = S[u >>> 24] << 24 ^ S[d >> 16 & 255] << 16 ^ S[h >> 8 & 255] << 8 ^ S[255 & p] ^ a[g++], o = u, u = d, d = h, h = p, p = o } } class r extends e { constructor() { super(e), this.jobs = [], this.delay = 1, this.timeout_ = null } processJob_() { this.jobs.shift()(), this.jobs.length ? this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay) : this.timeout_ = null } push(e) { this.jobs.push(e), this.timeout_ || (this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay)) } } const s = function (e) { return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24 }; class a { constructor(e, t, n, i) { const o = a.STEP, l = new Int32Array(e.buffer), c = new Uint8Array(e.byteLength); let u = 0; for (this.asyncStream_ = new r, this.asyncStream_.push(this.decryptChunk_(l.subarray(u, u + o), t, n, c)), u = o; u < l.length; u += o)n = new Uint32Array([s(l[u - 4]), s(l[u - 3]), s(l[u - 2]), s(l[u - 1])]), this.asyncStream_.push(this.decryptChunk_(l.subarray(u, u + o), t, n, c)); this.asyncStream_.push((function () { var e; i(null, (e = c).subarray(0, e.byteLength - e[e.byteLength - 1])) })) } static get STEP() { return 32e3 } decryptChunk_(e, t, n, r) { return function () { const a = function (e, t, n) { const r = new Int32Array(e.buffer, e.byteOffset, e.byteLength >> 2), a = new i(Array.prototype.slice.call(t)), o = new Uint8Array(e.byteLength), l = new Int32Array(o.buffer); let c, u, d, h, p, f, m, g, y; for (c = n[0], u = n[1], d = n[2], h = n[3], y = 0; y < r.length; y += 4)p = s(r[y]), f = s(r[y + 1]), m = s(r[y + 2]), g = s(r[y + 3]), a.decrypt(p, f, m, g, l, y), l[y] = s(l[y] ^ c), l[y + 1] = s(l[y + 1] ^ u), l[y + 2] = s(l[y + 2] ^ d), l[y + 3] = s(l[y + 3] ^ h), c = p, u = f, d = m, h = g; return o }(e, t, n); r.set(a, e.byteOffset) } } } var o, l = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof window ? window : "undefined" !== typeof n.g ? n.g : "undefined" !== typeof self ? self : {}; o = "undefined" !== typeof window ? window : "undefined" !== typeof l ? l : "undefined" !== typeof self ? self : {}; var c = o.BigInt || Number; c("0x1"), c("0x100"), c("0x10000"), c("0x1000000"), c("0x100000000"), c("0x10000000000"), c("0x1000000000000"), c("0x100000000000000"), c("0x10000000000000000"), function () { var e = new Uint16Array([65484]), t = new Uint8Array(e.buffer, e.byteOffset, e.byteLength); 255 === t[0] || t[0] }(); const u = function (e) { const t = {}; return Object.keys(e).forEach((n => { const i = e[n]; var r; r = i, ("function" === ArrayBuffer.isView ? ArrayBuffer.isView(r) : r && r.buffer instanceof ArrayBuffer) ? t[n] = { bytes: i.buffer, byteOffset: i.byteOffset, byteLength: i.byteLength } : t[n] = i })), t }; self.onmessage = function (e) { const t = e.data, n = new Uint8Array(t.encrypted.bytes, t.encrypted.byteOffset, t.encrypted.byteLength), i = new Uint32Array(t.key.bytes, t.key.byteOffset, t.key.byteLength / 4), r = new Uint32Array(t.iv.bytes, t.iv.byteOffset, t.iv.byteLength / 4); new a(n, i, r, (function (e, n) { self.postMessage(u({ source: t.source, decrypted: n }), [n.buffer]) })) } }))); var Jh = Pd(Qh); const Zh = e => { let t = e.default ? "main" : "alternative"; return e.characteristics && e.characteristics.indexOf("public.accessibility.describes-video") >= 0 && (t = "main-desc"), t }, ep = (e, t) => { e.abort(), e.pause(), t && t.activePlaylistLoader && (t.activePlaylistLoader.pause(), t.activePlaylistLoader = null) }, tp = (e, t) => { t.activePlaylistLoader = e, e.load() }, np = { AUDIO: (e, t) => () => { const { segmentLoaders: { [e]: n }, mediaTypes: { [e]: i }, excludePlaylist: r } = t; ep(n, i); const s = i.activeTrack(), a = i.activeGroup(), o = (a.filter((e => e.default))[0] || a[0]).id, l = i.tracks[o]; if (s !== l) { au.log.warn("Problem encountered loading the alternate audio track.Switching back to default."); for (const e in i.tracks) i.tracks[e].enabled = i.tracks[e] === l; i.onTrackChanged() } else r({ error: { message: "Problem encountered loading the default audio track." } }) }, SUBTITLES: (e, t) => () => { const { segmentLoaders: { [e]: n }, mediaTypes: { [e]: i } } = t; au.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track."), ep(n, i); const r = i.activeTrack(); r && (r.mode = "disabled"), i.onTrackChanged() } }, ip = { AUDIO: (e, t, n) => { if (!t) return; const { tech: i, requestOptions: r, segmentLoaders: { [e]: s } } = n; t.on("loadedmetadata", (() => { const e = t.media(); s.playlist(e, r), (!i.paused() || e.endList && "none" !== i.preload()) && s.load() })), t.on("loadedplaylist", (() => { s.playlist(t.media(), r), i.paused() || s.load() })), t.on("error", np[e](e, n)) }, SUBTITLES: (e, t, n) => { const { tech: i, requestOptions: r, segmentLoaders: { [e]: s }, mediaTypes: { [e]: a } } = n; t.on("loadedmetadata", (() => { const e = t.media(); s.playlist(e, r), s.track(a.activeTrack()), (!i.paused() || e.endList && "none" !== i.preload()) && s.load() })), t.on("loadedplaylist", (() => { s.playlist(t.media(), r), i.paused() || s.load() })), t.on("error", np[e](e, n)) } }, rp = { AUDIO: (e, t) => { const { vhs: n, sourceType: i, segmentLoaders: { [e]: r }, requestOptions: s, main: { mediaGroups: a }, mediaTypes: { [e]: { groups: o, tracks: l, logger_: c } }, mainPlaylistLoader: u } = t, d = Hu(u.main); a[e] && 0 !== Object.keys(a[e]).length || (a[e] = { main: { default: { default: !0 } } }, d && (a[e].main.default.playlists = u.main.playlists)); for (const h in a[e]) { o[h] || (o[h] = []); for (const r in a[e][h]) { let p, f = a[e][h][r]; if (d ? (c("AUDIO group '".concat(h, "' label '").concat(r, "' is a main playlist")), f.isMainPlaylist = !0, p = null) : p = "vhs-json" === i && f.playlists ? new id(f.playlists[0], n, s) : f.resolvedUri ? new id(f.resolvedUri, n, s) : f.playlists && "dash" === i ? new kd(f.playlists[0], n, s, u) : null, f = mu({ id: r, playlistLoader: p }, f), ip[e](e, f.playlistLoader, t), o[h].push(f), "undefined" === typeof l[r]) { const e = new au.AudioTrack({ id: r, kind: Zh(f), enabled: !1, language: f.language, default: f.default, label: r }); l[r] = e } } } r.on("error", np[e](e, t)) }, SUBTITLES: (e, t) => { const { tech: n, vhs: i, sourceType: r, segmentLoaders: { [e]: s }, requestOptions: a, main: { mediaGroups: o }, mediaTypes: { [e]: { groups: l, tracks: c } }, mainPlaylistLoader: u } = t; for (const d in o[e]) { l[d] || (l[d] = []); for (const s in o[e][d]) { if (o[e][d][s].forced) continue; let h, p = o[e][d][s]; if ("hls" === r) h = new id(p.resolvedUri, i, a); else if ("dash" === r) { if (!p.playlists.filter((e => e.excludeUntil !== 1 / 0)).length) return; h = new kd(p.playlists[0], i, a, u) } else "vhs-json" === r && (h = new id(p.playlists ? p.playlists[0] : p.resolvedUri, i, a)); if (p = mu({ id: s, playlistLoader: h }, p), ip[e](e, p.playlistLoader, t), l[d].push(p), "undefined" === typeof c[s]) { const e = n.addRemoteTextTrack({ id: s, kind: "subtitles", default: p.default && p.autoselect, language: p.language, label: s }, !1).track; c[s] = e } } } s.on("error", np[e](e, t)) }, "CLOSED-CAPTIONS": (e, t) => { const { tech: n, main: { mediaGroups: i }, mediaTypes: { [e]: { groups: r, tracks: s } } } = t; for (const a in i[e]) { r[a] || (r[a] = []); for (const t in i[e][a]) { const o = i[e][a][t]; if (!/^(?:CC|SERVICE)/.test(o.instreamId)) continue; const l = n.options_.vhs && n.options_.vhs.captionServices || {}; let c = { label: t, language: o.language, instreamId: o.instreamId, default: o.default && o.autoselect }; if (l[c.instreamId] && (c = mu(c, l[c.instreamId])), void 0 === c.default && delete c.default, r[a].push(mu({ id: t }, o)), "undefined" === typeof s[t]) { const e = n.addRemoteTextTrack({ id: c.instreamId, kind: "captions", default: c.default, language: c.language, label: c.label }, !1).track; s[t] = e } } } } }, sp = (e, t) => { for (let n = 0; n < e.length; n++) { if (Fu(t, e[n])) return !0; if (e[n].playlists && sp(e[n].playlists, t)) return !0 } return !1 }, ap = { AUDIO: (e, t) => () => { const { mediaTypes: { [e]: { tracks: n } } } = t; for (const e in n) if (n[e].enabled) return n[e]; return null }, SUBTITLES: (e, t) => () => { const { mediaTypes: { [e]: { tracks: n } } } = t; for (const e in n) if ("showing" === n[e].mode || "hidden" === n[e].mode) return n[e]; return null } }, op = e => { ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((t => { rp[t](t, e) })); const { mediaTypes: t, mainPlaylistLoader: n, tech: i, vhs: r, segmentLoaders: { AUDIO: s, main: a } } = e;["AUDIO", "SUBTITLES"].forEach((n => { t[n].activeGroup = ((e, t) => n => { const { mainPlaylistLoader: i, mediaTypes: { [e]: { groups: r } } } = t, s = i.media(); if (!s) return null; let a = null; s.attributes[e] && (a = r[s.attributes[e]]); const o = Object.keys(r); if (!a) if ("AUDIO" === e && o.length > 1 && Hu(t.main)) for (let e = 0; e < o.length; e++) { const t = r[o[e]]; if (sp(t, s)) { a = t; break } } else r.main ? a = r.main : 1 === o.length && (a = r[o[0]]); return "undefined" === typeof n ? a : null !== n && a && a.filter((e => e.id === n.id))[0] || null })(n, e), t[n].activeTrack = ap[n](n, e), t[n].onGroupChanged = ((e, t) => () => { const { segmentLoaders: { [e]: n, main: i }, mediaTypes: { [e]: r } } = t, s = r.activeTrack(), a = r.getActiveGroup(), o = r.activePlaylistLoader, l = r.lastGroup_; a && l && a.id === l.id || (r.lastGroup_ = a, r.lastTrack_ = s, ep(n, r), a && !a.isMainPlaylist && (a.playlistLoader ? (n.resyncLoader(), tp(a.playlistLoader, r)) : o && i.resetEverything())) })(n, e), t[n].onGroupChanging = ((e, t) => () => { const { segmentLoaders: { [e]: n }, mediaTypes: { [e]: i } } = t; i.lastGroup_ = null, n.abort(), n.pause() })(n, e), t[n].onTrackChanged = ((e, t) => () => { const { mainPlaylistLoader: n, segmentLoaders: { [e]: i, main: r }, mediaTypes: { [e]: s } } = t, a = s.activeTrack(), o = s.getActiveGroup(), l = s.activePlaylistLoader, c = s.lastTrack_; if ((!c || !a || c.id !== a.id) && (s.lastGroup_ = o, s.lastTrack_ = a, ep(i, s), o)) { if (o.isMainPlaylist) { if (!a || !c || a.id === c.id) return; const e = t.vhs.playlistController_, i = e.selectPlaylist(); if (e.media() === i) return; return s.logger_("track change. Switching main audio from ".concat(c.id, " to ").concat(a.id)), n.pause(), r.resetEverything(), void e.fastQualityChange_(i) } if ("AUDIO" === e) { if (!o.playlistLoader) return r.setAudio(!0), void r.resetEverything(); i.setAudio(!0), r.setAudio(!1) } l !== o.playlistLoader ? (i.track && i.track(a), i.resetEverything(), tp(o.playlistLoader, s)) : tp(o.playlistLoader, s) } })(n, e), t[n].getActiveGroup = ((e, t) => { let { mediaTypes: n } = t; return () => { const t = n[e].activeTrack(); return t ? n[e].activeGroup(t) : null } })(n, e) })); const o = t.AUDIO.activeGroup(); if (o) { const e = (o.filter((e => e.default))[0] || o[0]).id; t.AUDIO.tracks[e].enabled = !0, t.AUDIO.onGroupChanged(), t.AUDIO.onTrackChanged(); t.AUDIO.getActiveGroup().playlistLoader ? (a.setAudio(!1), s.setAudio(!0)) : a.setAudio(!0) } n.on("mediachange", (() => { ["AUDIO", "SUBTITLES"].forEach((e => t[e].onGroupChanged())) })), n.on("mediachanging", (() => { ["AUDIO", "SUBTITLES"].forEach((e => t[e].onGroupChanging())) })); const l = () => { t.AUDIO.onTrackChanged(), i.trigger({ type: "usage", name: "vhs-audio-change" }) }; i.audioTracks().addEventListener("change", l), i.remoteTextTracks().addEventListener("change", t.SUBTITLES.onTrackChanged), r.on("dispose", (() => { i.audioTracks().removeEventListener("change", l), i.remoteTextTracks().removeEventListener("change", t.SUBTITLES.onTrackChanged) })), i.clearTracks("audio"); for (const c in t.AUDIO.tracks) i.audioTracks().addTrack(t.AUDIO.tracks[c]) }; let lp; const cp = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"], up = function (e) { return this.audioSegmentLoader_[e] + this.mainSegmentLoader_[e] }; class dp extends au.EventTarget { constructor(e) { super(); const { src: t, withCredentials: n, tech: i, bandwidth: r, externVhs: s, useCueTags: a, playlistExclusionDuration: o, enableLowInitialPlaylist: l, sourceType: c, cacheEncryptionKeys: u, bufferBasedABR: d, leastPixelDiffSelector: h, captionServices: p } = e; if (!t) throw new Error("A non-empty playlist URL or JSON manifest string is required"); let { maxPlaylistRetries: f } = e; null !== f && "undefined" !== typeof f || (f = 1 / 0), lp = s, this.bufferBasedABR = Boolean(d), this.leastPixelDiffSelector = Boolean(h), this.withCredentials = n, this.tech_ = i, this.vhs_ = i.vhs, this.sourceType_ = c, this.useCueTags_ = a, this.playlistExclusionDuration = o, this.maxPlaylistRetries = f, this.enableLowInitialPlaylist = l, this.useCueTags_ && (this.cueTagsTrack_ = this.tech_.addTextTrack("metadata", "ad-cues"), this.cueTagsTrack_.inBandMetadataTrackDispatchType = ""), this.requestOptions_ = { withCredentials: n, maxPlaylistRetries: f, timeout: null }, this.on("error", this.pauseLoading), this.mediaTypes_ = (() => { const e = {}; return ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((t => { e[t] = { groups: {}, tracks: {}, activePlaylistLoader: null, activeGroup: wh, activeTrack: wh, getActiveGroup: wh, onGroupChanged: wh, onTrackChanged: wh, lastTrack_: null, logger_: fu("MediaGroups[".concat(t, "]")) } })), e })(), this.mediaSource = new (Un().MediaSource), this.handleDurationChange_ = this.handleDurationChange_.bind(this), this.handleSourceOpen_ = this.handleSourceOpen_.bind(this), this.handleSourceEnded_ = this.handleSourceEnded_.bind(this), this.mediaSource.addEventListener("durationchange", this.handleDurationChange_), this.mediaSource.addEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.addEventListener("sourceended", this.handleSourceEnded_), this.seekable_ = gu(), this.hasPlayed_ = !1, this.syncController_ = new $h(e), this.segmentMetadataTrack_ = i.addRemoteTextTrack({ kind: "metadata", label: "segment-metadata" }, !1).track, this.decrypter_ = new Jh, this.sourceUpdater_ = new Hh(this.mediaSource), this.inbandTextTracks_ = {}, this.timelineChangeController_ = new Yh; const m = { vhs: this.vhs_, parse708captions: e.parse708captions, useDtsForTimestampOffset: e.useDtsForTimestampOffset, captionServices: p, mediaSource: this.mediaSource, currentTime: this.tech_.currentTime.bind(this.tech_), seekable: () => this.seekable(), seeking: () => this.tech_.seeking(), duration: () => this.duration(), hasPlayed: () => this.hasPlayed_, goalBufferLength: () => this.goalBufferLength(), bandwidth: r, syncController: this.syncController_, decrypter: this.decrypter_, sourceType: this.sourceType_, inbandTextTracks: this.inbandTextTracks_, cacheEncryptionKeys: u, sourceUpdater: this.sourceUpdater_, timelineChangeController: this.timelineChangeController_, exactManifestTimings: e.exactManifestTimings }; this.mainPlaylistLoader_ = "dash" === this.sourceType_ ? new kd(t, this.vhs_, this.requestOptions_) : new id(t, this.vhs_, this.requestOptions_), this.setupMainPlaylistLoaderListeners_(), this.mainSegmentLoader_ = new Sh(mu(m, { segmentMetadataTrack: this.segmentMetadataTrack_, loaderType: "main" }), e), this.audioSegmentLoader_ = new Sh(mu(m, { loaderType: "audio" }), e), this.subtitleSegmentLoader_ = new Gh(mu(m, { loaderType: "vtt", featuresNativeTextTracks: this.tech_.featuresNativeTextTracks, loadVttJs: () => new Promise(((e, t) => { function n() { i.off("vttjserror", r), e() } function r() { i.off("vttjsloaded", n), t() } i.one("vttjsloaded", n), i.one("vttjserror", r), i.addWebVttScript_() })) }), e), this.setupSegmentLoaderListeners_(), this.bufferBasedABR && (this.mainPlaylistLoader_.one("loadedplaylist", (() => this.startABRTimer_())), this.tech_.on("pause", (() => this.stopABRTimer_())), this.tech_.on("play", (() => this.startABRTimer_()))), cp.forEach((e => { this[e + "_"] = up.bind(this, e) })), this.logger_ = fu("pc"), this.triggeredFmp4Usage = !1, "none" === this.tech_.preload() ? (this.loadOnPlay_ = () => { this.loadOnPlay_ = null, this.mainPlaylistLoader_.load() }, this.tech_.one("play", this.loadOnPlay_)) : this.mainPlaylistLoader_.load(), this.timeToLoadedData__ = -1, this.mainAppendsToLoadedData__ = -1, this.audioAppendsToLoadedData__ = -1; const g = "none" === this.tech_.preload() ? "play" : "loadstart"; this.tech_.one(g, (() => { const e = Date.now(); this.tech_.one("loadeddata", (() => { this.timeToLoadedData__ = Date.now() - e, this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends, this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends })) })) } mainAppendsToLoadedData_() { return this.mainAppendsToLoadedData__ } audioAppendsToLoadedData_() { return this.audioAppendsToLoadedData__ } appendsToLoadedData_() { const e = this.mainAppendsToLoadedData_(), t = this.audioAppendsToLoadedData_(); return -1 === e || -1 === t ? -1 : e + t } timeToLoadedData_() { return this.timeToLoadedData__ } checkABR_() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "abr"; const t = this.selectPlaylist(); t && this.shouldSwitchToMedia_(t) && this.switchMedia_(t, e) } switchMedia_(e, t, n) { const i = this.media(), r = i && (i.id || i.uri), s = e.id || e.uri; r && r !== s && (this.logger_("switch media ".concat(r, " -> ").concat(s, " from ").concat(t)), this.tech_.trigger({ type: "usage", name: "vhs-rendition-change-".concat(t) })), this.mainPlaylistLoader_.media(e, n) } startABRTimer_() { this.stopABRTimer_(), this.abrTimer_ = Un().setInterval((() => this.checkABR_()), 250) } stopABRTimer_() { this.tech_.scrubbing && this.tech_.scrubbing() || (Un().clearInterval(this.abrTimer_), this.abrTimer_ = null) } getAudioTrackPlaylists_() { const e = this.main(), t = e && e.playlists || []; if (!e || !e.mediaGroups || !e.mediaGroups.AUDIO) return t; const n = e.mediaGroups.AUDIO, i = Object.keys(n); let r; if (Object.keys(this.mediaTypes_.AUDIO.groups).length) r = this.mediaTypes_.AUDIO.activeTrack(); else { const e = n.main || i.length && n[i[0]]; for (const t in e) if (e[t].default) { r = { label: t }; break } } if (!r) return t; const s = []; for (const a in n) if (n[a][r.label]) { const t = n[a][r.label]; if (t.playlists && t.playlists.length) s.push.apply(s, t.playlists); else if (t.uri) s.push(t); else if (e.playlists.length) for (let n = 0; n < e.playlists.length; n++) { const t = e.playlists[n]; t.attributes && t.attributes.AUDIO && t.attributes.AUDIO === a && s.push(t) } } return s.length ? s : t } setupMainPlaylistLoaderListeners_() { this.mainPlaylistLoader_.on("loadedmetadata", (() => { const e = this.mainPlaylistLoader_.media(), t = 1.5 * e.targetDuration * 1e3; Bu(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = t, e.endList && "none" !== this.tech_.preload() && (this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.mainSegmentLoader_.load()), op({ sourceType: this.sourceType_, segmentLoaders: { AUDIO: this.audioSegmentLoader_, SUBTITLES: this.subtitleSegmentLoader_, main: this.mainSegmentLoader_ }, tech: this.tech_, requestOptions: this.requestOptions_, mainPlaylistLoader: this.mainPlaylistLoader_, vhs: this.vhs_, main: this.main(), mediaTypes: this.mediaTypes_, excludePlaylist: this.excludePlaylist.bind(this) }), this.triggerPresenceUsage_(this.main(), e), this.setupFirstPlay(), !this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media() ? this.trigger("selectedinitialmedia") : this.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", (() => { this.trigger("selectedinitialmedia") })) })), this.mainPlaylistLoader_.on("loadedplaylist", (() => { this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_); let e = this.mainPlaylistLoader_.media(); if (!e) { let t; if (this.excludeUnsupportedVariants_(), this.enableLowInitialPlaylist && (t = this.selectInitialPlaylist()), t || (t = this.selectPlaylist()), !t || !this.shouldSwitchToMedia_(t)) return; this.initialMedia_ = t, this.switchMedia_(this.initialMedia_, "initial"); if (!("vhs-json" === this.sourceType_ && this.initialMedia_.segments)) return; e = this.initialMedia_ } this.handleUpdatedMediaPlaylist(e) })), this.mainPlaylistLoader_.on("error", (() => { const e = this.mainPlaylistLoader_.error; this.excludePlaylist({ playlistToExclude: e.playlist, error: e }) })), this.mainPlaylistLoader_.on("mediachanging", (() => { this.mainSegmentLoader_.abort(), this.mainSegmentLoader_.pause() })), this.mainPlaylistLoader_.on("mediachange", (() => { const e = this.mainPlaylistLoader_.media(), t = 1.5 * e.targetDuration * 1e3; Bu(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = t, this.mainPlaylistLoader_.load(), this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.mainSegmentLoader_.load(), this.tech_.trigger({ type: "mediachange", bubbles: !0 }) })), this.mainPlaylistLoader_.on("playlistunchanged", (() => { const e = this.mainPlaylistLoader_.media(); if ("playlist-unchanged" === e.lastExcludeReason_) return; this.stuckAtPlaylistEnd_(e) && (this.excludePlaylist({ error: { message: "Playlist no longer updating.", reason: "playlist-unchanged" } }), this.tech_.trigger("playliststuck")) })), this.mainPlaylistLoader_.on("renditiondisabled", (() => { this.tech_.trigger({ type: "usage", name: "vhs-rendition-disabled" }) })), this.mainPlaylistLoader_.on("renditionenabled", (() => { this.tech_.trigger({ type: "usage", name: "vhs-rendition-enabled" }) })) } handleUpdatedMediaPlaylist(e) { this.useCueTags_ && this.updateAdCues_(e), this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.updateDuration(!e.endList), this.tech_.paused() || (this.mainSegmentLoader_.load(), this.audioSegmentLoader_ && this.audioSegmentLoader_.load()) } triggerPresenceUsage_(e, t) { const n = e.mediaGroups || {}; let i = !0; const r = Object.keys(n.AUDIO); for (const s in n.AUDIO) for (const e in n.AUDIO[s]) { n.AUDIO[s][e].uri || (i = !1) } i && this.tech_.trigger({ type: "usage", name: "vhs-demuxed" }), Object.keys(n.SUBTITLES).length && this.tech_.trigger({ type: "usage", name: "vhs-webvtt" }), lp.Playlist.isAes(t) && this.tech_.trigger({ type: "usage", name: "vhs-aes" }), r.length && Object.keys(n.AUDIO[r[0]]).length > 1 && this.tech_.trigger({ type: "usage", name: "vhs-alternate-audio" }), this.useCueTags_ && this.tech_.trigger({ type: "usage", name: "vhs-playlist-cue-tags" }) } shouldSwitchToMedia_(e) { const t = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_, n = this.tech_.currentTime(), i = this.bufferLowWaterLine(), r = this.bufferHighWaterLine(); return function (e) { let { currentPlaylist: t, buffered: n, currentTime: i, nextPlaylist: r, bufferLowWaterLine: s, bufferHighWaterLine: a, duration: o, bufferBasedABR: l, log: c } = e; if (!r) return au.log.warn("We received no playlist to switch to. Please check your stream."), !1; const u = "allowing switch ".concat(t && t.id || "null", " -> ").concat(r.id); if (!t) return c("".concat(u, " as current playlist is not set")), !0; if (r.id === t.id) return !1; const d = Boolean(_u(n, i).length); if (!t.endList) return d || "number" !== typeof t.partTargetDuration ? (c("".concat(u, " as current playlist is live")), !0) : (c("not ".concat(u, " as current playlist is live llhls, but currentTime isn't in buffered.")), !1); const h = ku(n, i), p = l ? Ed.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Ed.MAX_BUFFER_LOW_WATER_LINE; if (o < p) return c("".concat(u, " as duration < max low water line (").concat(o, " < ").concat(p, ")")), !0; const f = r.attributes.BANDWIDTH, m = t.attributes.BANDWIDTH; if (f < m && (!l || h < a)) { let e = "".concat(u, " as next bandwidth < current bandwidth (").concat(f, " < ").concat(m, ")"); return l && (e += " and forwardBuffer < bufferHighWaterLine (".concat(h, " < ").concat(a, ")")), c(e), !0 } if ((!l || f > m) && h >= s) { let e = "".concat(u, " as forwardBuffer >= bufferLowWaterLine (").concat(h, " >= ").concat(s, ")"); return l && (e += " and next bandwidth > current bandwidth (".concat(f, " > ").concat(m, ")")), c(e), !0 } return c("not ".concat(u, " as no switching criteria met")), !1 }({ buffered: this.tech_.buffered(), currentTime: n, currentPlaylist: t, nextPlaylist: e, bufferLowWaterLine: i, bufferHighWaterLine: r, duration: this.duration(), bufferBasedABR: this.bufferBasedABR, log: this.logger_ }) } setupSegmentLoaderListeners_() { this.mainSegmentLoader_.on("bandwidthupdate", (() => { this.checkABR_("bandwidthupdate"), this.tech_.trigger("bandwidthupdate") })), this.mainSegmentLoader_.on("timeout", (() => { this.bufferBasedABR && this.mainSegmentLoader_.load() })), this.bufferBasedABR || this.mainSegmentLoader_.on("progress", (() => { this.trigger("progress") })), this.mainSegmentLoader_.on("error", (() => { const e = this.mainSegmentLoader_.error(); this.excludePlaylist({ playlistToExclude: e.playlist, error: e }) })), this.mainSegmentLoader_.on("appenderror", (() => { this.error = this.mainSegmentLoader_.error_, this.trigger("error") })), this.mainSegmentLoader_.on("syncinfoupdate", (() => { this.onSyncInfoUpdate_() })), this.mainSegmentLoader_.on("timestampoffset", (() => { this.tech_.trigger({ type: "usage", name: "vhs-timestamp-offset" }) })), this.audioSegmentLoader_.on("syncinfoupdate", (() => { this.onSyncInfoUpdate_() })), this.audioSegmentLoader_.on("appenderror", (() => { this.error = this.audioSegmentLoader_.error_, this.trigger("error") })), this.mainSegmentLoader_.on("ended", (() => { this.logger_("main segment loader ended"), this.onEndOfStream() })), this.mainSegmentLoader_.on("earlyabort", (e => { this.bufferBasedABR || (this.delegateLoaders_("all", ["abort"]), this.excludePlaylist({ error: { message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering." }, playlistExclusionDuration: 120 })) })); const e = () => { if (!this.sourceUpdater_.hasCreatedSourceBuffers()) return this.tryToCreateSourceBuffers_(); const e = this.getCodecsOrExclude_(); e && this.sourceUpdater_.addOrChangeSourceBuffers(e) }; this.mainSegmentLoader_.on("trackinfo", e), this.audioSegmentLoader_.on("trackinfo", e), this.mainSegmentLoader_.on("fmp4", (() => { this.triggeredFmp4Usage || (this.tech_.trigger({ type: "usage", name: "vhs-fmp4" }), this.triggeredFmp4Usage = !0) })), this.audioSegmentLoader_.on("fmp4", (() => { this.triggeredFmp4Usage || (this.tech_.trigger({ type: "usage", name: "vhs-fmp4" }), this.triggeredFmp4Usage = !0) })), this.audioSegmentLoader_.on("ended", (() => { this.logger_("audioSegmentLoader ended"), this.onEndOfStream() })) } mediaSecondsLoaded_() { return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded) } load() { this.mainSegmentLoader_.load(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.load(), this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.load() } fastQualityChange_() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.selectPlaylist(); e !== this.mainPlaylistLoader_.media() ? (this.switchMedia_(e, "fast-quality"), this.mainSegmentLoader_.resetEverything((() => { au.browser.IE_VERSION || au.browser.IS_EDGE ? this.tech_.setCurrentTime(this.tech_.currentTime() + .04) : this.tech_.setCurrentTime(this.tech_.currentTime()) }))) : this.logger_("skipping fastQualityChange because new media is same as old") } play() { if (this.setupFirstPlay()) return; this.tech_.ended() && this.tech_.setCurrentTime(0), this.hasPlayed_ && this.load(); const e = this.tech_.seekable(); return this.tech_.duration() === 1 / 0 && this.tech_.currentTime() < e.start(0) ? this.tech_.setCurrentTime(e.end(e.length - 1)) : void 0 } setupFirstPlay() { const e = this.mainPlaylistLoader_.media(); if (!e || this.tech_.paused() || this.hasPlayed_) return !1; if (!e.endList) { const e = this.seekable(); if (!e.length) return !1; if (au.browser.IE_VERSION && 0 === this.tech_.readyState()) return this.tech_.one("loadedmetadata", (() => { this.trigger("firstplay"), this.tech_.setCurrentTime(e.end(0)), this.hasPlayed_ = !0 })), !1; this.trigger("firstplay"), this.tech_.setCurrentTime(e.end(0)) } return this.hasPlayed_ = !0, this.load(), !0 } handleSourceOpen_() { if (this.tryToCreateSourceBuffers_(), this.tech_.autoplay()) { const e = this.tech_.play(); "undefined" !== typeof e && "function" === typeof e.then && e.then(null, (e => { })) } this.trigger("sourceopen") } handleSourceEnded_() { if (!this.inbandTextTracks_.metadataTrack_) return; const e = this.inbandTextTracks_.metadataTrack_.cues; if (!e || !e.length) return; const t = this.duration(); e[e.length - 1].endTime = isNaN(t) || Math.abs(t) === 1 / 0 ? Number.MAX_VALUE : t } handleDurationChange_() { this.tech_.trigger("durationchange") } onEndOfStream() { let e = this.mainSegmentLoader_.ended_; if (this.mediaTypes_.AUDIO.activePlaylistLoader) { const t = this.mainSegmentLoader_.getCurrentMediaInfo_(); e = !t || t.hasVideo ? e && this.audioSegmentLoader_.ended_ : this.audioSegmentLoader_.ended_ } e && (this.stopABRTimer_(), this.sourceUpdater_.endOfStream()) } stuckAtPlaylistEnd_(e) { if (!this.seekable().length) return !1; const t = this.syncController_.getExpiredTime(e, this.duration()); if (null === t) return !1; const n = lp.Playlist.playlistEnd(e, t), i = this.tech_.currentTime(), r = this.tech_.buffered(); if (!r.length) return n - i <= vu; const s = r.end(r.length - 1); return s - i <= vu && n - s <= vu } excludePlaylist(e) { let { playlistToExclude: t = this.mainPlaylistLoader_.media(), error: n = {}, playlistExclusionDuration: i } = e; if (t = t || this.mainPlaylistLoader_.media(), i = i || n.playlistExclusionDuration || this.playlistExclusionDuration, !t) return this.error = n, void ("open" !== this.mediaSource.readyState ? this.trigger("error") : this.sourceUpdater_.endOfStream("network")); t.playlistErrors_++; const r = this.mainPlaylistLoader_.main.playlists, s = r.filter(Ru), a = 1 === s.length && s[0] === t; if (1 === r.length && i !== 1 / 0) return au.log.warn("Problem encountered with playlist ".concat(t.id, ". ") + "Trying again since it is the only playlist."), this.tech_.trigger("retryplaylist"), this.mainPlaylistLoader_.load(a); if (a) { let e = !1; r.forEach((n => { if (n === t) return; const i = n.excludeUntil; "undefined" !== typeof i && i !== 1 / 0 && (e = !0, delete n.excludeUntil) })), e && (au.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded."), this.tech_.trigger("retryplaylist")) } let o; o = t.playlistErrors_ > this.maxPlaylistRetries ? 1 / 0 : Date.now() + 1e3 * i, t.excludeUntil = o, n.reason && (t.lastExcludeReason_ = n.reason), this.tech_.trigger("excludeplaylist"), this.tech_.trigger({ type: "usage", name: "vhs-rendition-excluded" }); const l = this.selectPlaylist(); if (!l) return this.error = "Playback cannot continue. No available working or supported playlists.", void this.trigger("error"); const c = n.internal ? this.logger_ : au.log.warn, u = n.message ? " " + n.message : ""; c("".concat(n.internal ? "Internal problem" : "Problem", " encountered with playlist ").concat(t.id, ".") + "".concat(u, " Switching to playlist ").concat(l.id, ".")), l.attributes.AUDIO !== t.attributes.AUDIO && this.delegateLoaders_("audio", ["abort", "pause"]), l.attributes.SUBTITLES !== t.attributes.SUBTITLES && this.delegateLoaders_("subtitle", ["abort", "pause"]), this.delegateLoaders_("main", ["abort", "pause"]); const d = l.targetDuration / 2 * 1e3 || 5e3, h = "number" === typeof l.lastRequest && Date.now() - l.lastRequest <= d; return this.switchMedia_(l, "exclude", a || h) } pauseLoading() { this.delegateLoaders_("all", ["abort", "pause"]), this.stopABRTimer_() } delegateLoaders_(e, t) { const n = [], i = "all" === e; (i || "main" === e) && n.push(this.mainPlaylistLoader_); const r = []; (i || "audio" === e) && r.push("AUDIO"), (i || "subtitle" === e) && (r.push("CLOSED-CAPTIONS"), r.push("SUBTITLES")), r.forEach((e => { const t = this.mediaTypes_[e] && this.mediaTypes_[e].activePlaylistLoader; t && n.push(t) })), ["main", "audio", "subtitle"].forEach((t => { const i = this["".concat(t, "SegmentLoader_")]; !i || e !== t && "all" !== e || n.push(i) })), n.forEach((e => t.forEach((t => { "function" === typeof e[t] && e[t]() })))) } setCurrentTime(e) { const t = _u(this.tech_.buffered(), e); return this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media() && this.mainPlaylistLoader_.media().segments ? t && t.length ? e : (this.mainSegmentLoader_.resetEverything(), this.mainSegmentLoader_.abort(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.resetEverything(), this.audioSegmentLoader_.abort()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.resetEverything(), this.subtitleSegmentLoader_.abort()), void this.load()) : 0 } duration() { if (!this.mainPlaylistLoader_) return 0; const e = this.mainPlaylistLoader_.media(); return e ? e.endList ? this.mediaSource ? this.mediaSource.duration : lp.Playlist.duration(e) : 1 / 0 : 0 } seekable() { return this.seekable_ } onSyncInfoUpdate_() { let e; if (!this.mainPlaylistLoader_) return; let t = this.mainPlaylistLoader_.media(); if (!t) return; let n = this.syncController_.getExpiredTime(t, this.duration()); if (null === n) return; const i = this.mainPlaylistLoader_.main, r = lp.Playlist.seekable(t, n, lp.Playlist.liveEdgeDelay(i, t)); if (0 === r.length) return; if (this.mediaTypes_.AUDIO.activePlaylistLoader) { if (t = this.mediaTypes_.AUDIO.activePlaylistLoader.media(), n = this.syncController_.getExpiredTime(t, this.duration()), null === n) return; if (e = lp.Playlist.seekable(t, n, lp.Playlist.liveEdgeDelay(i, t)), 0 === e.length) return } let s, a; this.seekable_ && this.seekable_.length && (s = this.seekable_.end(0), a = this.seekable_.start(0)), e ? e.start(0) > r.end(0) || r.start(0) > e.end(0) ? this.seekable_ = r : this.seekable_ = gu([[e.start(0) > r.start(0) ? e.start(0) : r.start(0), e.end(0) < r.end(0) ? e.end(0) : r.end(0)]]) : this.seekable_ = r, this.seekable_ && this.seekable_.length && this.seekable_.end(0) === s && this.seekable_.start(0) === a || (this.logger_("seekable updated [".concat(Su(this.seekable_), "]")), this.tech_.trigger("seekablechanged")) } updateDuration(e) { if (this.updateDuration_ && (this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.updateDuration_ = null), "open" !== this.mediaSource.readyState) return this.updateDuration_ = this.updateDuration.bind(this, e), void this.mediaSource.addEventListener("sourceopen", this.updateDuration_); if (e) { const e = this.seekable(); if (!e.length) return; return void ((isNaN(this.mediaSource.duration) || this.mediaSource.duration < e.end(e.length - 1)) && this.sourceUpdater_.setDuration(e.end(e.length - 1))) } const t = this.tech_.buffered(); let n = lp.Playlist.duration(this.mainPlaylistLoader_.media()); t.length > 0 && (n = Math.max(n, t.end(t.length - 1))), this.mediaSource.duration !== n && this.sourceUpdater_.setDuration(n) } dispose() { this.trigger("dispose"), this.decrypter_.terminate(), this.mainPlaylistLoader_.dispose(), this.mainSegmentLoader_.dispose(), this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_), ["AUDIO", "SUBTITLES"].forEach((e => { const t = this.mediaTypes_[e].groups; for (const n in t) t[n].forEach((e => { e.playlistLoader && e.playlistLoader.dispose() })) })), this.audioSegmentLoader_.dispose(), this.subtitleSegmentLoader_.dispose(), this.sourceUpdater_.dispose(), this.timelineChangeController_.dispose(), this.stopABRTimer_(), this.updateDuration_ && this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_), this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_), this.off() } main() { return this.mainPlaylistLoader_.main } media() { return this.mainPlaylistLoader_.media() || this.initialMedia_ } areMediaTypesKnown_() { const e = !!this.mediaTypes_.AUDIO.activePlaylistLoader, t = !!this.mainSegmentLoader_.getCurrentMediaInfo_(), n = !e || !!this.audioSegmentLoader_.getCurrentMediaInfo_(); return !(!t || !n) } getCodecsOrExclude_() { const e = { main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {}, audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {} }, t = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media(); e.video = e.main; const n = sh(this.main(), t), i = {}, r = !!this.mediaTypes_.AUDIO.activePlaylistLoader; if (e.main.hasVideo && (i.video = n.video || e.main.videoCodec || "avc1.4d400d"), e.main.isMuxed && (i.video += ",".concat(n.audio || e.main.audioCodec || bi)), (e.main.hasAudio && !e.main.isMuxed || e.audio.hasAudio || r) && (i.audio = n.audio || e.main.audioCodec || e.audio.audioCodec || bi, e.audio.isFmp4 = e.main.hasAudio && !e.main.isMuxed ? e.main.isFmp4 : e.audio.isFmp4), !i.audio && !i.video) return void this.excludePlaylist({ playlistToExclude: t, error: { message: "Could not determine codecs for playlist." }, playlistExclusionDuration: 1 / 0 }); const s = {}; let a; if (["video", "audio"].forEach((function (t) { if (i.hasOwnProperty(t) && (n = e[t].isFmp4, r = i[t], !(n ? yi(r) : vi(r)))) { const n = e[t].isFmp4 ? "browser" : "muxer"; s[n] = s[n] || [], s[n].push(i[t]), "audio" === t && (a = n) } var n, r })), r && a && t.attributes.AUDIO) { const e = t.attributes.AUDIO; this.main().playlists.forEach((n => { (n.attributes && n.attributes.AUDIO) === e && n !== t && (n.excludeUntil = 1 / 0) })), this.logger_("excluding audio group ".concat(e, " as ").concat(a, ' does not support codec(s): "').concat(i.audio, '"')) } if (!Object.keys(s).length) { if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) { const e = []; if (["video", "audio"].forEach((t => { const n = (fi(this.sourceUpdater_.codecs[t] || "")[0] || {}).type, r = (fi(i[t] || "")[0] || {}).type; n && r && n.toLowerCase() !== r.toLowerCase() && e.push('"'.concat(this.sourceUpdater_.codecs[t], '" -> "').concat(i[t], '"')) })), e.length) return void this.excludePlaylist({ playlistToExclude: t, error: { message: "Codec switching not supported: ".concat(e.join(", "), "."), internal: !0 }, playlistExclusionDuration: 1 / 0 }) } return i } { const e = Object.keys(s).reduce(((e, t) => (e && (e += ", "), e += "".concat(t, ' does not support codec(s): "').concat(s[t].join(","), '"'))), "") + "."; this.excludePlaylist({ playlistToExclude: t, error: { internal: !0, message: e }, playlistExclusionDuration: 1 / 0 }) } } tryToCreateSourceBuffers_() { if ("open" !== this.mediaSource.readyState || this.sourceUpdater_.hasCreatedSourceBuffers()) return; if (!this.areMediaTypesKnown_()) return; const e = this.getCodecsOrExclude_(); if (!e) return; this.sourceUpdater_.createSourceBuffers(e); const t = [e.video, e.audio].filter(Boolean).join(","); this.excludeIncompatibleVariants_(t) } excludeUnsupportedVariants_() { const e = this.main().playlists, t = []; Object.keys(e).forEach((n => { const i = e[n]; if (-1 !== t.indexOf(i.id)) return; t.push(i.id); const r = sh(this.main, i), s = []; !r.audio || vi(r.audio) || yi(r.audio) || s.push("audio codec ".concat(r.audio)), !r.video || vi(r.video) || yi(r.video) || s.push("video codec ".concat(r.video)), r.text && "stpp.ttml.im1t" === r.text && s.push("text codec ".concat(r.text)), s.length && (i.excludeUntil = 1 / 0, this.logger_("excluding ".concat(i.id, " for unsupported: ").concat(s.join(", ")))) })) } excludeIncompatibleVariants_(e) { const t = [], n = this.main().playlists, i = ih(fi(e)), r = rh(i), s = i.video && fi(i.video)[0] || null, a = i.audio && fi(i.audio)[0] || null; Object.keys(n).forEach((e => { const i = n[e]; if (-1 !== t.indexOf(i.id) || i.excludeUntil === 1 / 0) return; t.push(i.id); const o = [], l = sh(this.mainPlaylistLoader_.main, i), c = rh(l); if (l.audio || l.video) { if (c !== r && o.push('codec count "'.concat(c, '" !== "').concat(r, '"')), !this.sourceUpdater_.canChangeType()) { const e = l.video && fi(l.video)[0] || null, t = l.audio && fi(l.audio)[0] || null; e && s && e.type.toLowerCase() !== s.type.toLowerCase() && o.push('video codec "'.concat(e.type, '" !== "').concat(s.type, '"')), t && a && t.type.toLowerCase() !== a.type.toLowerCase() && o.push('audio codec "'.concat(t.type, '" !== "').concat(a.type, '"')) } o.length && (i.excludeUntil = 1 / 0, this.logger_("excluding ".concat(i.id, ": ").concat(o.join(" && ")))) } })) } updateAdCues_(e) { let t = 0; const n = this.seekable(); n.length && (t = n.start(0)), function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; if (!e.segments) return; let i, r = n; for (let s = 0; s < e.segments.length; s++) { const n = e.segments[s]; if (i || (i = Xh(t, r + n.duration / 2)), i) { if ("cueIn" in n) { i.endTime = r, i.adEndTime = r, r += n.duration, i = null; continue } if (r < i.endTime) { r += n.duration; continue } i.endTime += n.duration } else if ("cueOut" in n && (i = new (Un().VTTCue)(r, r + n.duration, n.cueOut), i.adStartTime = r, i.adEndTime = r + parseFloat(n.cueOut), t.addCue(i)), "cueOutCont" in n) { const [e, s] = n.cueOutCont.split("/").map(parseFloat); i = new (Un().VTTCue)(r, r + n.duration, ""), i.adStartTime = r - e, i.adEndTime = i.adStartTime + s, t.addCue(i) } r += n.duration } }(e, this.cueTagsTrack_, t) } goalBufferLength() { const e = this.tech_.currentTime(), t = Ed.GOAL_BUFFER_LENGTH, n = Ed.GOAL_BUFFER_LENGTH_RATE, i = Math.max(t, Ed.MAX_GOAL_BUFFER_LENGTH); return Math.min(t + e * n, i) } bufferLowWaterLine() { const e = this.tech_.currentTime(), t = Ed.BUFFER_LOW_WATER_LINE, n = Ed.BUFFER_LOW_WATER_LINE_RATE, i = Math.max(t, Ed.MAX_BUFFER_LOW_WATER_LINE), r = Math.max(t, Ed.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE); return Math.min(t + e * n, this.bufferBasedABR ? r : i) } bufferHighWaterLine() { return Ed.BUFFER_HIGH_WATER_LINE } } class hp { constructor(e, t, n) { const { playlistController_: i } = e, r = i.fastQualityChange_.bind(i); if (t.attributes) { const e = t.attributes.RESOLUTION; this.width = e && e.width, this.height = e && e.height, this.bandwidth = t.attributes.BANDWIDTH, this.frameRate = t.attributes["FRAME-RATE"] } var s, a, o; this.codecs = sh(i.main(), t), this.playlist = t, this.id = n, this.enabled = (s = e.playlists, a = t.id, o = r, e => { const t = s.main.playlists[a], n = Mu(t), i = Ru(t); return "undefined" === typeof e ? i : (e ? delete t.disabled : t.disabled = !0, e === i || n || (o(), e ? s.trigger("renditionenabled") : s.trigger("renditiondisabled")), e) }) } } const pp = ["seeking", "seeked", "pause", "playing", "error"]; class fp { constructor(e) { this.playlistController_ = e.playlistController, this.tech_ = e.tech, this.seekable = e.seekable, this.allowSeeksWithinUnsafeLiveWindow = e.allowSeeksWithinUnsafeLiveWindow, this.liveRangeSafeTimeDelta = e.liveRangeSafeTimeDelta, this.media = e.media, this.consecutiveUpdates = 0, this.lastRecordedTime = null, this.checkCurrentTimeTimeout_ = null, this.logger_ = fu("PlaybackWatcher"), this.logger_("initialize"); const t = () => this.monitorCurrentTime_(), n = () => this.monitorCurrentTime_(), i = () => this.techWaiting_(), r = () => this.resetTimeUpdate_(), s = this.playlistController_, a = ["main", "subtitle", "audio"], o = {}; a.forEach((e => { o[e] = { reset: () => this.resetSegmentDownloads_(e), updateend: () => this.checkSegmentDownloads_(e) }, s["".concat(e, "SegmentLoader_")].on("appendsdone", o[e].updateend), s["".concat(e, "SegmentLoader_")].on("playlistupdate", o[e].reset), this.tech_.on(["seeked", "seeking"], o[e].reset) })); const l = e => { ["main", "audio"].forEach((t => { s["".concat(t, "SegmentLoader_")][e]("appended", this.seekingAppendCheck_) })) }; this.seekingAppendCheck_ = () => { this.fixesBadSeeks_() && (this.consecutiveUpdates = 0, this.lastRecordedTime = this.tech_.currentTime(), l("off")) }, this.clearSeekingAppendCheck_ = () => l("off"), this.watchForBadSeeking_ = () => { this.clearSeekingAppendCheck_(), l("on") }, this.tech_.on("seeked", this.clearSeekingAppendCheck_), this.tech_.on("seeking", this.watchForBadSeeking_), this.tech_.on("waiting", i), this.tech_.on(pp, r), this.tech_.on("canplay", n), this.tech_.one("play", t), this.dispose = () => { this.clearSeekingAppendCheck_(), this.logger_("dispose"), this.tech_.off("waiting", i), this.tech_.off(pp, r), this.tech_.off("canplay", n), this.tech_.off("play", t), this.tech_.off("seeking", this.watchForBadSeeking_), this.tech_.off("seeked", this.clearSeekingAppendCheck_), a.forEach((e => { s["".concat(e, "SegmentLoader_")].off("appendsdone", o[e].updateend), s["".concat(e, "SegmentLoader_")].off("playlistupdate", o[e].reset), this.tech_.off(["seeked", "seeking"], o[e].reset) })), this.checkCurrentTimeTimeout_ && Un().clearTimeout(this.checkCurrentTimeTimeout_), this.resetTimeUpdate_() } } monitorCurrentTime_() { this.checkCurrentTime_(), this.checkCurrentTimeTimeout_ && Un().clearTimeout(this.checkCurrentTimeTimeout_), this.checkCurrentTimeTimeout_ = Un().setTimeout(this.monitorCurrentTime_.bind(this), 250) } resetSegmentDownloads_(e) { const t = this.playlistController_["".concat(e, "SegmentLoader_")]; this["".concat(e, "StalledDownloads_")] > 0 && this.logger_("resetting possible stalled download count for ".concat(e, " loader")), this["".concat(e, "StalledDownloads_")] = 0, this["".concat(e, "Buffered_")] = t.buffered_() } checkSegmentDownloads_(e) { const t = this.playlistController_, n = t["".concat(e, "SegmentLoader_")], i = n.buffered_(), r = function (e, t) { if (e === t) return !1; if (!e && t || !t && e) return !0; if (e.length !== t.length) return !0; for (let n = 0; n < e.length; n++)if (e.start(n) !== t.start(n) || e.end(n) !== t.end(n)) return !0; return !1 }(this["".concat(e, "Buffered_")], i); this["".concat(e, "Buffered_")] = i, r ? this.resetSegmentDownloads_(e) : (this["".concat(e, "StalledDownloads_")]++, this.logger_("found #".concat(this["".concat(e, "StalledDownloads_")], " ").concat(e, " appends that did not increase buffer (possible stalled download)"), { playlistId: n.playlist_ && n.playlist_.id, buffered: wu(i) }), this["".concat(e, "StalledDownloads_")] < 10 || (this.logger_("".concat(e, " loader stalled download exclusion")), this.resetSegmentDownloads_(e), this.tech_.trigger({ type: "usage", name: "vhs-".concat(e, "-download-exclusion") }), "subtitle" !== e && t.excludePlaylist({ error: { message: "Excessive ".concat(e, " segment downloading detected.") }, playlistExclusionDuration: 1 / 0 }))) } checkCurrentTime_() { if (this.tech_.paused() || this.tech_.seeking()) return; const e = this.tech_.currentTime(), t = this.tech_.buffered(); if (this.lastRecordedTime === e && (!t.length || e + vu >= t.end(t.length - 1))) return this.techWaiting_(); this.consecutiveUpdates >= 5 && e === this.lastRecordedTime ? (this.consecutiveUpdates++, this.waiting_()) : e === this.lastRecordedTime ? this.consecutiveUpdates++ : (this.consecutiveUpdates = 0, this.lastRecordedTime = e) } resetTimeUpdate_() { this.consecutiveUpdates = 0 } fixesBadSeeks_() { if (!this.tech_.seeking()) return !1; const e = this.seekable(), t = this.tech_.currentTime(); let n; if (this.afterSeekableWindow_(e, t, this.media(), this.allowSeeksWithinUnsafeLiveWindow)) { n = e.end(e.length - 1) } if (this.beforeSeekableWindow_(e, t)) { const t = e.start(0); n = t + (t === e.end(0) ? 0 : vu) } if ("undefined" !== typeof n) return this.logger_("Trying to seek outside of seekable at time ".concat(t, " with ") + "seekable range ".concat(Su(e), ". Seeking to ") + "".concat(n, ".")), this.tech_.setCurrentTime(n), !0; const i = this.playlistController_.sourceUpdater_, r = this.tech_.buffered(), s = i.audioBuffer ? i.audioBuffered() : null, a = i.videoBuffer ? i.videoBuffered() : null, o = this.media(), l = o.partTargetDuration ? o.partTargetDuration : 2 * (o.targetDuration - yu), c = [s, a]; for (let d = 0; d < c.length; d++) { if (!c[d]) continue; if (ku(c[d], t) < l) return !1 } const u = Tu(r, t); return 0 !== u.length && (n = u.start(0) + vu, this.logger_("Buffered region starts (".concat(u.start(0), ") ") + " just beyond seek point (".concat(t, "). Seeking to ").concat(n, ".")), this.tech_.setCurrentTime(n), !0) } waiting_() { if (this.techWaiting_()) return; const e = this.tech_.currentTime(), t = this.tech_.buffered(), n = _u(t, e); return n.length && e + 3 <= n.end(0) ? (this.resetTimeUpdate_(), this.tech_.setCurrentTime(e), this.logger_("Stopped at ".concat(e, " while inside a buffered region ") + "[".concat(n.start(0), " -> ").concat(n.end(0), "]. Attempting to resume ") + "playback by seeking to the current time."), void this.tech_.trigger({ type: "usage", name: "vhs-unknown-waiting" })) : void 0 } techWaiting_() { const e = this.seekable(), t = this.tech_.currentTime(); if (this.tech_.seeking()) return !0; if (this.beforeSeekableWindow_(e, t)) { const n = e.end(e.length - 1); return this.logger_("Fell out of live window at time ".concat(t, ". Seeking to ") + "live point (seekable end) ".concat(n)), this.resetTimeUpdate_(), this.tech_.setCurrentTime(n), this.tech_.trigger({ type: "usage", name: "vhs-live-resync" }), !0 } const n = this.tech_.vhs.playlistController_.sourceUpdater_, i = this.tech_.buffered(); if (this.videoUnderflow_({ audioBuffered: n.audioBuffered(), videoBuffered: n.videoBuffered(), currentTime: t })) return this.resetTimeUpdate_(), this.tech_.setCurrentTime(t), this.tech_.trigger({ type: "usage", name: "vhs-video-underflow" }), !0; const r = Tu(i, t); return r.length > 0 && (this.logger_("Stopped at ".concat(t, " and seeking to ").concat(r.start(0))), this.resetTimeUpdate_(), this.skipTheGap_(t), !0) } afterSeekableWindow_(e, t, n) { let i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; if (!e.length) return !1; let r = e.end(e.length - 1) + vu; return !n.endList && i && (r = e.end(e.length - 1) + 3 * n.targetDuration), t > r } beforeSeekableWindow_(e, t) { return !!(e.length && e.start(0) > 0 && t < e.start(0) - this.liveRangeSafeTimeDelta) } videoUnderflow_(e) { let t, { videoBuffered: n, audioBuffered: i, currentTime: r } = e; if (n) { if (n.length && i.length) { const e = _u(n, r - 3), s = _u(n, r), a = _u(i, r); a.length && !s.length && e.length && (t = { start: e.end(0), end: a.end(0) }) } else { Tu(n, r).length || (t = this.gapFromVideoUnderflow_(n, r)) } return !!t && (this.logger_("Encountered a gap in video from ".concat(t.start, " to ").concat(t.end, ". ") + "Seeking to current time ".concat(r)), !0) } } skipTheGap_(e) { const t = this.tech_.buffered(), n = this.tech_.currentTime(), i = Tu(t, n); this.resetTimeUpdate_(), 0 !== i.length && n === e && (this.logger_("skipTheGap_:", "currentTime:", n, "scheduled currentTime:", e, "nextRange start:", i.start(0)), this.tech_.setCurrentTime(i.start(0) + yu), this.tech_.trigger({ type: "usage", name: "vhs-gap-skip" })) } gapFromVideoUnderflow_(e, t) { const n = function (e) { if (e.length < 2) return gu(); const t = []; for (let n = 1; n < e.length; n++) { const i = e.end(n - 1), r = e.start(n); t.push([i, r]) } return gu(t) }(e); for (let i = 0; i < n.length; i++) { const e = n.start(i), r = n.end(i); if (t - e < 4 && t - e > 2) return { start: e, end: r } } return null } } const mp = { errorInterval: 30, getSource(e) { return e(this.tech({ IWillNotUseThisInPlugins: !0 }).currentSource_ || this.currentSource()) } }, gp = function (e, t) { let n = 0, i = 0; const r = mu(mp, t); e.ready((() => { e.trigger({ type: "usage", name: "vhs-error-reload-initialized" }) })); const s = function () { i && e.currentTime(i) }, a = function (t) { null !== t && void 0 !== t && (i = e.duration() !== 1 / 0 && e.currentTime() || 0, e.one("loadedmetadata", s), e.src(t), e.trigger({ type: "usage", name: "vhs-error-reload" }), e.play()) }, o = function () { if (Date.now() - n < 1e3 * r.errorInterval) e.trigger({ type: "usage", name: "vhs-error-reload-canceled" }); else { if (r.getSource && "function" === typeof r.getSource) return n = Date.now(), r.getSource.call(e, a); au.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!") } }, l = function () { e.off("loadedmetadata", s), e.off("error", o), e.off("dispose", l) }; e.on("error", o), e.on("dispose", l), e.reloadSourceOnError = function (t) { l(), gp(e, t) } }, yp = function (e) { gp(this, e) }; var vp = "3.0.2"; const bp = { PlaylistLoader: id, Playlist: Vu, utils: md, STANDARD_PLAYLIST_SELECTOR: hh, INITIAL_PLAYLIST_SELECTOR: function () { const e = this.playlists.main.playlists.filter(Vu.isEnabled); ch(e, ((e, t) => uh(e, t))); return e.filter((e => !!sh(this.playlists.main, e).video))[0] || null }, lastBandwidthSelector: hh, movingAverageBandwidthSelector: function (e) { let t = -1, n = -1; if (e < 0 || e > 1) throw new Error("Moving average bandwidth decay must be between 0 and 1."); return function () { const i = this.useDevicePixelRatio && Un().devicePixelRatio || 1; return t < 0 && (t = this.systemBandwidth, n = this.systemBandwidth), this.systemBandwidth > 0 && this.systemBandwidth !== n && (t = e * this.systemBandwidth + (1 - e) * t, n = this.systemBandwidth), dh(this.playlists.main, t, parseInt(lh(this.tech_.el(), "width"), 10) * i, parseInt(lh(this.tech_.el(), "height"), 10) * i, this.limitRenditionByPlayerDimensions, this.playlistController_) } }, comparePlaylistBandwidth: uh, comparePlaylistResolution: function (e, t) { let n, i; return e.attributes.RESOLUTION && e.attributes.RESOLUTION.width && (n = e.attributes.RESOLUTION.width), n = n || Un().Number.MAX_VALUE, t.attributes.RESOLUTION && t.attributes.RESOLUTION.width && (i = t.attributes.RESOLUTION.width), i = i || Un().Number.MAX_VALUE, n === i && e.attributes.BANDWIDTH && t.attributes.BANDWIDTH ? e.attributes.BANDWIDTH - t.attributes.BANDWIDTH : n - i }, xhr: ad() }; Object.keys(Ed).forEach((e => { Object.defineProperty(bp, e, { get: () => (au.log.warn("using Vhs.".concat(e, " is UNSAFE be sure you know what you are doing")), Ed[e]), set(t) { au.log.warn("using Vhs.".concat(e, " is UNSAFE be sure you know what you are doing")), "number" !== typeof t || t < 0 ? au.log.warn("value of Vhs.".concat(e, " must be greater than or equal to 0")) : Ed[e] = t } }) })); const _p = "videojs-vhs", Tp = function (e, t) { const n = t.media(); let i = -1; for (let r = 0; r < e.length; r++)if (e[r].id === n.id) { i = r; break } e.selectedIndex_ = i, e.trigger({ selectedIndex: i, type: "change" }) }; bp.canPlaySource = function () { return au.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.") }; const Sp = e => { let { player: t, sourceKeySystems: n, audioMedia: i, mainPlaylists: r } = e; if (!t.eme.initializeMediaKeys) return Promise.resolve(); const s = ((e, t) => e.reduce(((e, n) => { if (!n.contentProtection) return e; const i = t.reduce(((e, t) => { const i = n.contentProtection[t]; return i && i.pssh && (e[t] = { pssh: i.pssh }), e }), {}); return Object.keys(i).length && e.push(i), e }), []))(i ? r.concat([i]) : r, Object.keys(n)), a = [], o = []; return s.forEach((e => { o.push(new Promise(((e, n) => { t.tech_.one("keysessioncreated", e) }))), a.push(new Promise(((n, i) => { t.eme.initializeMediaKeys({ keySystems: e }, (e => { e ? i(e) : n() })) }))) })), Promise.race([Promise.all(a), Promise.race(o)]) }, wp = e => { let { player: t, sourceKeySystems: n, media: i, audioMedia: r } = e; const s = ((e, t, n) => { if (!e) return e; let i = {}; t && t.attributes && t.attributes.CODECS && (i = ih(fi(t.attributes.CODECS))), n && n.attributes && n.attributes.CODECS && (i.audio = n.attributes.CODECS); const r = gi(i.video), s = gi(i.audio), a = {}; for (const o in e) a[o] = {}, s && (a[o].audioContentType = s), r && (a[o].videoContentType = r), t.contentProtection && t.contentProtection[o] && t.contentProtection[o].pssh && (a[o].pssh = t.contentProtection[o].pssh), "string" === typeof e[o] && (a[o].url = e[o]); return mu(e, a) })(n, i, r); return !!s && (t.currentSource().keySystems = s, !(s && !t.eme) || (au.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin"), !1)) }, xp = () => { if (!Un().localStorage) return null; const e = Un().localStorage.getItem(_p); if (!e) return null; try { return JSON.parse(e) } catch (t) { return null } }; bp.supportsNativeHls = function () { if (!Fn() || !Fn().createElement) return !1; const e = Fn().createElement("video"); if (!au.getTech("Html5").isSupported()) return !1; return ["application/vnd.apple.mpegurl", "audio/mpegurl", "audio/x-mpegurl", "application/x-mpegurl", "video/x-mpegurl", "video/mpegurl", "application/mpegurl"].some((function (t) { return /maybe|probably/i.test(e.canPlayType(t)) })) }(), bp.supportsNativeDash = !!(Fn() && Fn().createElement && au.getTech("Html5").isSupported()) && /maybe|probably/i.test(Fn().createElement("video").canPlayType("application/dash+xml")), bp.supportsTypeNatively = e => "hls" === e ? bp.supportsNativeHls : "dash" === e && bp.supportsNativeDash, bp.isSupported = function () { return au.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.") }; const kp = au.getComponent("Component"); class Ep extends kp { constructor(e, t, n) { if (super(t, n.vhs), "number" === typeof n.initialBandwidth && (this.options_.bandwidth = n.initialBandwidth), this.logger_ = fu("VhsHandler"), t.options_ && t.options_.playerId) { const e = au.getPlayer(t.options_.playerId); this.player_ = e } if (this.tech_ = t, this.source_ = e, this.stats = {}, this.ignoreNextSeekingEvent_ = !1, this.setOptions_(), this.options_.overrideNative && t.overrideNativeAudioTracks && t.overrideNativeVideoTracks) t.overrideNativeAudioTracks(!0), t.overrideNativeVideoTracks(!0); else if (this.options_.overrideNative && (t.featuresNativeVideoTracks || t.featuresNativeAudioTracks)) throw new Error("Overriding native VHS requires emulated tracks. See https://git.io/vMpjB"); this.on(Fn(), ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], (e => { const t = Fn().fullscreenElement || Fn().webkitFullscreenElement || Fn().mozFullScreenElement || Fn().msFullscreenElement; t && t.contains(this.tech_.el()) ? this.playlistController_.fastQualityChange_() : this.playlistController_.checkABR_() })), this.on(this.tech_, "seeking", (function () { this.ignoreNextSeekingEvent_ ? this.ignoreNextSeekingEvent_ = !1 : this.setCurrentTime(this.tech_.currentTime()) })), this.on(this.tech_, "error", (function () { this.tech_.error() && this.playlistController_ && this.playlistController_.pauseLoading() })), this.on(this.tech_, "play", this.play) } setOptions_() { if (this.options_.withCredentials = this.options_.withCredentials || !1, this.options_.limitRenditionByPlayerDimensions = !1 !== this.options_.limitRenditionByPlayerDimensions, this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || !1, this.options_.useBandwidthFromLocalStorage = "undefined" !== typeof this.source_.useBandwidthFromLocalStorage ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || !1, this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || !1, this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || !1, this.options_.customTagParsers = this.options_.customTagParsers || [], this.options_.customTagMappers = this.options_.customTagMappers || [], this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || !1, this.options_.llhls = !1 !== this.options_.llhls, this.options_.bufferBasedABR = this.options_.bufferBasedABR || !1, "number" !== typeof this.options_.playlistExclusionDuration && (this.options_.playlistExclusionDuration = 300), "number" !== typeof this.options_.bandwidth && this.options_.useBandwidthFromLocalStorage) { const e = xp(); e && e.bandwidth && (this.options_.bandwidth = e.bandwidth, this.tech_.trigger({ type: "usage", name: "vhs-bandwidth-from-local-storage" })), e && e.throughput && (this.options_.throughput = e.throughput, this.tech_.trigger({ type: "usage", name: "vhs-throughput-from-local-storage" })) } "number" !== typeof this.options_.bandwidth && (this.options_.bandwidth = Ed.INITIAL_BANDWIDTH), this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Ed.INITIAL_BANDWIDTH, ["withCredentials", "useDevicePixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "customTagParsers", "customTagMappers", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "bufferBasedABR", "liveRangeSafeTimeDelta", "llhls", "useNetworkInformationApi", "useDtsForTimestampOffset", "exactManifestTimings", "leastPixelDiffSelector"].forEach((e => { "undefined" !== typeof this.source_[e] && (this.options_[e] = this.source_[e]) })), this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions, this.useDevicePixelRatio = this.options_.useDevicePixelRatio } src(e, t) { if (!e) return; var n; this.setOptions_(), this.options_.src = 0 === (n = this.source_.src).toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") ? JSON.parse(n.substring(n.indexOf(",") + 1)) : n, this.options_.tech = this.tech_, this.options_.externVhs = bp, this.options_.sourceType = Si(t), this.options_.seekTo = e => { this.tech_.setCurrentTime(e) }, this.playlistController_ = new dp(this.options_); const i = mu({ liveRangeSafeTimeDelta: vu }, this.options_, { seekable: () => this.seekable(), media: () => this.playlistController_.media(), playlistController: this.playlistController_ }); this.playbackWatcher_ = new fp(i), this.playlistController_.on("error", (() => { const e = au.players[this.tech_.options_.playerId]; let t = this.playlistController_.error; "object" !== typeof t || t.code ? "string" === typeof t && (t = { message: t, code: 3 }) : t.code = 3, e.error(t) })); const r = this.options_.bufferBasedABR ? bp.movingAverageBandwidthSelector(.55) : bp.STANDARD_PLAYLIST_SELECTOR; this.playlistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : r.bind(this), this.playlistController_.selectInitialPlaylist = bp.INITIAL_PLAYLIST_SELECTOR.bind(this), this.playlists = this.playlistController_.mainPlaylistLoader_, this.mediaSource = this.playlistController_.mediaSource, Object.defineProperties(this, { selectPlaylist: { get() { return this.playlistController_.selectPlaylist }, set(e) { this.playlistController_.selectPlaylist = e.bind(this) } }, throughput: { get() { return this.playlistController_.mainSegmentLoader_.throughput.rate }, set(e) { this.playlistController_.mainSegmentLoader_.throughput.rate = e, this.playlistController_.mainSegmentLoader_.throughput.count = 1 } }, bandwidth: { get() { let e = this.playlistController_.mainSegmentLoader_.bandwidth; const t = Un().navigator.connection || Un().navigator.mozConnection || Un().navigator.webkitConnection, n = 1e7; if (this.options_.useNetworkInformationApi && t) { const i = 1e3 * t.downlink * 1e3; e = i >= n && e >= n ? Math.max(e, i) : i } return e }, set(e) { this.playlistController_.mainSegmentLoader_.bandwidth = e, this.playlistController_.mainSegmentLoader_.throughput = { rate: 0, count: 0 } } }, systemBandwidth: { get() { const e = 1 / (this.bandwidth || 1); let t; t = this.throughput > 0 ? 1 / this.throughput : 0; return Math.floor(1 / (e + t)) }, set() { au.log.error('The "systemBandwidth" property is read-only') } } }), this.options_.bandwidth && (this.bandwidth = this.options_.bandwidth), this.options_.throughput && (this.throughput = this.options_.throughput), Object.defineProperties(this.stats, { bandwidth: { get: () => this.bandwidth || 0, enumerable: !0 }, mediaRequests: { get: () => this.playlistController_.mediaRequests_() || 0, enumerable: !0 }, mediaRequestsAborted: { get: () => this.playlistController_.mediaRequestsAborted_() || 0, enumerable: !0 }, mediaRequestsTimedout: { get: () => this.playlistController_.mediaRequestsTimedout_() || 0, enumerable: !0 }, mediaRequestsErrored: { get: () => this.playlistController_.mediaRequestsErrored_() || 0, enumerable: !0 }, mediaTransferDuration: { get: () => this.playlistController_.mediaTransferDuration_() || 0, enumerable: !0 }, mediaBytesTransferred: { get: () => this.playlistController_.mediaBytesTransferred_() || 0, enumerable: !0 }, mediaSecondsLoaded: { get: () => this.playlistController_.mediaSecondsLoaded_() || 0, enumerable: !0 }, mediaAppends: { get: () => this.playlistController_.mediaAppends_() || 0, enumerable: !0 }, mainAppendsToLoadedData: { get: () => this.playlistController_.mainAppendsToLoadedData_() || 0, enumerable: !0 }, audioAppendsToLoadedData: { get: () => this.playlistController_.audioAppendsToLoadedData_() || 0, enumerable: !0 }, appendsToLoadedData: { get: () => this.playlistController_.appendsToLoadedData_() || 0, enumerable: !0 }, timeToLoadedData: { get: () => this.playlistController_.timeToLoadedData_() || 0, enumerable: !0 }, buffered: { get: () => wu(this.tech_.buffered()), enumerable: !0 }, currentTime: { get: () => this.tech_.currentTime(), enumerable: !0 }, currentSource: { get: () => this.tech_.currentSource_, enumerable: !0 }, currentTech: { get: () => this.tech_.name_, enumerable: !0 }, duration: { get: () => this.tech_.duration(), enumerable: !0 }, main: { get: () => this.playlists.main, enumerable: !0 }, playerDimensions: { get: () => this.tech_.currentDimensions(), enumerable: !0 }, seekable: { get: () => wu(this.tech_.seekable()), enumerable: !0 }, timestamp: { get: () => Date.now(), enumerable: !0 }, videoPlaybackQuality: { get: () => this.tech_.getVideoPlaybackQuality(), enumerable: !0 } }), this.tech_.one("canplay", this.playlistController_.setupFirstPlay.bind(this.playlistController_)), this.tech_.on("bandwidthupdate", (() => { this.options_.useBandwidthFromLocalStorage && (e => { if (!Un().localStorage) return !1; let t = xp(); t = t ? mu(t, e) : e; try { Un().localStorage.setItem(_p, JSON.stringify(t)) } catch (n) { return !1 } })({ bandwidth: this.bandwidth, throughput: Math.round(this.throughput) }) })), this.playlistController_.on("selectedinitialmedia", (() => { var e; (e = this).representations = () => { const t = e.playlistController_.main(), n = Hu(t) ? e.playlistController_.getAudioTrackPlaylists_() : t.playlists; return n ? n.filter((e => !Mu(e))).map(((t, n) => new hp(e, t, t.id))) : [] } })), this.playlistController_.sourceUpdater_.on("createdsourcebuffers", (() => { this.setupEme_() })), this.on(this.playlistController_, "progress", (function () { this.tech_.trigger("progress") })), this.on(this.playlistController_, "firstplay", (function () { this.ignoreNextSeekingEvent_ = !0 })), this.setupQualityLevels_(), this.tech_.el() && (this.mediaSourceUrl_ = Un().URL.createObjectURL(this.playlistController_.mediaSource), this.tech_.src(this.mediaSourceUrl_)) } createKeySessions_() { const e = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader; this.logger_("waiting for EME key session creation"), Sp({ player: this.player_, sourceKeySystems: this.source_.keySystems, audioMedia: e && e.media(), mainPlaylists: this.playlists.main.playlists }).then((() => { this.logger_("created EME key session"), this.playlistController_.sourceUpdater_.initializedEme() })).catch((e => { this.logger_("error while creating EME key session", e), this.player_.error({ message: "Failed to initialize media keys for EME", code: 3 }) })) } handleWaitingForKey_() { this.logger_("waitingforkey fired, attempting to create any new key sessions"), this.createKeySessions_() } setupEme_() { const e = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader, t = wp({ player: this.player_, sourceKeySystems: this.source_.keySystems, media: this.playlists.media(), audioMedia: e && e.media() }); this.player_.tech_.on("keystatuschange", (e => { if ("output-restricted" !== e.status) return; const t = this.playlistController_.main(); if (!t || !t.playlists) return; const n = []; t.playlists.forEach((e => { e && e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.height >= 720 && (!e.excludeUntil || e.excludeUntil < 1 / 0) && (e.excludeUntil = 1 / 0, n.push(e)) })), n.length && (au.log.warn('DRM keystatus changed to "output-restricted." Removing the following HD playlists that will most likely fail to play and clearing the buffer. This may be due to HDCP restrictions on the stream and the capabilities of the current device.', ...n), this.playlistController_.fastQualityChange_()) })), this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this), this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_), 11 !== au.browser.IE_VERSION && t ? this.createKeySessions_() : this.playlistController_.sourceUpdater_.initializedEme() } setupQualityLevels_() { const e = au.players[this.tech_.options_.playerId]; e && e.qualityLevels && !this.qualityLevels_ && (this.qualityLevels_ = e.qualityLevels(), this.playlistController_.on("selectedinitialmedia", (() => { !function (e, t) { t.representations().forEach((t => { e.addQualityLevel(t) })), Tp(e, t.playlists) }(this.qualityLevels_, this) })), this.playlists.on("mediachange", (() => { Tp(this.qualityLevels_, this.playlists) }))) } static version() { return { "@videojs/http-streaming": vp, "mux.js": "6.3.0", "mpd-parser": "1.0.1", "m3u8-parser": "6.0.0", "aes-decrypter": "4.0.1" } } version() { return this.constructor.version() } canChangeType() { return Hh.canChangeType() } play() { this.playlistController_.play() } setCurrentTime(e) { this.playlistController_.setCurrentTime(e) } duration() { return this.playlistController_.duration() } seekable() { return this.playlistController_.seekable() } dispose() { this.playbackWatcher_ && this.playbackWatcher_.dispose(), this.playlistController_ && this.playlistController_.dispose(), this.qualityLevels_ && this.qualityLevels_.dispose(), this.tech_ && this.tech_.vhs && delete this.tech_.vhs, this.mediaSourceUrl_ && Un().URL.revokeObjectURL && (Un().URL.revokeObjectURL(this.mediaSourceUrl_), this.mediaSourceUrl_ = null), this.tech_ && this.tech_.off("waitingforkey", this.handleWaitingForKey_), super.dispose() } convertToProgramTime(e, t) { return gd({ playlist: this.playlistController_.media(), time: e, callback: t }) } seekToProgramTime(e, t) { let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2; return yd({ programTime: e, playlist: this.playlistController_.media(), retryCount: i, pauseAfterSeek: n, seekTo: this.options_.seekTo, tech: this.options_.tech, callback: t }) } } const Cp = { name: "videojs-http-streaming", VERSION: vp, canHandleSource(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = mu(au.options, t); return Cp.canPlayType(e.type, n) }, handleSource(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const i = mu(au.options, n); return t.vhs = new Ep(e, t, i), t.vhs.xhr = ad(), t.vhs.src(e.src, e.type), t.vhs }, canPlayType(e, t) { const n = Si(e); if (!n) return ""; const i = Cp.getOverrideNative(t); return !bp.supportsTypeNatively(n) || i ? "maybe" : "" }, getOverrideNative() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const { vhs: t = {} } = e, n = !(au.browser.IS_ANY_SAFARI || au.browser.IS_IOS), { overrideNative: i = n } = t; return i } }; yi("avc1.4d400d,mp4a.40.2") && au.getTech("Html5").registerSourceHandler(Cp, 0), au.VhsHandler = Ep, au.VhsSourceHandler = Cp, au.Vhs = bp, au.use || au.registerComponent("Vhs", bp), au.options.vhs = au.options.vhs || {}, au.getPlugin && au.getPlugin("reloadSourceOnError") || au.registerPlugin("reloadSourceOnError", yp); var Pp = n(6710), Ip = n.n(Pp); const Lp = e => { const { options: t, onReady: n } = e; return (0, Ct.jsx)("div", { children: (0, Ct.jsx)(Ip(), { url: t.sources[0].src, controls: !0, width: "100%", height: "100%", playing: t.autoplay, onReady: n, config: { file: { forceHLS: !0, hlsOptions: { xhrSetup: function (e, t) { e.open("GET", t, !0), e.setRequestHeader("x-user-token", "".concat(localStorage.getItem("token"))) } } } } }) }) }; function Op() { const { id: e } = Q(), n = (0, t.useRef)(null), { data: i } = je("".concat("", "/get_movie_data/").concat(e)), { data: r } = je("".concat("", "/can_i_play_movie/").concat(e)), s = Y(); null !== r && void 0 !== r && !1 === r.can_I_play && s("/"); const a = { autoplay: !0, controls: !0, preload: "none", techOrder: ["chromecast", "html5", "hls"], sources: [{ src: "".concat("", "/main_movie/").concat(e), type: "application/x-mpegURL" }], html5: { nativeTextTracks: !1 } }; return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(Ot, {}), (0, Ct.jsx)(kn, {}), (0, Ct.jsx)("h1", { className: "videoTitle", children: null === i || void 0 === i ? void 0 : i.realTitle }), (0, Ct.jsx)(Lp, { options: a, onReady: (e, t) => { n.current = e, e.on("waiting", (() => { au.log("player is waiting") })), e.on("dispose", (() => { au.log("player will dispose") })), e.on("timeupdate", (() => { })) } })] }) } function Ap() { const { id: e } = Q(), n = (0, t.useRef)(null), i = Y(), { data: r } = je("".concat("", "/get_episode_data/").concat(e)); console.log(r); const { data: s } = je("".concat("", "/can_i_play_episode/").concat(e)); null !== s && void 0 !== s && !1 === s.can_I_play && i("/"); const a = { autoplay: !0, controls: !0, preload: "none", techOrder: ["chromecast", "html5", "hls"], sources: [{ src: "".concat("", "/main_serie/").concat(e), type: "application/x-mpegURL" }], html5: { nativeTextTracks: !1 } }; return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(Ot, {}), (0, Ct.jsx)(kn, { path: "/season/" + (null === r || void 0 === r ? void 0 : r.season_id) }), (0, Ct.jsxs)("h1", { className: "videoTitle", children: ["EP", null === r || void 0 === r ? void 0 : r.episode_number, " - ", null === r || void 0 === r ? void 0 : r.episode_name] }), (0, Ct.jsx)(Lp, { options: a, onReady: (e, t) => { n.current = e, e.on("waiting", (() => { au.log("player is waiting") })), e.on("dispose", (() => { au.log("player will dispose") })), e.on("timeupdate", (() => { })) } }), (0, Ct.jsxs)("div", { className: "episodeButtons", children: [null !== r && void 0 !== r && r.previous_episode ? (0, Ct.jsx)(qt, { text: "Previous episode", onClick: () => i("/episode/" + (null === r || void 0 === r ? void 0 : r.previous_episode)) }) : (0, Ct.jsx)("div", {}), null !== r && void 0 !== r && r.next_episode ? (0, Ct.jsx)(qt, { text: "Next episode", onClick: () => i("/episode/" + (null === r || void 0 === r ? void 0 : r.next_episode)) }) : (0, Ct.jsx)("div", {})] })] }) } function Np() { const { id: e } = Q(), n = (0, t.useRef)(null), { data: i } = je("".concat("", "/can_i_play_other_video/").concat(e)), r = Y(); console.log(i), null !== i && void 0 !== i && !1 === i.can_I_play && r("/"); const s = { autoplay: !0, controls: !0, preload: "none", techOrder: ["chromecast", "html5", "hls"], sources: [{ src: "".concat("", "/main_other/").concat(e), type: "application/x-mpegURL" }], html5: { nativeTextTracks: !1 } }; return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(Ot, {}), (0, Ct.jsx)(kn, {}), (0, Ct.jsx)(Lp, { options: s, onReady: (e, t) => { n.current = e, e.on("waiting", (() => { au.log("player is waiting") })), e.on("dispose", (() => { au.log("player will dispose") })), e.on("timeupdate", (() => { })) } })] }) } function jp(e) { return null !== e && "object" === typeof e && "constructor" in e && e.constructor === Object } function Dp() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; Object.keys(t).forEach((n => { "undefined" === typeof e[n] ? e[n] = t[n] : jp(t[n]) && jp(e[n]) && Object.keys(t[n]).length > 0 && Dp(e[n], t[n]) })) } const Mp = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() { } }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function Rp() { const e = "undefined" !== typeof document ? document : {}; return Dp(e, Mp), e } const Up = { document: Mp, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle: () => ({ getPropertyValue: () => "" }), Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia: () => ({}), requestAnimationFrame: e => "undefined" === typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { "undefined" !== typeof setTimeout && clearTimeout(e) } }; function Bp() { const e = "undefined" !== typeof window ? window : {}; return Dp(e, Up), e } function Fp(e) { return setTimeout(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0) } function zp() { return Date.now() } function Hp(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x"; const n = Bp(); let i, r, s; const a = function (e) { const t = Bp(); let n; return t.getComputedStyle && (n = t.getComputedStyle(e, null)), !n && e.currentStyle && (n = e.currentStyle), n || (n = e.style), n }(e); return n.WebKitCSSMatrix ? (r = a.transform || a.webkitTransform, r.split(",").length > 6 && (r = r.split(", ").map((e => e.replace(",", "."))).join(", ")), s = new n.WebKitCSSMatrix("none" === r ? "" : r)) : (s = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = s.toString().split(",")), "x" === t && (r = n.WebKitCSSMatrix ? s.m41 : 16 === i.length ? parseFloat(i[12]) : parseFloat(i[4])), "y" === t && (r = n.WebKitCSSMatrix ? s.m42 : 16 === i.length ? parseFloat(i[13]) : parseFloat(i[5])), r || 0 } function Vp(e) { return "object" === typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function Wp() { const e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = ["__proto__", "constructor", "prototype"]; for (let i = 1; i < arguments.length; i += 1) { const r = i < 0 || arguments.length <= i ? void 0 : arguments[i]; if (void 0 !== r && null !== r && (n = r, !("undefined" !== typeof window && "undefined" !== typeof window.HTMLElement ? n instanceof HTMLElement : n && (1 === n.nodeType || 11 === n.nodeType)))) { const n = Object.keys(Object(r)).filter((e => t.indexOf(e) < 0)); for (let t = 0, i = n.length; t < i; t += 1) { const i = n[t], s = Object.getOwnPropertyDescriptor(r, i); void 0 !== s && s.enumerable && (Vp(e[i]) && Vp(r[i]) ? r[i].__swiper__ ? e[i] = r[i] : Wp(e[i], r[i]) : !Vp(e[i]) && Vp(r[i]) ? (e[i] = {}, r[i].__swiper__ ? e[i] = r[i] : Wp(e[i], r[i])) : e[i] = r[i]) } } } var n; return e } function qp(e, t, n) { e.style.setProperty(t, n) } function Gp(e) { let { swiper: t, targetPosition: n, side: i } = e; const r = Bp(), s = -t.translate; let a, o = null; const l = t.params.speed; t.wrapperEl.style.scrollSnapType = "none", r.cancelAnimationFrame(t.cssModeFrameID); const c = n > s ? "next" : "prev", u = (e, t) => "next" === c && e >= t || "prev" === c && e <= t, d = () => { a = (new Date).getTime(), null === o && (o = a); const e = Math.max(Math.min((a - o) / l, 1), 0), c = .5 - Math.cos(e * Math.PI) / 2; let h = s + c * (n - s); if (u(h, n) && (h = n), t.wrapperEl.scrollTo({ [i]: h }), u(h, n)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => { t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({ [i]: h }) })), void r.cancelAnimationFrame(t.cssModeFrameID); t.cssModeFrameID = r.requestAnimationFrame(d) }; d() } function Xp(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ""; return [...e.children].filter((e => e.matches(t))) } function Kp(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []; const n = document.createElement(e); return n.classList.add(...Array.isArray(t) ? t : [t]), n } function $p(e, t) { return Bp().getComputedStyle(e, null).getPropertyValue(t) } function Yp(e) { let t, n = e; if (n) { for (t = 0; null !== (n = n.previousSibling);)1 === n.nodeType && (t += 1); return t } } function Qp(e, t) { const n = []; let i = e.parentElement; for (; i;)t ? i.matches(t) && n.push(i) : n.push(i), i = i.parentElement; return n } function Jp(e, t, n) { const i = Bp(); return n ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(i.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(i.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth } let Zp, ef, tf; function nf() { return Zp || (Zp = function () { const e = Bp(), t = Rp(); return { smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch) } }()), Zp } function rf() { return ef || (ef = function () { let { userAgent: e } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = nf(), n = Bp(), i = n.navigator.platform, r = e || n.navigator.userAgent, s = { ios: !1, android: !1 }, a = n.screen.width, o = n.screen.height, l = r.match(/(Android);?[\s\/]+([\d.]+)?/); let c = r.match(/(iPad).*OS\s([\d_]+)/); const u = r.match(/(iPod)(.*OS\s([\d_]+))?/), d = !c && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/), h = "Win32" === i; let p = "MacIntel" === i; return !c && p && t.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf("".concat(a, "x").concat(o)) >= 0 && (c = r.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), p = !1), l && !h && (s.os = "android", s.android = !0), (c || d || u) && (s.os = "ios", s.ios = !0), s }(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {})), ef } function sf() { return tf || (tf = function () { const e = Bp(); let t = !1; function n() { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0 } if (n()) { const n = String(e.navigator.userAgent); if (n.includes("Version/")) { const [e, i] = n.split("Version/")[1].split(" ")[0].split(".").map((e => Number(e))); t = e < 16 || 16 === e && i < 2 } } return { isSafari: t || n(), needPerspectiveFix: t, isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent) } }()), tf } const af = { on(e, t, n) { const i = this; if (!i.eventsListeners || i.destroyed) return i; if ("function" !== typeof t) return i; const r = n ? "unshift" : "push"; return e.split(" ").forEach((e => { i.eventsListeners[e] || (i.eventsListeners[e] = []), i.eventsListeners[e][r](t) })), i }, once(e, t, n) { const i = this; if (!i.eventsListeners || i.destroyed) return i; if ("function" !== typeof t) return i; function r() { i.off(e, r), r.__emitterProxy && delete r.__emitterProxy; for (var n = arguments.length, s = new Array(n), a = 0; a < n; a++)s[a] = arguments[a]; t.apply(i, s) } return r.__emitterProxy = t, i.on(e, r, n) }, onAny(e, t) { const n = this; if (!n.eventsListeners || n.destroyed) return n; if ("function" !== typeof e) return n; const i = t ? "unshift" : "push"; return n.eventsAnyListeners.indexOf(e) < 0 && n.eventsAnyListeners[i](e), n }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const n = t.eventsAnyListeners.indexOf(e); return n >= 0 && t.eventsAnyListeners.splice(n, 1), t }, off(e, t) { const n = this; return !n.eventsListeners || n.destroyed ? n : n.eventsListeners ? (e.split(" ").forEach((e => { "undefined" === typeof t ? n.eventsListeners[e] = [] : n.eventsListeners[e] && n.eventsListeners[e].forEach(((i, r) => { (i === t || i.__emitterProxy && i.__emitterProxy === t) && n.eventsListeners[e].splice(r, 1) })) })), n) : n }, emit() { const e = this; if (!e.eventsListeners || e.destroyed) return e; if (!e.eventsListeners) return e; let t, n, i; for (var r = arguments.length, s = new Array(r), a = 0; a < r; a++)s[a] = arguments[a]; "string" === typeof s[0] || Array.isArray(s[0]) ? (t = s[0], n = s.slice(1, s.length), i = e) : (t = s[0].events, n = s[0].data, i = s[0].context || e), n.unshift(i); return (Array.isArray(t) ? t : t.split(" ")).forEach((t => { e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => { e.apply(i, [t, ...n]) })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => { e.apply(i, n) })) })), e } }; const of = (e, t) => { if (!e || e.destroyed || !e.params) return; const n = t.closest(e.isElement ? "swiper-slide" : ".".concat(e.params.slideClass)); if (n) { const t = n.querySelector(".".concat(e.params.lazyPreloaderClass)); t && t.remove() } }, lf = (e, t) => { if (!e.slides[t]) return; const n = e.slides[t].querySelector('[loading="lazy"]'); n && n.removeAttribute("loading") }, cf = e => { if (!e || e.destroyed || !e.params) return; let t = e.params.lazyPreloadPrevNext; const n = e.slides.length; if (!n || !t || t < 0) return; t = Math.min(t, n); const i = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView), r = e.activeIndex, s = r + i - 1; if (e.params.rewind) for (let a = r - t; a <= s + t; a += 1) { const t = (a % n + n) % n; t !== r && t > s && lf(e, t) } else for (let a = Math.max(s - t, 0); a <= Math.min(s + t, n - 1); a += 1)a !== r && a > s && lf(e, a) }; const uf = { updateSize: function () { const e = this; let t, n; const i = e.el; t = "undefined" !== typeof e.params.width && null !== e.params.width ? e.params.width : i.clientWidth, n = "undefined" !== typeof e.params.height && null !== e.params.height ? e.params.height : i.clientHeight, 0 === t && e.isHorizontal() || 0 === n && e.isVertical() || (t = t - parseInt($p(i, "padding-left") || 0, 10) - parseInt($p(i, "padding-right") || 0, 10), n = n - parseInt($p(i, "padding-top") || 0, 10) - parseInt($p(i, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(n) && (n = 0), Object.assign(e, { width: t, height: n, size: e.isHorizontal() ? t : n })) }, updateSlides: function () { const e = this; function t(t) { return e.isHorizontal() ? t : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[t] } function n(e, n) { return parseFloat(e.getPropertyValue(t(n)) || 0) } const i = e.params, { wrapperEl: r, slidesEl: s, size: a, rtlTranslate: o, wrongRTL: l } = e, c = e.virtual && i.virtual.enabled, u = c ? e.virtual.slides.length : e.slides.length, d = Xp(s, ".".concat(e.params.slideClass, ", swiper-slide")), h = c ? e.virtual.slides.length : d.length; let p = []; const f = [], m = []; let g = i.slidesOffsetBefore; "function" === typeof g && (g = i.slidesOffsetBefore.call(e)); let y = i.slidesOffsetAfter; "function" === typeof y && (y = i.slidesOffsetAfter.call(e)); const v = e.snapGrid.length, b = e.slidesGrid.length; let _ = i.spaceBetween, T = -g, S = 0, w = 0; if ("undefined" === typeof a) return; "string" === typeof _ && _.indexOf("%") >= 0 ? _ = parseFloat(_.replace("%", "")) / 100 * a : "string" === typeof _ && (_ = parseFloat(_)), e.virtualSize = -_, d.forEach((e => { o ? e.style.marginLeft = "" : e.style.marginRight = "", e.style.marginBottom = "", e.style.marginTop = "" })), i.centeredSlides && i.cssMode && (qp(r, "--swiper-centered-offset-before", ""), qp(r, "--swiper-centered-offset-after", "")); const x = i.grid && i.grid.rows > 1 && e.grid; let k; x && e.grid.initSlides(h); const E = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter((e => "undefined" !== typeof i.breakpoints[e].slidesPerView)).length > 0; for (let C = 0; C < h; C += 1) { let r; if (k = 0, d[C] && (r = d[C]), x && e.grid.updateSlide(C, r, h, t), !d[C] || "none" !== $p(r, "display")) { if ("auto" === i.slidesPerView) { E && (d[C].style[t("width")] = ""); const s = getComputedStyle(r), a = r.style.transform, o = r.style.webkitTransform; if (a && (r.style.transform = "none"), o && (r.style.webkitTransform = "none"), i.roundLengths) k = e.isHorizontal() ? Jp(r, "width", !0) : Jp(r, "height", !0); else { const e = n(s, "width"), t = n(s, "padding-left"), i = n(s, "padding-right"), a = n(s, "margin-left"), o = n(s, "margin-right"), l = s.getPropertyValue("box-sizing"); if (l && "border-box" === l) k = e + a + o; else { const { clientWidth: n, offsetWidth: s } = r; k = e + t + i + a + o + (s - n) } } a && (r.style.transform = a), o && (r.style.webkitTransform = o), i.roundLengths && (k = Math.floor(k)) } else k = (a - (i.slidesPerView - 1) * _) / i.slidesPerView, i.roundLengths && (k = Math.floor(k)), d[C] && (d[C].style[t("width")] = "".concat(k, "px")); d[C] && (d[C].swiperSlideSize = k), m.push(k), i.centeredSlides ? (T = T + k / 2 + S / 2 + _, 0 === S && 0 !== C && (T = T - a / 2 - _), 0 === C && (T = T - a / 2 - _), Math.abs(T) < .001 && (T = 0), i.roundLengths && (T = Math.floor(T)), w % i.slidesPerGroup === 0 && p.push(T), f.push(T)) : (i.roundLengths && (T = Math.floor(T)), (w - Math.min(e.params.slidesPerGroupSkip, w)) % e.params.slidesPerGroup === 0 && p.push(T), f.push(T), T = T + k + _), e.virtualSize += k + _, S = k, w += 1 } } if (e.virtualSize = Math.max(e.virtualSize, a) + y, o && l && ("slide" === i.effect || "coverflow" === i.effect) && (r.style.width = "".concat(e.virtualSize + _, "px")), i.setWrapperSize && (r.style[t("width")] = "".concat(e.virtualSize + _, "px")), x && e.grid.updateWrapperSize(k, p, t), !i.centeredSlides) { const t = []; for (let n = 0; n < p.length; n += 1) { let r = p[n]; i.roundLengths && (r = Math.floor(r)), p[n] <= e.virtualSize - a && t.push(r) } p = t, Math.floor(e.virtualSize - a) - Math.floor(p[p.length - 1]) > 1 && p.push(e.virtualSize - a) } if (c && i.loop) { const t = m[0] + _; if (i.slidesPerGroup > 1) { const n = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / i.slidesPerGroup), r = t * i.slidesPerGroup; for (let e = 0; e < n; e += 1)p.push(p[p.length - 1] + r) } for (let n = 0; n < e.virtual.slidesBefore + e.virtual.slidesAfter; n += 1)1 === i.slidesPerGroup && p.push(p[p.length - 1] + t), f.push(f[f.length - 1] + t), e.virtualSize += t } if (0 === p.length && (p = [0]), 0 !== _) { const n = e.isHorizontal() && o ? "marginLeft" : t("marginRight"); d.filter(((e, t) => !(i.cssMode && !i.loop) || t !== d.length - 1)).forEach((e => { e.style[n] = "".concat(_, "px") })) } if (i.centeredSlides && i.centeredSlidesBounds) { let e = 0; m.forEach((t => { e += t + (_ || 0) })), e -= _; const t = e - a; p = p.map((e => e < 0 ? -g : e > t ? t + y : e)) } if (i.centerInsufficientSlides) { let e = 0; if (m.forEach((t => { e += t + (_ || 0) })), e -= _, e < a) { const t = (a - e) / 2; p.forEach(((e, n) => { p[n] = e - t })), f.forEach(((e, n) => { f[n] = e + t })) } } if (Object.assign(e, { slides: d, snapGrid: p, slidesGrid: f, slidesSizesGrid: m }), i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) { qp(r, "--swiper-centered-offset-before", "".concat(-p[0], "px")), qp(r, "--swiper-centered-offset-after", "".concat(e.size / 2 - m[m.length - 1] / 2, "px")); const t = -e.snapGrid[0], n = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + n)) } if (h !== u && e.emit("slidesLengthChange"), p.length !== v && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), f.length !== b && e.emit("slidesGridLengthChange"), i.watchSlidesProgress && e.updateSlidesOffset(), !c && !i.cssMode && ("slide" === i.effect || "fade" === i.effect)) { const t = "".concat(i.containerModifierClass, "backface-hidden"), n = e.el.classList.contains(t); h <= i.maxBackfaceHiddenSlides ? n || e.el.classList.add(t) : n && e.el.classList.remove(t) } }, updateAutoHeight: function (e) { const t = this, n = [], i = t.virtual && t.params.virtual.enabled; let r, s = 0; "number" === typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const a = e => i ? t.slides[t.getSlideIndexByData(e)] : t.slides[e]; if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) (t.visibleSlides || []).forEach((e => { n.push(e) })); else for (r = 0; r < Math.ceil(t.params.slidesPerView); r += 1) { const e = t.activeIndex + r; if (e > t.slides.length && !i) break; n.push(a(e)) } else n.push(a(t.activeIndex)); for (r = 0; r < n.length; r += 1)if ("undefined" !== typeof n[r]) { const e = n[r].offsetHeight; s = e > s ? e : s } (s || 0 === s) && (t.wrapperEl.style.height = "".concat(s, "px")) }, updateSlidesOffset: function () { const e = this, t = e.slides, n = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0; for (let i = 0; i < t.length; i += 1)t[i].swiperSlideOffset = (e.isHorizontal() ? t[i].offsetLeft : t[i].offsetTop) - n - e.cssOverflowAdjustment() }, updateSlidesProgress: function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this && this.translate || 0; const t = this, n = t.params, { slides: i, rtlTranslate: r, snapGrid: s } = t; if (0 === i.length) return; "undefined" === typeof i[0].swiperSlideOffset && t.updateSlidesOffset(); let a = -e; r && (a = e), i.forEach((e => { e.classList.remove(n.slideVisibleClass) })), t.visibleSlidesIndexes = [], t.visibleSlides = []; let o = n.spaceBetween; "string" === typeof o && o.indexOf("%") >= 0 ? o = parseFloat(o.replace("%", "")) / 100 * t.size : "string" === typeof o && (o = parseFloat(o)); for (let l = 0; l < i.length; l += 1) { const e = i[l]; let c = e.swiperSlideOffset; n.cssMode && n.centeredSlides && (c -= i[0].swiperSlideOffset); const u = (a + (n.centeredSlides ? t.minTranslate() : 0) - c) / (e.swiperSlideSize + o), d = (a - s[0] + (n.centeredSlides ? t.minTranslate() : 0) - c) / (e.swiperSlideSize + o), h = -(a - c), p = h + t.slidesSizesGrid[l]; (h >= 0 && h < t.size - 1 || p > 1 && p <= t.size || h <= 0 && p >= t.size) && (t.visibleSlides.push(e), t.visibleSlidesIndexes.push(l), i[l].classList.add(n.slideVisibleClass)), e.progress = r ? -u : u, e.originalProgress = r ? -d : d } }, updateProgress: function (e) { const t = this; if ("undefined" === typeof e) { const n = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * n || 0 } const n = t.params, i = t.maxTranslate() - t.minTranslate(); let { progress: r, isBeginning: s, isEnd: a, progressLoop: o } = t; const l = s, c = a; if (0 === i) r = 0, s = !0, a = !0; else { r = (e - t.minTranslate()) / i; const n = Math.abs(e - t.minTranslate()) < 1, o = Math.abs(e - t.maxTranslate()) < 1; s = n || r <= 0, a = o || r >= 1, n && (r = 0), o && (r = 1) } if (n.loop) { const n = t.getSlideIndexByData(0), i = t.getSlideIndexByData(t.slides.length - 1), r = t.slidesGrid[n], s = t.slidesGrid[i], a = t.slidesGrid[t.slidesGrid.length - 1], l = Math.abs(e); o = l >= r ? (l - r) / a : (l + a - s) / a, o > 1 && (o -= 1) } Object.assign(t, { progress: r, progressLoop: o, isBeginning: s, isEnd: a }), (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && t.updateSlidesProgress(e), s && !l && t.emit("reachBeginning toEdge"), a && !c && t.emit("reachEnd toEdge"), (l && !s || c && !a) && t.emit("fromEdge"), t.emit("progress", r) }, updateSlidesClasses: function () { const e = this, { slides: t, params: n, slidesEl: i, activeIndex: r } = e, s = e.virtual && n.virtual.enabled, a = e => Xp(i, ".".concat(n.slideClass).concat(e, ", swiper-slide").concat(e))[0]; let o; if (t.forEach((e => { e.classList.remove(n.slideActiveClass, n.slideNextClass, n.slidePrevClass) })), s) if (n.loop) { let t = r - e.virtual.slidesBefore; t < 0 && (t = e.virtual.slides.length + t), t >= e.virtual.slides.length && (t -= e.virtual.slides.length), o = a('[data-swiper-slide-index="'.concat(t, '"]')) } else o = a('[data-swiper-slide-index="'.concat(r, '"]')); else o = t[r]; if (o) { o.classList.add(n.slideActiveClass); let e = function (e, t) { const n = []; for (; e.nextElementSibling;) { const i = e.nextElementSibling; t ? i.matches(t) && n.push(i) : n.push(i), e = i } return n }(o, ".".concat(n.slideClass, ", swiper-slide"))[0]; n.loop && !e && (e = t[0]), e && e.classList.add(n.slideNextClass); let i = function (e, t) { const n = []; for (; e.previousElementSibling;) { const i = e.previousElementSibling; t ? i.matches(t) && n.push(i) : n.push(i), e = i } return n }(o, ".".concat(n.slideClass, ", swiper-slide"))[0]; n.loop && 0 === !i && (i = t[t.length - 1]), i && i.classList.add(n.slidePrevClass) } e.emitSlidesClasses() }, updateActiveIndex: function (e) { const t = this, n = t.rtlTranslate ? t.translate : -t.translate, { snapGrid: i, params: r, activeIndex: s, realIndex: a, snapIndex: o } = t; let l, c = e; const u = e => { let n = e - t.virtual.slidesBefore; return n < 0 && (n = t.virtual.slides.length + n), n >= t.virtual.slides.length && (n -= t.virtual.slides.length), n }; if ("undefined" === typeof c && (c = function (e) { const { slidesGrid: t, params: n } = e, i = e.rtlTranslate ? e.translate : -e.translate; let r; for (let s = 0; s < t.length; s += 1)"undefined" !== typeof t[s + 1] ? i >= t[s] && i < t[s + 1] - (t[s + 1] - t[s]) / 2 ? r = s : i >= t[s] && i < t[s + 1] && (r = s + 1) : i >= t[s] && (r = s); return n.normalizeSlideIndex && (r < 0 || "undefined" === typeof r) && (r = 0), r }(t)), i.indexOf(n) >= 0) l = i.indexOf(n); else { const e = Math.min(r.slidesPerGroupSkip, c); l = e + Math.floor((c - e) / r.slidesPerGroup) } if (l >= i.length && (l = i.length - 1), c === s) return l !== o && (t.snapIndex = l, t.emit("snapIndexChange")), void (t.params.loop && t.virtual && t.params.virtual.enabled && (t.realIndex = u(c))); let d; d = t.virtual && r.virtual.enabled && r.loop ? u(c) : t.slides[c] ? parseInt(t.slides[c].getAttribute("data-swiper-slide-index") || c, 10) : c, Object.assign(t, { previousSnapIndex: o, snapIndex: l, previousRealIndex: a, realIndex: d, previousIndex: s, activeIndex: c }), t.initialized && cf(t), t.emit("activeIndexChange"), t.emit("snapIndexChange"), a !== d && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange") }, updateClickedSlide: function (e) { const t = this, n = t.params, i = e.closest(".".concat(n.slideClass, ", swiper-slide")); let r, s = !1; if (i) for (let a = 0; a < t.slides.length; a += 1)if (t.slides[a] === i) { s = !0, r = a; break } if (!i || !s) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = i, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(i.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = r, n.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } }; const df = { getTranslate: function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.isHorizontal() ? "x" : "y"; const { params: t, rtlTranslate: n, translate: i, wrapperEl: r } = this; if (t.virtualTranslate) return n ? -i : i; if (t.cssMode) return i; let s = Hp(r, e); return s += this.cssOverflowAdjustment(), n && (s = -s), s || 0 }, setTranslate: function (e, t) { const n = this, { rtlTranslate: i, params: r, wrapperEl: s, progress: a } = n; let o, l = 0, c = 0; n.isHorizontal() ? l = i ? -e : e : c = e, r.roundLengths && (l = Math.floor(l), c = Math.floor(c)), n.previousTranslate = n.translate, n.translate = n.isHorizontal() ? l : c, r.cssMode ? s[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -l : -c : r.virtualTranslate || (n.isHorizontal() ? l -= n.cssOverflowAdjustment() : c -= n.cssOverflowAdjustment(), s.style.transform = "translate3d(".concat(l, "px, ").concat(c, "px, ").concat(0, "px)")); const u = n.maxTranslate() - n.minTranslate(); o = 0 === u ? 0 : (e - n.minTranslate()) / u, o !== a && n.updateProgress(e), n.emit("setTranslate", n.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.params.speed, n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r = arguments.length > 4 ? arguments[4] : void 0; const s = this, { params: a, wrapperEl: o } = s; if (s.animating && a.preventInteractionOnTransition) return !1; const l = s.minTranslate(), c = s.maxTranslate(); let u; if (u = i && e > l ? l : i && e < c ? c : e, s.updateProgress(u), a.cssMode) { const e = s.isHorizontal(); if (0 === t) o[e ? "scrollLeft" : "scrollTop"] = -u; else { if (!s.support.smoothScroll) return Gp({ swiper: s, targetPosition: -u, side: e ? "left" : "top" }), !0; o.scrollTo({ [e ? "left" : "top"]: -u, behavior: "smooth" }) } return !0 } return 0 === t ? (s.setTransition(0), s.setTranslate(u), n && (s.emit("beforeTransitionStart", t, r), s.emit("transitionEnd"))) : (s.setTransition(t), s.setTranslate(u), n && (s.emit("beforeTransitionStart", t, r), s.emit("transitionStart")), s.animating || (s.animating = !0, s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function (e) { s && !s.destroyed && e.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.onTranslateToWrapperTransitionEnd = null, delete s.onTranslateToWrapperTransitionEnd, n && s.emit("transitionEnd")) }), s.wrapperEl.addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd))), !0 } }; function hf(e) { let { swiper: t, runCallbacks: n, direction: i, step: r } = e; const { activeIndex: s, previousIndex: a } = t; let o = i; if (o || (o = s > a ? "next" : s < a ? "prev" : "reset"), t.emit("transition".concat(r)), n && s !== a) { if ("reset" === o) return void t.emit("slideResetTransition".concat(r)); t.emit("slideChangeTransition".concat(r)), "next" === o ? t.emit("slideNextTransition".concat(r)) : t.emit("slidePrevTransition".concat(r)) } } const pf = { setTransition: function (e, t) { const n = this; n.params.cssMode || (n.wrapperEl.style.transitionDuration = "".concat(e, "ms")), n.emit("setTransition", e, t) }, transitionStart: function () { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], t = arguments.length > 1 ? arguments[1] : void 0; const n = this, { params: i } = n; i.cssMode || (i.autoHeight && n.updateAutoHeight(), hf({ swiper: n, runCallbacks: e, direction: t, step: "Start" })) }, transitionEnd: function () { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], t = arguments.length > 1 ? arguments[1] : void 0; const n = this, { params: i } = n; n.animating = !1, i.cssMode || (n.setTransition(0), hf({ swiper: n, runCallbacks: e, direction: t, step: "End" })) } }; const ff = { slideTo: function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.params.speed, n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], i = arguments.length > 3 ? arguments[3] : void 0, r = arguments.length > 4 ? arguments[4] : void 0; "string" === typeof e && (e = parseInt(e, 10)); const s = this; let a = e; a < 0 && (a = 0); const { params: o, snapGrid: l, slidesGrid: c, previousIndex: u, activeIndex: d, rtlTranslate: h, wrapperEl: p, enabled: f } = s; if (s.animating && o.preventInteractionOnTransition || !f && !i && !r) return !1; const m = Math.min(s.params.slidesPerGroupSkip, a); let g = m + Math.floor((a - m) / s.params.slidesPerGroup); g >= l.length && (g = l.length - 1); const y = -l[g]; if (o.normalizeSlideIndex) for (let b = 0; b < c.length; b += 1) { const e = -Math.floor(100 * y), t = Math.floor(100 * c[b]), n = Math.floor(100 * c[b + 1]); "undefined" !== typeof c[b + 1] ? e >= t && e < n - (n - t) / 2 ? a = b : e >= t && e < n && (a = b + 1) : e >= t && (a = b) } if (s.initialized && a !== d) { if (!s.allowSlideNext && y < s.translate && y < s.minTranslate()) return !1; if (!s.allowSlidePrev && y > s.translate && y > s.maxTranslate() && (d || 0) !== a) return !1 } let v; if (a !== (u || 0) && n && s.emit("beforeSlideChangeStart"), s.updateProgress(y), v = a > d ? "next" : a < d ? "prev" : "reset", h && -y === s.translate || !h && y === s.translate) return s.updateActiveIndex(a), o.autoHeight && s.updateAutoHeight(), s.updateSlidesClasses(), "slide" !== o.effect && s.setTranslate(y), "reset" !== v && (s.transitionStart(n, v), s.transitionEnd(n, v)), !1; if (o.cssMode) { const e = s.isHorizontal(), n = h ? y : -y; if (0 === t) { const t = s.virtual && s.params.virtual.enabled; t && (s.wrapperEl.style.scrollSnapType = "none", s._immediateVirtual = !0), t && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0 ? (s._cssModeVirtualInitialSet = !0, requestAnimationFrame((() => { p[e ? "scrollLeft" : "scrollTop"] = n }))) : p[e ? "scrollLeft" : "scrollTop"] = n, t && requestAnimationFrame((() => { s.wrapperEl.style.scrollSnapType = "", s._immediateVirtual = !1 })) } else { if (!s.support.smoothScroll) return Gp({ swiper: s, targetPosition: n, side: e ? "left" : "top" }), !0; p.scrollTo({ [e ? "left" : "top"]: n, behavior: "smooth" }) } return !0 } return s.setTransition(t), s.setTranslate(y), s.updateActiveIndex(a), s.updateSlidesClasses(), s.emit("beforeTransitionStart", t, i), s.transitionStart(n, v), 0 === t ? s.transitionEnd(n, v) : s.animating || (s.animating = !0, s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function (e) { s && !s.destroyed && e.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.onSlideToWrapperTransitionEnd = null, delete s.onSlideToWrapperTransitionEnd, s.transitionEnd(n, v)) }), s.wrapperEl.addEventListener("transitionend", s.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.params.speed, n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], i = arguments.length > 3 ? arguments[3] : void 0; if ("string" === typeof e) { e = parseInt(e, 10) } const r = this; let s = e; return r.params.loop && (r.virtual && r.params.virtual.enabled ? s += r.virtual.slidesBefore : s = r.getSlideIndexByData(s)), r.slideTo(s, t, n, i) }, slideNext: function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.params.speed, t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n = arguments.length > 2 ? arguments[2] : void 0; const i = this, { enabled: r, params: s, animating: a } = i; if (!r) return i; let o = s.slidesPerGroup; "auto" === s.slidesPerView && 1 === s.slidesPerGroup && s.slidesPerGroupAuto && (o = Math.max(i.slidesPerViewDynamic("current", !0), 1)); const l = i.activeIndex < s.slidesPerGroupSkip ? 1 : o, c = i.virtual && s.virtual.enabled; if (s.loop) { if (a && !c && s.loopPreventsSliding) return !1; i.loopFix({ direction: "next" }), i._clientLeft = i.wrapperEl.clientLeft } return s.rewind && i.isEnd ? i.slideTo(0, e, t, n) : i.slideTo(i.activeIndex + l, e, t, n) }, slidePrev: function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.params.speed, t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n = arguments.length > 2 ? arguments[2] : void 0; const i = this, { params: r, snapGrid: s, slidesGrid: a, rtlTranslate: o, enabled: l, animating: c } = i; if (!l) return i; const u = i.virtual && r.virtual.enabled; if (r.loop) { if (c && !u && r.loopPreventsSliding) return !1; i.loopFix({ direction: "prev" }), i._clientLeft = i.wrapperEl.clientLeft } function d(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const h = d(o ? i.translate : -i.translate), p = s.map((e => d(e))); let f = s[p.indexOf(h) - 1]; if ("undefined" === typeof f && r.cssMode) { let e; s.forEach(((t, n) => { h >= t && (e = n) })), "undefined" !== typeof e && (f = s[e > 0 ? e - 1 : e]) } let m = 0; if ("undefined" !== typeof f && (m = a.indexOf(f), m < 0 && (m = i.activeIndex - 1), "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (m = m - i.slidesPerViewDynamic("previous", !0) + 1, m = Math.max(m, 0))), r.rewind && i.isBeginning) { const r = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1; return i.slideTo(r, e, t, n) } return i.slideTo(m, e, t, n) }, slideReset: function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.params.speed, t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n = arguments.length > 2 ? arguments[2] : void 0; return this.slideTo(this.activeIndex, e, t, n) }, slideToClosest: function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.params.speed, t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n = arguments.length > 2 ? arguments[2] : void 0, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5; const r = this; let s = r.activeIndex; const a = Math.min(r.params.slidesPerGroupSkip, s), o = a + Math.floor((s - a) / r.params.slidesPerGroup), l = r.rtlTranslate ? r.translate : -r.translate; if (l >= r.snapGrid[o]) { const e = r.snapGrid[o]; l - e > (r.snapGrid[o + 1] - e) * i && (s += r.params.slidesPerGroup) } else { const e = r.snapGrid[o - 1]; l - e <= (r.snapGrid[o] - e) * i && (s -= r.params.slidesPerGroup) } return s = Math.max(s, 0), s = Math.min(s, r.slidesGrid.length - 1), r.slideTo(s, e, t, n) }, slideToClickedSlide: function () { const e = this, { params: t, slidesEl: n } = e, i = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let r, s = e.clickedIndex; const a = e.isElement ? "swiper-slide" : ".".concat(t.slideClass); if (t.loop) { if (e.animating) return; r = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? s < e.loopedSlides - i / 2 || s > e.slides.length - e.loopedSlides + i / 2 ? (e.loopFix(), s = e.getSlideIndex(Xp(n, "".concat(a, '[data-swiper-slide-index="').concat(r, '"]'))[0]), Fp((() => { e.slideTo(s) }))) : e.slideTo(s) : s > e.slides.length - i ? (e.loopFix(), s = e.getSlideIndex(Xp(n, "".concat(a, '[data-swiper-slide-index="').concat(r, '"]'))[0]), Fp((() => { e.slideTo(s) }))) : e.slideTo(s) } else e.slideTo(s) } }; const mf = { loopCreate: function (e) { const t = this, { params: n, slidesEl: i } = t; if (!n.loop || t.virtual && t.params.virtual.enabled) return; Xp(i, ".".concat(n.slideClass, ", swiper-slide")).forEach(((e, t) => { e.setAttribute("data-swiper-slide-index", t) })), t.loopFix({ slideRealIndex: e, direction: n.centeredSlides ? void 0 : "next" }) }, loopFix: function () { let { slideRealIndex: e, slideTo: t = !0, direction: n, setTranslate: i, activeSlideIndex: r, byController: s, byMousewheel: a } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const o = this; if (!o.params.loop) return; o.emit("beforeLoopFix"); const { slides: l, allowSlidePrev: c, allowSlideNext: u, slidesEl: d, params: h } = o; if (o.allowSlidePrev = !0, o.allowSlideNext = !0, o.virtual && h.virtual.enabled) return t && (h.centeredSlides || 0 !== o.snapIndex ? h.centeredSlides && o.snapIndex < h.slidesPerView ? o.slideTo(o.virtual.slides.length + o.snapIndex, 0, !1, !0) : o.snapIndex === o.snapGrid.length - 1 && o.slideTo(o.virtual.slidesBefore, 0, !1, !0) : o.slideTo(o.virtual.slides.length, 0, !1, !0)), o.allowSlidePrev = c, o.allowSlideNext = u, void o.emit("loopFix"); const p = "auto" === h.slidesPerView ? o.slidesPerViewDynamic() : Math.ceil(parseFloat(h.slidesPerView, 10)); let f = h.loopedSlides || p; f % h.slidesPerGroup !== 0 && (f += h.slidesPerGroup - f % h.slidesPerGroup), o.loopedSlides = f; const m = [], g = []; let y = o.activeIndex; "undefined" === typeof r ? r = o.getSlideIndex(o.slides.filter((e => e.classList.contains(h.slideActiveClass)))[0]) : y = r; const v = "next" === n || !n, b = "prev" === n || !n; let _ = 0, T = 0; if (r < f) { _ = Math.max(f - r, h.slidesPerGroup); for (let e = 0; e < f - r; e += 1) { const t = e - Math.floor(e / l.length) * l.length; m.push(l.length - t - 1) } } else if (r > o.slides.length - 2 * f) { T = Math.max(r - (o.slides.length - 2 * f), h.slidesPerGroup); for (let e = 0; e < T; e += 1) { const t = e - Math.floor(e / l.length) * l.length; g.push(t) } } if (b && m.forEach((e => { o.slides[e].swiperLoopMoveDOM = !0, d.prepend(o.slides[e]), o.slides[e].swiperLoopMoveDOM = !1 })), v && g.forEach((e => { o.slides[e].swiperLoopMoveDOM = !0, d.append(o.slides[e]), o.slides[e].swiperLoopMoveDOM = !1 })), o.recalcSlides(), "auto" === h.slidesPerView && o.updateSlides(), h.watchSlidesProgress && o.updateSlidesOffset(), t) if (m.length > 0 && b) if ("undefined" === typeof e) { const e = o.slidesGrid[y], t = o.slidesGrid[y + _] - e; a ? o.setTranslate(o.translate - t) : (o.slideTo(y + _, 0, !1, !0), i && (o.touches[o.isHorizontal() ? "startX" : "startY"] += t)) } else i && o.slideToLoop(e, 0, !1, !0); else if (g.length > 0 && v) if ("undefined" === typeof e) { const e = o.slidesGrid[y], t = o.slidesGrid[y - T] - e; a ? o.setTranslate(o.translate - t) : (o.slideTo(y - T, 0, !1, !0), i && (o.touches[o.isHorizontal() ? "startX" : "startY"] += t)) } else o.slideToLoop(e, 0, !1, !0); if (o.allowSlidePrev = c, o.allowSlideNext = u, o.controller && o.controller.control && !s) { const t = { slideRealIndex: e, slideTo: !1, direction: n, setTranslate: i, activeSlideIndex: r, byController: !0 }; Array.isArray(o.controller.control) ? o.controller.control.forEach((e => { !e.destroyed && e.params.loop && e.loopFix(t) })) : o.controller.control instanceof o.constructor && o.controller.control.params.loop && o.controller.control.loopFix(t) } o.emit("loopFix") }, loopDestroy: function () { const e = this, { params: t, slidesEl: n } = e; if (!t.loop || e.virtual && e.params.virtual.enabled) return; e.recalcSlides(); const i = []; e.slides.forEach((e => { const t = "undefined" === typeof e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex; i[t] = e })), e.slides.forEach((e => { e.removeAttribute("data-swiper-slide-index") })), i.forEach((e => { n.append(e) })), e.recalcSlides(), e.slideTo(e.realIndex, 0) } }; function gf(e) { const t = this, n = Rp(), i = Bp(), r = t.touchEventsData; r.evCache.push(e); const { params: s, touches: a, enabled: o } = t; if (!o) return; if (!s.simulateTouch && "mouse" === e.pointerType) return; if (t.animating && s.preventInteractionOnTransition) return; !t.animating && s.cssMode && s.loop && t.loopFix(); let l = e; l.originalEvent && (l = l.originalEvent); let c = l.target; if ("wrapper" === s.touchEventsTarget && !t.wrapperEl.contains(c)) return; if ("which" in l && 3 === l.which) return; if ("button" in l && l.button > 0) return; if (r.isTouched && r.isMoved) return; const u = !!s.noSwipingClass && "" !== s.noSwipingClass, d = e.composedPath ? e.composedPath() : e.path; u && l.target && l.target.shadowRoot && d && (c = d[0]); const h = s.noSwipingSelector ? s.noSwipingSelector : ".".concat(s.noSwipingClass), p = !(!l.target || !l.target.shadowRoot); if (s.noSwiping && (p ? function (e) { return function t(n) { if (!n || n === Rp() || n === Bp()) return null; n.assignedSlot && (n = n.assignedSlot); const i = n.closest(e); return i || n.getRootNode ? i || t(n.getRootNode().host) : null }(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this) }(h, c) : c.closest(h))) return void (t.allowClick = !0); if (s.swipeHandler && !c.closest(s.swipeHandler)) return; a.currentX = l.pageX, a.currentY = l.pageY; const f = a.currentX, m = a.currentY, g = s.edgeSwipeDetection || s.iOSEdgeSwipeDetection, y = s.edgeSwipeThreshold || s.iOSEdgeSwipeThreshold; if (g && (f <= y || f >= i.innerWidth - y)) { if ("prevent" !== g) return; e.preventDefault() } Object.assign(r, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), a.startX = f, a.startY = m, r.touchStartTime = zp(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, s.threshold > 0 && (r.allowThresholdMove = !1); let v = !0; c.matches(r.focusableElements) && (v = !1, "SELECT" === c.nodeName && (r.isTouched = !1)), n.activeElement && n.activeElement.matches(r.focusableElements) && n.activeElement !== c && n.activeElement.blur(); const b = v && t.allowTouchMove && s.touchStartPreventDefault; !s.touchStartForcePreventDefault && !b || c.isContentEditable || l.preventDefault(), t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !s.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", l) } function yf(e) { const t = Rp(), n = this, i = n.touchEventsData, { params: r, touches: s, rtlTranslate: a, enabled: o } = n; if (!o) return; if (!r.simulateTouch && "mouse" === e.pointerType) return; let l = e; if (l.originalEvent && (l = l.originalEvent), !i.isTouched) return void (i.startMoving && i.isScrolling && n.emit("touchMoveOpposite", l)); const c = i.evCache.findIndex((e => e.pointerId === l.pointerId)); c >= 0 && (i.evCache[c] = l); const u = i.evCache.length > 1 ? i.evCache[0] : l, d = u.pageX, h = u.pageY; if (l.preventedByNestedSwiper) return s.startX = d, void (s.startY = h); if (!n.allowTouchMove) return l.target.matches(i.focusableElements) || (n.allowClick = !1), void (i.isTouched && (Object.assign(s, { startX: d, startY: h, prevX: n.touches.currentX, prevY: n.touches.currentY, currentX: d, currentY: h }), i.touchStartTime = zp())); if (r.touchReleaseOnEdges && !r.loop) if (n.isVertical()) { if (h < s.startY && n.translate <= n.maxTranslate() || h > s.startY && n.translate >= n.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1) } else if (d < s.startX && n.translate <= n.maxTranslate() || d > s.startX && n.translate >= n.minTranslate()) return; if (t.activeElement && l.target === t.activeElement && l.target.matches(i.focusableElements)) return i.isMoved = !0, void (n.allowClick = !1); if (i.allowTouchCallbacks && n.emit("touchMove", l), l.targetTouches && l.targetTouches.length > 1) return; s.currentX = d, s.currentY = h; const p = s.currentX - s.startX, f = s.currentY - s.startY; if (n.params.threshold && Math.sqrt(p ** 2 + f ** 2) < n.params.threshold) return; if ("undefined" === typeof i.isScrolling) { let e; n.isHorizontal() && s.currentY === s.startY || n.isVertical() && s.currentX === s.startX ? i.isScrolling = !1 : p * p + f * f >= 25 && (e = 180 * Math.atan2(Math.abs(f), Math.abs(p)) / Math.PI, i.isScrolling = n.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle) } if (i.isScrolling && n.emit("touchMoveOpposite", l), "undefined" === typeof i.startMoving && (s.currentX === s.startX && s.currentY === s.startY || (i.startMoving = !0)), i.isScrolling || n.zoom && n.params.zoom && n.params.zoom.enabled && i.evCache.length > 1) return void (i.isTouched = !1); if (!i.startMoving) return; n.allowClick = !1, !r.cssMode && l.cancelable && l.preventDefault(), r.touchMoveStopPropagation && !r.nested && l.stopPropagation(); let m = n.isHorizontal() ? p : f, g = n.isHorizontal() ? s.currentX - s.previousX : s.currentY - s.previousY; r.oneWayMovement && (m = Math.abs(m) * (a ? 1 : -1), g = Math.abs(g) * (a ? 1 : -1)), s.diff = m, m *= r.touchRatio, a && (m = -m, g = -g); const y = n.touchesDirection; n.swipeDirection = m > 0 ? "prev" : "next", n.touchesDirection = g > 0 ? "prev" : "next"; const v = n.params.loop && !r.cssMode; if (!i.isMoved) { if (v && n.loopFix({ direction: n.swipeDirection }), i.startTranslate = n.getTranslate(), n.setTransition(0), n.animating) { const e = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); n.wrapperEl.dispatchEvent(e) } i.allowMomentumBounce = !1, !r.grabCursor || !0 !== n.allowSlideNext && !0 !== n.allowSlidePrev || n.setGrabCursor(!0), n.emit("sliderFirstMove", l) } let b; i.isMoved && y !== n.touchesDirection && v && Math.abs(m) >= 1 && (n.loopFix({ direction: n.swipeDirection, setTranslate: !0 }), b = !0), n.emit("sliderMove", l), i.isMoved = !0, i.currentTranslate = m + i.startTranslate; let _ = !0, T = r.resistanceRatio; if (r.touchReleaseOnEdges && (T = 0), m > 0 ? (v && !b && i.currentTranslate > (r.centeredSlides ? n.minTranslate() - n.size / 2 : n.minTranslate()) && n.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), i.currentTranslate > n.minTranslate() && (_ = !1, r.resistance && (i.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + i.startTranslate + m) ** T))) : m < 0 && (v && !b && i.currentTranslate < (r.centeredSlides ? n.maxTranslate() + n.size / 2 : n.maxTranslate()) && n.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: n.slides.length - ("auto" === r.slidesPerView ? n.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10))) }), i.currentTranslate < n.maxTranslate() && (_ = !1, r.resistance && (i.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - i.startTranslate - m) ** T))), _ && (l.preventedByNestedSwiper = !0), !n.allowSlideNext && "next" === n.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !n.allowSlidePrev && "prev" === n.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), n.allowSlidePrev || n.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) { if (!(Math.abs(m) > r.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate); if (!i.allowThresholdMove) return i.allowThresholdMove = !0, s.startX = s.currentX, s.startY = s.currentY, i.currentTranslate = i.startTranslate, void (s.diff = n.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY) } r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && n.freeMode || r.watchSlidesProgress) && (n.updateActiveIndex(), n.updateSlidesClasses()), n.params.freeMode && r.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(), n.updateProgress(i.currentTranslate), n.setTranslate(i.currentTranslate)) } function vf(e) { const t = this, n = t.touchEventsData, i = n.evCache.findIndex((t => t.pointerId === e.pointerId)); if (i >= 0 && n.evCache.splice(i, 1), ["pointercancel", "pointerout", "pointerleave"].includes(e.type)) { if (!("pointercancel" === e.type && (t.browser.isSafari || t.browser.isWebView))) return } const { params: r, touches: s, rtlTranslate: a, slidesGrid: o, enabled: l } = t; if (!l) return; if (!r.simulateTouch && "mouse" === e.pointerType) return; let c = e; if (c.originalEvent && (c = c.originalEvent), n.allowTouchCallbacks && t.emit("touchEnd", c), n.allowTouchCallbacks = !1, !n.isTouched) return n.isMoved && r.grabCursor && t.setGrabCursor(!1), n.isMoved = !1, void (n.startMoving = !1); r.grabCursor && n.isMoved && n.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const u = zp(), d = u - n.touchStartTime; if (t.allowClick) { const e = c.path || c.composedPath && c.composedPath(); t.updateClickedSlide(e && e[0] || c.target), t.emit("tap click", c), d < 300 && u - n.lastClickTime < 300 && t.emit("doubleTap doubleClick", c) } if (n.lastClickTime = zp(), Fp((() => { t.destroyed || (t.allowClick = !0) })), !n.isTouched || !n.isMoved || !t.swipeDirection || 0 === s.diff || n.currentTranslate === n.startTranslate) return n.isTouched = !1, n.isMoved = !1, void (n.startMoving = !1); let h; if (n.isTouched = !1, n.isMoved = !1, n.startMoving = !1, h = r.followFinger ? a ? t.translate : -t.translate : -n.currentTranslate, r.cssMode) return; if (t.params.freeMode && r.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: h }); let p = 0, f = t.slidesSizesGrid[0]; for (let b = 0; b < o.length; b += b < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup) { const e = b < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; "undefined" !== typeof o[b + e] ? h >= o[b] && h < o[b + e] && (p = b, f = o[b + e] - o[b]) : h >= o[b] && (p = b, f = o[o.length - 1] - o[o.length - 2]) } let m = null, g = null; r.rewind && (t.isBeginning ? g = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (m = 0)); const y = (h - o[p]) / f, v = p < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; if (d > r.longSwipesMs) { if (!r.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (y >= r.longSwipesRatio ? t.slideTo(r.rewind && t.isEnd ? m : p + v) : t.slideTo(p)), "prev" === t.swipeDirection && (y > 1 - r.longSwipesRatio ? t.slideTo(p + v) : null !== g && y < 0 && Math.abs(y) > r.longSwipesRatio ? t.slideTo(g) : t.slideTo(p)) } else { if (!r.shortSwipes) return void t.slideTo(t.activeIndex); t.navigation && (c.target === t.navigation.nextEl || c.target === t.navigation.prevEl) ? c.target === t.navigation.nextEl ? t.slideTo(p + v) : t.slideTo(p) : ("next" === t.swipeDirection && t.slideTo(null !== m ? m : p + v), "prev" === t.swipeDirection && t.slideTo(null !== g ? g : p)) } } function bf() { const e = this, { params: t, el: n } = e; if (n && 0 === n.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: i, allowSlidePrev: r, snapGrid: s } = e, a = e.virtual && e.params.virtual.enabled; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(); const o = a && t.loop; !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || o ? e.params.loop && !a ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout((() => { e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume() }), 500)), e.allowSlidePrev = r, e.allowSlideNext = i, e.params.watchOverflow && s !== e.snapGrid && e.checkOverflow() } function _f(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function Tf() { const e = this, { wrapperEl: t, rtlTranslate: n, enabled: i } = e; if (!i) return; let r; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const s = e.maxTranslate() - e.minTranslate(); r = 0 === s ? 0 : (e.translate - e.minTranslate()) / s, r !== e.progress && e.updateProgress(n ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } function Sf(e) { const t = this; of(t, e.target), t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update() } let wf = !1; function xf() { } const kf = (e, t) => { const n = Rp(), { params: i, el: r, wrapperEl: s, device: a } = e, o = !!i.nested, l = "on" === t ? "addEventListener" : "removeEventListener", c = t; r[l]("pointerdown", e.onTouchStart, { passive: !1 }), n[l]("pointermove", e.onTouchMove, { passive: !1, capture: o }), n[l]("pointerup", e.onTouchEnd, { passive: !0 }), n[l]("pointercancel", e.onTouchEnd, { passive: !0 }), n[l]("pointerout", e.onTouchEnd, { passive: !0 }), n[l]("pointerleave", e.onTouchEnd, { passive: !0 }), (i.preventClicks || i.preventClicksPropagation) && r[l]("click", e.onClick, !0), i.cssMode && s[l]("scroll", e.onScroll), i.updateOnWindowResize ? e[c](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", bf, !0) : e[c]("observerUpdate", bf, !0), r[l]("load", e.onLoad, { capture: !0 }) }; const Ef = (e, t) => e.grid && t.grid && t.grid.rows > 1; const Cf = { setBreakpoint: function () { const e = this, { realIndex: t, initialized: n, params: i, el: r } = e, s = i.breakpoints; if (!s || s && 0 === Object.keys(s).length) return; const a = e.getBreakpoint(s, e.params.breakpointsBase, e.el); if (!a || e.currentBreakpoint === a) return; const o = (a in s ? s[a] : void 0) || e.originalParams, l = Ef(e, i), c = Ef(e, o), u = i.enabled; l && !c ? (r.classList.remove("".concat(i.containerModifierClass, "grid"), "".concat(i.containerModifierClass, "grid-column")), e.emitContainerClasses()) : !l && c && (r.classList.add("".concat(i.containerModifierClass, "grid")), (o.grid.fill && "column" === o.grid.fill || !o.grid.fill && "column" === i.grid.fill) && r.classList.add("".concat(i.containerModifierClass, "grid-column")), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => { const n = i[t] && i[t].enabled, r = o[t] && o[t].enabled; n && !r && e[t].disable(), !n && r && e[t].enable() })); const d = o.direction && o.direction !== i.direction, h = i.loop && (o.slidesPerView !== i.slidesPerView || d); d && n && e.changeDirection(), Wp(e.params, o); const p = e.params.enabled; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), u && !p ? e.disable() : !u && p && e.enable(), e.currentBreakpoint = a, e.emit("_beforeBreakpoint", o), h && n && (e.loopDestroy(), e.loopCreate(t), e.updateSlides()), e.emit("breakpoint", o) }, getBreakpoint: function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "window", n = arguments.length > 2 ? arguments[2] : void 0; if (!e || "container" === t && !n) return; let i = !1; const r = Bp(), s = "window" === t ? r.innerHeight : n.clientHeight, a = Object.keys(e).map((e => { if ("string" === typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: s * t, point: e } } return { value: e, point: e } })); a.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let o = 0; o < a.length; o += 1) { const { point: e, value: s } = a[o]; "window" === t ? r.matchMedia("(min-width: ".concat(s, "px)")).matches && (i = e) : s <= n.clientWidth && (i = e) } return i || "max" } }; const Pf = { init: !0, direction: "horizontal", oneWayMovement: !1, touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopedSlides: null, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; function If(e, t) { return function () { let n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const i = Object.keys(n)[0], r = n[i]; "object" === typeof r && null !== r ? (["navigation", "pagination", "scrollbar"].indexOf(i) >= 0 && !0 === e[i] && (e[i] = { auto: !0 }), i in e && "enabled" in r ? (!0 === e[i] && (e[i] = { enabled: !0 }), "object" !== typeof e[i] || "enabled" in e[i] || (e[i].enabled = !0), e[i] || (e[i] = { enabled: !1 }), Wp(t, n)) : Wp(t, n)) : Wp(t, n) } } const Lf = { eventsEmitter: af, update: uf, translate: df, transition: pf, slide: ff, loop: mf, grabCursor: { setGrabCursor: function (e) { const t = this; if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const n = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl; t.isElement && (t.__preventObserver__ = !0), n.style.cursor = "move", n.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame((() => { t.__preventObserver__ = !1 })) }, unsetGrabCursor: function () { const e = this; e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame((() => { e.__preventObserver__ = !1 }))) } }, events: { attachEvents: function () { const e = this, t = Rp(), { params: n } = e; e.onTouchStart = gf.bind(e), e.onTouchMove = yf.bind(e), e.onTouchEnd = vf.bind(e), n.cssMode && (e.onScroll = Tf.bind(e)), e.onClick = _f.bind(e), e.onLoad = Sf.bind(e), wf || (t.addEventListener("touchstart", xf), wf = !0), kf(e, "on") }, detachEvents: function () { kf(this, "off") } }, breakpoints: Cf, checkOverflow: { checkOverflow: function () { const e = this, { isLocked: t, params: n } = e, { slidesOffsetBefore: i } = n; if (i) { const t = e.slides.length - 1, n = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * i; e.isLocked = e.size > n } else e.isLocked = 1 === e.snapGrid.length; !0 === n.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === n.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } }, classes: { addClasses: function () { const e = this, { classNames: t, params: n, rtl: i, el: r, device: s } = e, a = function (e, t) { const n = []; return e.forEach((e => { "object" === typeof e ? Object.keys(e).forEach((i => { e[i] && n.push(t + i) })) : "string" === typeof e && n.push(t + e) })), n }(["initialized", n.direction, { "free-mode": e.params.freeMode && n.freeMode.enabled }, { autoheight: n.autoHeight }, { rtl: i }, { grid: n.grid && n.grid.rows > 1 }, { "grid-column": n.grid && n.grid.rows > 1 && "column" === n.grid.fill }, { android: s.android }, { ios: s.ios }, { "css-mode": n.cssMode }, { centered: n.cssMode && n.centeredSlides }, { "watch-progress": n.watchSlidesProgress }], n.containerModifierClass); t.push(...a), r.classList.add(...t), e.emitContainerClasses() }, removeClasses: function () { const { el: e, classNames: t } = this; e.classList.remove(...t), this.emitContainerClasses() } } }, Of = {}; class Af { constructor() { let e, t; for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++)i[r] = arguments[r]; 1 === i.length && i[0].constructor && "Object" === Object.prototype.toString.call(i[0]).slice(8, -1) ? t = i[0] : [e, t] = i, t || (t = {}), t = Wp({}, t), e && !t.el && (t.el = e); const s = Rp(); if (t.el && "string" === typeof t.el && s.querySelectorAll(t.el).length > 1) { const e = []; return s.querySelectorAll(t.el).forEach((n => { const i = Wp({}, t, { el: n }); e.push(new Af(i)) })), e } const a = this; a.__swiper__ = !0, a.support = nf(), a.device = rf({ userAgent: t.userAgent }), a.browser = sf(), a.eventsListeners = {}, a.eventsAnyListeners = [], a.modules = [...a.__modules__], t.modules && Array.isArray(t.modules) && a.modules.push(...t.modules); const o = {}; a.modules.forEach((e => { e({ params: t, swiper: a, extendParams: If(t, o), on: a.on.bind(a), once: a.once.bind(a), off: a.off.bind(a), emit: a.emit.bind(a) }) })); const l = Wp({}, Pf, o); return a.params = Wp({}, l, Of, t), a.originalParams = Wp({}, a.params), a.passedParams = Wp({}, t), a.params && a.params.on && Object.keys(a.params.on).forEach((e => { a.on(e, a.params.on[e]) })), a.params && a.params.onAny && a.onAny(a.params.onAny), Object.assign(a, { enabled: a.params.enabled, el: e, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === a.params.direction, isVertical: () => "vertical" === a.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: a.params.allowSlideNext, allowSlidePrev: a.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: a.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, evCache: [] }, allowClick: !0, allowTouchMove: a.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), a.emit("_swiper"), a.params.init && a.init(), a } getSlideIndex(e) { const { slidesEl: t, params: n } = this, i = Yp(Xp(t, ".".concat(n.slideClass, ", swiper-slide"))[0]); return Yp(e) - i } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.filter((t => 1 * t.getAttribute("data-swiper-slide-index") === e))[0]) } recalcSlides() { const { slidesEl: e, params: t } = this; this.slides = Xp(e, ".".concat(t.slideClass, ", swiper-slide")) } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const n = this; e = Math.min(Math.max(e, 0), 1); const i = n.minTranslate(), r = (n.maxTranslate() - i) * e + i; n.translateTo(r, "undefined" === typeof t ? 0 : t), n.updateActiveIndex(), n.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass))); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.forEach((n => { const i = e.getSlideClasses(n); t.push({ slideEl: n, classNames: i }), e.emit("_slideClass", n, i) })), e.emit("_slideClasses", t) } slidesPerViewDynamic() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "current", t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const { params: n, slides: i, slidesGrid: r, slidesSizesGrid: s, size: a, activeIndex: o } = this; let l = 1; if (n.centeredSlides) { let e, t = i[o].swiperSlideSize; for (let n = o + 1; n < i.length; n += 1)i[n] && !e && (t += i[n].swiperSlideSize, l += 1, t > a && (e = !0)); for (let n = o - 1; n >= 0; n -= 1)i[n] && !e && (t += i[n].swiperSlideSize, l += 1, t > a && (e = !0)) } else if ("current" === e) for (let c = o + 1; c < i.length; c += 1) { (t ? r[c] + s[c] - r[o] < a : r[c] - r[o] < a) && (l += 1) } else for (let c = o - 1; c >= 0; c -= 1) { r[o] - r[c] < a && (l += 1) } return l } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: n } = e; function i() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, n = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(n), e.updateActiveIndex(), e.updateSlidesClasses() } let r; if (n.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach((t => { t.complete && of(e, t) })), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled) i(), e.params.autoHeight && e.updateAutoHeight(); else { if (("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides) { const t = e.virtual && e.params.virtual.enabled ? e.virtual.slides : e.slides; r = e.slideTo(t.length - 1, 0, !1, !0) } else r = e.slideTo(e.activeIndex, 0, !1, !0); r || i() } n.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const n = this, i = n.params.direction; return e || (e = "horizontal" === i ? "vertical" : "horizontal"), e === i || "horizontal" !== e && "vertical" !== e || (n.el.classList.remove("".concat(n.params.containerModifierClass).concat(i)), n.el.classList.add("".concat(n.params.containerModifierClass).concat(e)), n.emitContainerClasses(), n.params.direction = e, n.slides.forEach((t => { "vertical" === e ? t.style.width = "" : t.style.height = "" })), n.emit("changeDirection"), t && n.update()), n } changeLanguageDirection(e) { const t = this; t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add("".concat(t.params.containerModifierClass, "rtl")), t.el.dir = "rtl") : (t.el.classList.remove("".concat(t.params.containerModifierClass, "rtl")), t.el.dir = "ltr"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; let n = e || t.params.el; if ("string" === typeof n && (n = document.querySelector(n)), !n) return !1; n.swiper = t, n.shadowEl && (t.isElement = !0); const i = () => ".".concat((t.params.wrapperClass || "").trim().split(" ").join(".")); let r = (() => { if (n && n.shadowRoot && n.shadowRoot.querySelector) { return n.shadowRoot.querySelector(i()) } return Xp(n, i())[0] })(); return !r && t.params.createElements && (r = Kp("div", t.params.wrapperClass), n.append(r), Xp(n, ".".concat(t.params.slideClass)).forEach((e => { r.append(e) }))), Object.assign(t, { el: n, wrapperEl: r, slidesEl: t.isElement ? n : r, mounted: !0, rtl: "rtl" === n.dir.toLowerCase() || "rtl" === $p(n, "direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === n.dir.toLowerCase() || "rtl" === $p(n, "direction")), wrongRTL: "-webkit-box" === $p(r, "display") }), !0 } init(e) { const t = this; if (t.initialized) return t; return !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents(), [...t.el.querySelectorAll('[loading="lazy"]')].forEach((e => { e.complete ? of(t, e) : e.addEventListener("load", (e => { of(t, e.target) })) })), cf(t), t.initialized = !0, cf(t), t.emit("init"), t.emit("afterInit")), t } destroy() { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const n = this, { params: i, el: r, wrapperEl: s, slides: a } = n; return "undefined" === typeof n.params || n.destroyed || (n.emit("beforeDestroy"), n.initialized = !1, n.detachEvents(), i.loop && n.loopDestroy(), t && (n.removeClasses(), r.removeAttribute("style"), s.removeAttribute("style"), a && a.length && a.forEach((e => { e.classList.remove(i.slideVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass), e.removeAttribute("style"), e.removeAttribute("data-swiper-slide-index") }))), n.emit("destroy"), Object.keys(n.eventsListeners).forEach((e => { n.off(e) })), !1 !== e && (n.el.swiper = null, function (e) { const t = e; Object.keys(t).forEach((e => { try { t[e] = null } catch (n) { } try { delete t[e] } catch (n) { } })) }(n)), n.destroyed = !0), null } static extendDefaults(e) { Wp(Of, e) } static get extendedDefaults() { return Of } static get defaults() { return Pf } static installModule(e) { Af.prototype.__modules__ || (Af.prototype.__modules__ = []); const t = Af.prototype.__modules__; "function" === typeof e && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach((e => Af.installModule(e))), Af) : (Af.installModule(e), Af) } } Object.keys(Lf).forEach((e => { Object.keys(Lf[e]).forEach((t => { Af.prototype[t] = Lf[e][t] })) })), Af.use([function (e) { let { swiper: t, on: n, emit: i } = e; const r = Bp(); let s = null, a = null; const o = () => { t && !t.destroyed && t.initialized && (i("beforeResize"), i("resize")) }, l = () => { t && !t.destroyed && t.initialized && i("orientationchange") }; n("init", (() => { t.params.resizeObserver && "undefined" !== typeof r.ResizeObserver ? t && !t.destroyed && t.initialized && (s = new ResizeObserver((e => { a = r.requestAnimationFrame((() => { const { width: n, height: i } = t; let r = n, s = i; e.forEach((e => { let { contentBoxSize: n, contentRect: i, target: a } = e; a && a !== t.el || (r = i ? i.width : (n[0] || n).inlineSize, s = i ? i.height : (n[0] || n).blockSize) })), r === n && s === i || o() })) })), s.observe(t.el)) : (r.addEventListener("resize", o), r.addEventListener("orientationchange", l)) })), n("destroy", (() => { a && r.cancelAnimationFrame(a), s && s.unobserve && t.el && (s.unobserve(t.el), s = null), r.removeEventListener("resize", o), r.removeEventListener("orientationchange", l) })) }, function (e) { let { swiper: t, extendParams: n, on: i, emit: r } = e; const s = [], a = Bp(), o = function (e) { let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const i = new (a.MutationObserver || a.WebkitMutationObserver)((e => { if (t.__preventObserver__) return; if (1 === e.length) return void r("observerUpdate", e[0]); const n = function () { r("observerUpdate", e[0]) }; a.requestAnimationFrame ? a.requestAnimationFrame(n) : a.setTimeout(n, 0) })); i.observe(e, { attributes: "undefined" === typeof n.attributes || n.attributes, childList: "undefined" === typeof n.childList || n.childList, characterData: "undefined" === typeof n.characterData || n.characterData }), s.push(i) }; n({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), i("init", (() => { if (t.params.observer) { if (t.params.observeParents) { const e = Qp(t.el); for (let t = 0; t < e.length; t += 1)o(e[t]) } o(t.el, { childList: t.params.observeSlideChildren }), o(t.wrapperEl, { attributes: !1 }) } })), i("destroy", (() => { s.forEach((e => { e.disconnect() })), s.splice(0, s.length) })) }]); const Nf = Af; function jf(e) { let { swiper: t, extendParams: n, on: i, emit: r } = e; const s = Rp(), a = Bp(); function o(e) { if (!t.enabled) return; const { rtlTranslate: n } = t; let i = e; i.originalEvent && (i = i.originalEvent); const o = i.keyCode || i.charCode, l = t.params.keyboard.pageUpDown, c = l && 33 === o, u = l && 34 === o, d = 37 === o, h = 39 === o, p = 38 === o, f = 40 === o; if (!t.allowSlideNext && (t.isHorizontal() && h || t.isVertical() && f || u)) return !1; if (!t.allowSlidePrev && (t.isHorizontal() && d || t.isVertical() && p || c)) return !1; if (!(i.shiftKey || i.altKey || i.ctrlKey || i.metaKey) && (!s.activeElement || !s.activeElement.nodeName || "input" !== s.activeElement.nodeName.toLowerCase() && "textarea" !== s.activeElement.nodeName.toLowerCase())) { if (t.params.keyboard.onlyInViewport && (c || u || d || h || p || f)) { let e = !1; if (Qp(t.el, ".".concat(t.params.slideClass, ", swiper-slide")).length > 0 && 0 === Qp(t.el, ".".concat(t.params.slideActiveClass)).length) return; const i = t.el, r = i.clientWidth, s = i.clientHeight, o = a.innerWidth, l = a.innerHeight, c = function (e) { const t = Bp(), n = Rp(), i = e.getBoundingClientRect(), r = n.body, s = e.clientTop || r.clientTop || 0, a = e.clientLeft || r.clientLeft || 0, o = e === t ? t.scrollY : e.scrollTop, l = e === t ? t.scrollX : e.scrollLeft; return { top: i.top + o - s, left: i.left + l - a } }(i); n && (c.left -= i.scrollLeft); const u = [[c.left, c.top], [c.left + r, c.top], [c.left, c.top + s], [c.left + r, c.top + s]]; for (let t = 0; t < u.length; t += 1) { const n = u[t]; if (n[0] >= 0 && n[0] <= o && n[1] >= 0 && n[1] <= l) { if (0 === n[0] && 0 === n[1]) continue; e = !0 } } if (!e) return } t.isHorizontal() ? ((c || u || d || h) && (i.preventDefault ? i.preventDefault() : i.returnValue = !1), ((u || h) && !n || (c || d) && n) && t.slideNext(), ((c || d) && !n || (u || h) && n) && t.slidePrev()) : ((c || u || p || f) && (i.preventDefault ? i.preventDefault() : i.returnValue = !1), (u || f) && t.slideNext(), (c || p) && t.slidePrev()), r("keyPress", o) } } function l() { t.keyboard.enabled || (s.addEventListener("keydown", o), t.keyboard.enabled = !0) } function c() { t.keyboard.enabled && (s.removeEventListener("keydown", o), t.keyboard.enabled = !1) } t.keyboard = { enabled: !1 }, n({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }), i("init", (() => { t.params.keyboard.enabled && l() })), i("destroy", (() => { t.keyboard.enabled && c() })), Object.assign(t.keyboard, { enable: l, disable: c }) } function Df(e, t, n, i) { return e.params.createElements && Object.keys(i).forEach((r => { if (!n[r] && !0 === n.auto) { let s = Xp(e.el, ".".concat(i[r]))[0]; s || (s = Kp("div", i[r]), s.className = i[r], e.el.append(s)), n[r] = s, t[r] = s } })), n } function Mf(e) { let { swiper: t, extendParams: n, on: i, emit: r } = e; n({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), t.navigation = { nextEl: null, prevEl: null }; const s = e => (Array.isArray(e) || (e = [e].filter((e => !!e))), e); function a(e) { let n; return e && "string" === typeof e && t.isElement && (n = t.el.shadowRoot.querySelector(e), n) ? n : (e && ("string" === typeof e && (n = [...document.querySelectorAll(e)]), t.params.uniqueNavElements && "string" === typeof e && n.length > 1 && 1 === t.el.querySelectorAll(e).length && (n = t.el.querySelector(e))), e && !n ? e : n) } function o(e, n) { const i = t.params.navigation; (e = s(e)).forEach((e => { e && (e.classList[n ? "add" : "remove"](...i.disabledClass.split(" ")), "BUTTON" === e.tagName && (e.disabled = n), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](i.lockClass)) })) } function l() { const { nextEl: e, prevEl: n } = t.navigation; if (t.params.loop) return o(n, !1), void o(e, !1); o(n, t.isBeginning && !t.params.rewind), o(e, t.isEnd && !t.params.rewind) } function c(e) { e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), r("navigationPrev")) } function u(e) { e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), r("navigationNext")) } function d() { const e = t.params.navigation; if (t.params.navigation = Df(t, t.originalParams.navigation, t.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !e.nextEl && !e.prevEl) return; let n = a(e.nextEl), i = a(e.prevEl); Object.assign(t.navigation, { nextEl: n, prevEl: i }), n = s(n), i = s(i); const r = (n, i) => { n && n.addEventListener("click", "next" === i ? u : c), !t.enabled && n && n.classList.add(...e.lockClass.split(" ")) }; n.forEach((e => r(e, "next"))), i.forEach((e => r(e, "prev"))) } function h() { let { nextEl: e, prevEl: n } = t.navigation; e = s(e), n = s(n); const i = (e, n) => { e.removeEventListener("click", "next" === n ? u : c), e.classList.remove(...t.params.navigation.disabledClass.split(" ")) }; e.forEach((e => i(e, "next"))), n.forEach((e => i(e, "prev"))) } i("init", (() => { !1 === t.params.navigation.enabled ? p() : (d(), l()) })), i("toEdge fromEdge lock unlock", (() => { l() })), i("destroy", (() => { h() })), i("enable disable", (() => { let { nextEl: e, prevEl: n } = t.navigation; e = s(e), n = s(n), [...e, ...n].filter((e => !!e)).forEach((e => e.classList[t.enabled ? "remove" : "add"](t.params.navigation.lockClass))) })), i("click", ((e, n) => { let { nextEl: i, prevEl: a } = t.navigation; i = s(i), a = s(a); const o = n.target; if (t.params.navigation.hideOnClick && !a.includes(o) && !i.includes(o)) { if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === o || t.pagination.el.contains(o))) return; let e; i.length ? e = i[0].classList.contains(t.params.navigation.hiddenClass) : a.length && (e = a[0].classList.contains(t.params.navigation.hiddenClass)), r(!0 === e ? "navigationShow" : "navigationHide"), [...i, ...a].filter((e => !!e)).forEach((e => e.classList.toggle(t.params.navigation.hiddenClass))) } })); const p = () => { t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")), h() }; Object.assign(t.navigation, { enable: () => { t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")), d(), l() }, disable: p, update: l, init: d, destroy: h }) } function Rf() { return ".".concat((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "").trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")) } function Uf(e) { let { swiper: t, extendParams: n, on: i, emit: r } = e; const s = "swiper-pagination"; let a; n({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: "".concat(s, "-bullet"), bulletActiveClass: "".concat(s, "-bullet-active"), modifierClass: "".concat(s, "-"), currentClass: "".concat(s, "-current"), totalClass: "".concat(s, "-total"), hiddenClass: "".concat(s, "-hidden"), progressbarFillClass: "".concat(s, "-progressbar-fill"), progressbarOppositeClass: "".concat(s, "-progressbar-opposite"), clickableClass: "".concat(s, "-clickable"), lockClass: "".concat(s, "-lock"), horizontalClass: "".concat(s, "-horizontal"), verticalClass: "".concat(s, "-vertical"), paginationDisabledClass: "".concat(s, "-disabled") } }), t.pagination = { el: null, bullets: [] }; let o = 0; const l = e => (Array.isArray(e) || (e = [e].filter((e => !!e))), e); function c() { return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && 0 === t.pagination.el.length } function u(e, n) { const { bulletActiveClass: i } = t.params.pagination; e && (e = e["".concat("prev" === n ? "previous" : "next", "ElementSibling")]) && (e.classList.add("".concat(i, "-").concat(n)), (e = e["".concat("prev" === n ? "previous" : "next", "ElementSibling")]) && e.classList.add("".concat(i, "-").concat(n, "-").concat(n))) } function d(e) { const n = e.target.closest(Rf(t.params.pagination.bulletClass)); if (!n) return; e.preventDefault(); const i = Yp(n) * t.params.slidesPerGroup; if (t.params.loop) { if (t.realIndex === i) return; const e = t.getSlideIndexByData(i), n = t.getSlideIndexByData(t.realIndex); e > t.slides.length - t.loopedSlides && t.loopFix({ direction: e > n ? "next" : "prev", activeSlideIndex: e, slideTo: !1 }), t.slideToLoop(i) } else t.slideTo(i) } function h() { const e = t.rtl, n = t.params.pagination; if (c()) return; let i, s, d = t.pagination.el; d = l(d); const h = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length, p = t.params.loop ? Math.ceil(h / t.params.slidesPerGroup) : t.snapGrid.length; if (t.params.loop ? (s = t.previousRealIndex || 0, i = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : "undefined" !== typeof t.snapIndex ? (i = t.snapIndex, s = t.previousSnapIndex) : (s = t.previousIndex || 0, i = t.activeIndex || 0), "bullets" === n.type && t.pagination.bullets && t.pagination.bullets.length > 0) { const r = t.pagination.bullets; let l, c, h; if (n.dynamicBullets && (a = Jp(r[0], t.isHorizontal() ? "width" : "height", !0), d.forEach((e => { e.style[t.isHorizontal() ? "width" : "height"] = "".concat(a * (n.dynamicMainBullets + 4), "px") })), n.dynamicMainBullets > 1 && void 0 !== s && (o += i - (s || 0), o > n.dynamicMainBullets - 1 ? o = n.dynamicMainBullets - 1 : o < 0 && (o = 0)), l = Math.max(i - o, 0), c = l + (Math.min(r.length, n.dynamicMainBullets) - 1), h = (c + l) / 2), r.forEach((e => { const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => "".concat(n.bulletActiveClass).concat(e)))].map((e => "string" === typeof e && e.includes(" ") ? e.split(" ") : e)).flat(); e.classList.remove(...t) })), d.length > 1) r.forEach((e => { const t = Yp(e); t === i && e.classList.add(...n.bulletActiveClass.split(" ")), n.dynamicBullets && (t >= l && t <= c && e.classList.add(..."".concat(n.bulletActiveClass, "-main").split(" ")), t === l && u(e, "prev"), t === c && u(e, "next")) })); else { const e = r[i]; if (e && e.classList.add(...n.bulletActiveClass.split(" ")), n.dynamicBullets) { const e = r[l], t = r[c]; for (let i = l; i <= c; i += 1)r[i] && r[i].classList.add(..."".concat(n.bulletActiveClass, "-main").split(" ")); u(e, "prev"), u(t, "next") } } if (n.dynamicBullets) { const i = Math.min(r.length, n.dynamicMainBullets + 4), s = (a * i - a) / 2 - h * a, o = e ? "right" : "left"; r.forEach((e => { e.style[t.isHorizontal() ? o : "top"] = "".concat(s, "px") })) } } d.forEach(((e, s) => { if ("fraction" === n.type && (e.querySelectorAll(Rf(n.currentClass)).forEach((e => { e.textContent = n.formatFractionCurrent(i + 1) })), e.querySelectorAll(Rf(n.totalClass)).forEach((e => { e.textContent = n.formatFractionTotal(p) }))), "progressbar" === n.type) { let r; r = n.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical"; const s = (i + 1) / p; let a = 1, o = 1; "horizontal" === r ? a = s : o = s, e.querySelectorAll(Rf(n.progressbarFillClass)).forEach((e => { e.style.transform = "translate3d(0,0,0) scaleX(".concat(a, ") scaleY(").concat(o, ")"), e.style.transitionDuration = "".concat(t.params.speed, "ms") })) } "custom" === n.type && n.renderCustom ? (e.innerHTML = n.renderCustom(t, i + 1, p), 0 === s && r("paginationRender", e)) : (0 === s && r("paginationRender", e), r("paginationUpdate", e)), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](n.lockClass) })) } function p() { const e = t.params.pagination; if (c()) return; const n = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length; let i = t.pagination.el; i = l(i); let s = ""; if ("bullets" === e.type) { let i = t.params.loop ? Math.ceil(n / t.params.slidesPerGroup) : t.snapGrid.length; t.params.freeMode && t.params.freeMode.enabled && i > n && (i = n); for (let n = 0; n < i; n += 1)e.renderBullet ? s += e.renderBullet.call(t, n, e.bulletClass) : s += "<".concat(e.bulletElement, ' class="').concat(e.bulletClass, '"></').concat(e.bulletElement, ">") } "fraction" === e.type && (s = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : '<span class="'.concat(e.currentClass, '"></span>') + " / " + '<span class="'.concat(e.totalClass, '"></span>')), "progressbar" === e.type && (s = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : '<span class="'.concat(e.progressbarFillClass, '"></span>')), t.pagination.bullets = [], i.forEach((n => { "custom" !== e.type && (n.innerHTML = s || ""), "bullets" === e.type && t.pagination.bullets.push(...n.querySelectorAll(Rf(e.bulletClass))) })), "custom" !== e.type && r("paginationRender", i[0]) } function f() { t.params.pagination = Df(t, t.originalParams.pagination, t.params.pagination, { el: "swiper-pagination" }); const e = t.params.pagination; if (!e.el) return; let n; "string" === typeof e.el && t.isElement && (n = t.el.shadowRoot.querySelector(e.el)), n || "string" !== typeof e.el || (n = [...document.querySelectorAll(e.el)]), n || (n = e.el), n && 0 !== n.length && (t.params.uniqueNavElements && "string" === typeof e.el && Array.isArray(n) && n.length > 1 && (n = [...t.el.querySelectorAll(e.el)], n.length > 1 && (n = n.filter((e => Qp(e, ".swiper")[0] === t.el))[0])), Array.isArray(n) && 1 === n.length && (n = n[0]), Object.assign(t.pagination, { el: n }), n = l(n), n.forEach((n => { "bullets" === e.type && e.clickable && n.classList.add(e.clickableClass), n.classList.add(e.modifierClass + e.type), n.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (n.classList.add("".concat(e.modifierClass).concat(e.type, "-dynamic")), o = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && n.classList.add(e.progressbarOppositeClass), e.clickable && n.addEventListener("click", d), t.enabled || n.classList.add(e.lockClass) }))) } function m() { const e = t.params.pagination; if (c()) return; let n = t.pagination.el; n && (n = l(n), n.forEach((n => { n.classList.remove(e.hiddenClass), n.classList.remove(e.modifierClass + e.type), n.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && n.removeEventListener("click", d) }))), t.pagination.bullets && t.pagination.bullets.forEach((t => t.classList.remove(...e.bulletActiveClass.split(" ")))) } i("changeDirection", (() => { if (!t.pagination || !t.pagination.el) return; const e = t.params.pagination; let { el: n } = t.pagination; n = l(n), n.forEach((n => { n.classList.remove(e.horizontalClass, e.verticalClass), n.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass) })) })), i("init", (() => { !1 === t.params.pagination.enabled ? g() : (f(), p(), h()) })), i("activeIndexChange", (() => { "undefined" === typeof t.snapIndex && h() })), i("snapIndexChange", (() => { h() })), i("snapGridLengthChange", (() => { p(), h() })), i("destroy", (() => { m() })), i("enable disable", (() => { let { el: e } = t.pagination; e && (e = l(e), e.forEach((e => e.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass)))) })), i("lock unlock", (() => { h() })), i("click", ((e, n) => { const i = n.target; let { el: s } = t.pagination; if (Array.isArray(s) || (s = [s].filter((e => !!e))), t.params.pagination.el && t.params.pagination.hideOnClick && s && s.length > 0 && !i.classList.contains(t.params.pagination.bulletClass)) { if (t.navigation && (t.navigation.nextEl && i === t.navigation.nextEl || t.navigation.prevEl && i === t.navigation.prevEl)) return; const e = s[0].classList.contains(t.params.pagination.hiddenClass); r(!0 === e ? "paginationShow" : "paginationHide"), s.forEach((e => e.classList.toggle(t.params.pagination.hiddenClass))) } })); const g = () => { t.el.classList.add(t.params.pagination.paginationDisabledClass); let { el: e } = t.pagination; e && (e = l(e), e.forEach((e => e.classList.add(t.params.pagination.paginationDisabledClass)))), m() }; Object.assign(t.pagination, { enable: () => { t.el.classList.remove(t.params.pagination.paginationDisabledClass); let { el: e } = t.pagination; e && (e = l(e), e.forEach((e => e.classList.remove(t.params.pagination.paginationDisabledClass)))), f(), p(), h() }, disable: g, render: p, update: h, init: f, destroy: m }) } function Bf(e) { return "object" === typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function Ff(e, t) { const n = ["__proto__", "constructor", "prototype"]; Object.keys(t).filter((e => n.indexOf(e) < 0)).forEach((n => { "undefined" === typeof e[n] ? e[n] = t[n] : Bf(t[n]) && Bf(e[n]) && Object.keys(t[n]).length > 0 ? t[n].__swiper__ ? e[n] = t[n] : Ff(e[n], t[n]) : e[n] = t[n] })) } function zf() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return e.navigation && "undefined" === typeof e.navigation.nextEl && "undefined" === typeof e.navigation.prevEl } function Hf() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return e.pagination && "undefined" === typeof e.pagination.el } function Vf() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return e.scrollbar && "undefined" === typeof e.scrollbar.el } function Wf() { const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "").split(" ").map((e => e.trim())).filter((e => !!e)), t = []; return e.forEach((e => { t.indexOf(e) < 0 && t.push(e) })), t.join(" ") } function qf() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""; return e ? e.includes("swiper-wrapper") ? e : "swiper-wrapper ".concat(e) : "swiper-wrapper" } const Gf = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopedSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideNextClass", "slidePrevClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"]; function Xf(e) { return e.type && e.type.displayName && e.type.displayName.includes("SwiperSlide") } function Kf(e) { const n = []; return t.Children.toArray(e).forEach((e => { Xf(e) ? n.push(e) : e.props && e.props.children && Kf(e.props.children).forEach((e => n.push(e))) })), n } function $f(e) { const n = [], i = { "container-start": [], "container-end": [], "wrapper-start": [], "wrapper-end": [] }; return t.Children.toArray(e).forEach((e => { if (Xf(e)) n.push(e); else if (e.props && e.props.slot && i[e.props.slot]) i[e.props.slot].push(e); else if (e.props && e.props.children) { const t = Kf(e.props.children); t.length > 0 ? t.forEach((e => n.push(e))) : i["container-end"].push(e) } else i["container-end"].push(e) })), { slides: n, slots: i } } function Yf(e, n) { return "undefined" === typeof window ? (0, t.useEffect)(e, n) : (0, t.useLayoutEffect)(e, n) } const Qf = (0, t.createContext)(null), Jf = (0, t.createContext)(null); function Zf() { return Zf = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, Zf.apply(this, arguments) } const em = (0, t.forwardRef)((function (e, n) { let { className: i, tag: r = "div", wrapperTag: s = "div", children: a, onSwiper: o, ...l } = void 0 === e ? {} : e, c = !1; const [u, d] = (0, t.useState)("swiper"), [h, p] = (0, t.useState)(null), [f, m] = (0, t.useState)(!1), g = (0, t.useRef)(!1), y = (0, t.useRef)(null), v = (0, t.useRef)(null), b = (0, t.useRef)(null), _ = (0, t.useRef)(null), T = (0, t.useRef)(null), S = (0, t.useRef)(null), w = (0, t.useRef)(null), x = (0, t.useRef)(null), { params: k, passedParams: E, rest: C, events: P } = function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const n = { on: {} }, i = {}, r = {}; Ff(n, Nf.defaults), Ff(n, Nf.extendedDefaults), n._emitClasses = !0, n.init = !1; const s = {}, a = Gf.map((e => e.replace(/_/, ""))), o = Object.assign({}, e); return Object.keys(o).forEach((o => { "undefined" !== typeof e[o] && (a.indexOf(o) >= 0 ? Bf(e[o]) ? (n[o] = {}, r[o] = {}, Ff(n[o], e[o]), Ff(r[o], e[o])) : (n[o] = e[o], r[o] = e[o]) : 0 === o.search(/on[A-Z]/) && "function" === typeof e[o] ? t ? i["".concat(o[2].toLowerCase()).concat(o.substr(3))] = e[o] : n.on["".concat(o[2].toLowerCase()).concat(o.substr(3))] = e[o] : s[o] = e[o]) })), ["navigation", "pagination", "scrollbar"].forEach((e => { !0 === n[e] && (n[e] = {}), !1 === n[e] && delete n[e] })), { params: n, passedParams: r, rest: s, events: i } }(l), { slides: I, slots: L } = $f(a), O = () => { m(!f) }; Object.assign(k.on, { _containerClasses(e, t) { d(t) } }); const A = () => { Object.assign(k.on, P), c = !0; const e = { ...k }; if (delete e.wrapperClass, v.current = new Nf(e), v.current.virtual && v.current.params.virtual.enabled) { v.current.virtual.slides = I; const e = { cache: !1, slides: I, renderExternal: p, renderExternalUpdate: !1 }; Ff(v.current.params.virtual, e), Ff(v.current.originalParams.virtual, e) } }; y.current || A(), v.current && v.current.on("_beforeBreakpoint", O); return (0, t.useEffect)((() => () => { v.current && v.current.off("_beforeBreakpoint", O) })), (0, t.useEffect)((() => { !g.current && v.current && (v.current.emitSlidesClasses(), g.current = !0) })), Yf((() => { if (n && (n.current = y.current), y.current) return v.current.destroyed && A(), function (e, t) { let { el: n, nextEl: i, prevEl: r, paginationEl: s, scrollbarEl: a, swiper: o } = e; zf(t) && i && r && (o.params.navigation.nextEl = i, o.originalParams.navigation.nextEl = i, o.params.navigation.prevEl = r, o.originalParams.navigation.prevEl = r), Hf(t) && s && (o.params.pagination.el = s, o.originalParams.pagination.el = s), Vf(t) && a && (o.params.scrollbar.el = a, o.originalParams.scrollbar.el = a), o.init(n) }({ el: y.current, nextEl: T.current, prevEl: S.current, paginationEl: w.current, scrollbarEl: x.current, swiper: v.current }, k), o && o(v.current), () => { v.current && !v.current.destroyed && v.current.destroy(!0, !1) } }), []), Yf((() => { !c && P && v.current && Object.keys(P).forEach((e => { v.current.on(e, P[e]) })); const e = function (e, t, n, i, r) { const s = []; if (!t) return s; const a = e => { s.indexOf(e) < 0 && s.push(e) }; if (n && i) { const e = i.map(r), t = n.map(r); e.join("") !== t.join("") && a("children"), i.length !== n.length && a("children") } return Gf.filter((e => "_" === e[0])).map((e => e.replace(/_/, ""))).forEach((n => { if (n in e && n in t) if (Bf(e[n]) && Bf(t[n])) { const i = Object.keys(e[n]), r = Object.keys(t[n]); i.length !== r.length ? a(n) : (i.forEach((i => { e[n][i] !== t[n][i] && a(n) })), r.forEach((i => { e[n][i] !== t[n][i] && a(n) }))) } else e[n] !== t[n] && a(n) })), s }(E, b.current, I, _.current, (e => e.key)); return b.current = E, _.current = I, e.length && v.current && !v.current.destroyed && function (e) { let { swiper: t, slides: n, passedParams: i, changedParams: r, nextEl: s, prevEl: a, scrollbarEl: o, paginationEl: l } = e; const c = r.filter((e => "children" !== e && "direction" !== e && "wrapperClass" !== e)), { params: u, pagination: d, navigation: h, scrollbar: p, virtual: f, thumbs: m } = t; let g, y, v, b, _, T, S, w; r.includes("thumbs") && i.thumbs && i.thumbs.swiper && u.thumbs && !u.thumbs.swiper && (g = !0), r.includes("controller") && i.controller && i.controller.control && u.controller && !u.controller.control && (y = !0), r.includes("pagination") && i.pagination && (i.pagination.el || l) && (u.pagination || !1 === u.pagination) && d && !d.el && (v = !0), r.includes("scrollbar") && i.scrollbar && (i.scrollbar.el || o) && (u.scrollbar || !1 === u.scrollbar) && p && !p.el && (b = !0), r.includes("navigation") && i.navigation && (i.navigation.prevEl || a) && (i.navigation.nextEl || s) && (u.navigation || !1 === u.navigation) && h && !h.prevEl && !h.nextEl && (_ = !0); const x = e => { t[e] && (t[e].destroy(), "navigation" === e ? (t.isElement && (t[e].prevEl.remove(), t[e].nextEl.remove()), u[e].prevEl = void 0, u[e].nextEl = void 0, t[e].prevEl = void 0, t[e].nextEl = void 0) : (t.isElement && t[e].el.remove(), u[e].el = void 0, t[e].el = void 0)) }; r.includes("loop") && t.isElement && (u.loop && !i.loop ? T = !0 : !u.loop && i.loop ? S = !0 : w = !0), c.forEach((e => { if (Bf(u[e]) && Bf(i[e])) Ff(u[e], i[e]), "navigation" !== e && "pagination" !== e && "scrollbar" !== e || !("enabled" in i[e]) || i[e].enabled || x(e); else { const t = i[e]; !0 !== t && !1 !== t || "navigation" !== e && "pagination" !== e && "scrollbar" !== e ? u[e] = i[e] : !1 === t && x(e) } })), c.includes("controller") && !y && t.controller && t.controller.control && u.controller && u.controller.control && (t.controller.control = u.controller.control), r.includes("children") && n && f && u.virtual.enabled && (f.slides = n, f.update(!0)), r.includes("children") && n && u.loop && (w = !0), g && m.init() && m.update(!0); y && (t.controller.control = u.controller.control), v && (!t.isElement || l && "string" !== typeof l || (l = document.createElement("div"), l.classList.add("swiper-pagination"), t.el.shadowEl.appendChild(l)), l && (u.pagination.el = l), d.init(), d.render(), d.update()), b && (!t.isElement || o && "string" !== typeof o || (o = document.createElement("div"), o.classList.add("swiper-scrollbar"), t.el.shadowEl.appendChild(o)), o && (u.scrollbar.el = o), p.init(), p.updateSize(), p.setTranslate()), _ && (t.isElement && (s && "string" !== typeof s || (s = document.createElement("div"), s.classList.add("swiper-button-next"), t.el.shadowEl.appendChild(s)), a && "string" !== typeof a || (a = document.createElement("div"), a.classList.add("swiper-button-prev"), t.el.shadowEl.appendChild(a))), s && (u.navigation.nextEl = s), a && (u.navigation.prevEl = a), h.init(), h.update()), r.includes("allowSlideNext") && (t.allowSlideNext = i.allowSlideNext), r.includes("allowSlidePrev") && (t.allowSlidePrev = i.allowSlidePrev), r.includes("direction") && t.changeDirection(i.direction, !1), (T || w) && t.loopDestroy(), (S || w) && t.loopCreate(), t.update() }({ swiper: v.current, slides: I, passedParams: E, changedParams: e, nextEl: T.current, prevEl: S.current, scrollbarEl: x.current, paginationEl: w.current }), () => { P && v.current && Object.keys(P).forEach((e => { v.current.off(e, P[e]) })) } })), Yf((() => { var e; !(e = v.current) || e.destroyed || !e.params.virtual || e.params.virtual && !e.params.virtual.enabled || (e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.parallax && e.params.parallax && e.params.parallax.enabled && e.parallax.setTranslate()) }), [h]), t.createElement(r, Zf({ ref: y, className: Wf("".concat(u).concat(i ? " ".concat(i) : "")) }, C), t.createElement(Jf.Provider, { value: v.current }, L["container-start"], t.createElement(s, { className: qf(k.wrapperClass) }, L["wrapper-start"], k.virtual ? function (e, n, i) { if (!i) return null; const r = e => { let t = e; return e < 0 ? t = n.length + e : t >= n.length && (t -= n.length), t }, s = e.isHorizontal() ? { [e.rtlTranslate ? "right" : "left"]: "".concat(i.offset, "px") } : { top: "".concat(i.offset, "px") }, { from: a, to: o } = i, l = e.params.loop ? -n.length : 0, c = e.params.loop ? 2 * n.length : n.length, u = []; for (let t = l; t < c; t += 1)t >= a && t <= o && u.push(n[r(t)]); return u.map(((n, i) => t.cloneElement(n, { swiper: e, style: s, key: "slide-".concat(i) }))) }(v.current, I, h) : I.map(((e, n) => t.cloneElement(e, { swiper: v.current, swiperSlideIndex: n }))), L["wrapper-end"]), zf(k) && t.createElement(t.Fragment, null, t.createElement("div", { ref: S, className: "swiper-button-prev" }), t.createElement("div", { ref: T, className: "swiper-button-next" })), Vf(k) && t.createElement("div", { ref: x, className: "swiper-scrollbar" }), Hf(k) && t.createElement("div", { ref: w, className: "swiper-pagination" }), L["container-end"])) })); function tm() { return tm = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, tm.apply(this, arguments) } em.displayName = "Swiper"; const nm = (0, t.forwardRef)((function (e, n) { let { tag: i = "div", children: r, className: s = "", swiper: a, zoom: o, lazy: l, virtualIndex: c, swiperSlideIndex: u, ...d } = void 0 === e ? {} : e; const h = (0, t.useRef)(null), [p, f] = (0, t.useState)("swiper-slide"), [m, g] = (0, t.useState)(!1); function y(e, t, n) { t === h.current && f(n) } Yf((() => { if ("undefined" !== typeof u && (h.current.swiperSlideIndex = u), n && (n.current = h.current), h.current && a) { if (!a.destroyed) return a.on("_slideClass", y), () => { a && a.off("_slideClass", y) }; "swiper-slide" !== p && f("swiper-slide") } })), Yf((() => { a && h.current && !a.destroyed && f(a.getSlideClasses(h.current)) }), [a]); const v = { isActive: p.indexOf("swiper-slide-active") >= 0, isVisible: p.indexOf("swiper-slide-visible") >= 0, isPrev: p.indexOf("swiper-slide-prev") >= 0, isNext: p.indexOf("swiper-slide-next") >= 0 }, b = () => "function" === typeof r ? r(v) : r; return t.createElement(i, tm({ ref: h, className: Wf("".concat(p).concat(s ? " ".concat(s) : "")), "data-swiper-slide-index": c, onLoad: () => { g(!0) } }, d), o && t.createElement(Qf.Provider, { value: v }, t.createElement("div", { className: "swiper-zoom-container", "data-swiper-zoom": "number" === typeof o ? o : void 0 }, b(), l && !m && t.createElement("div", { className: "swiper-lazy-preloader" }))), !o && t.createElement(Qf.Provider, { value: v }, b(), l && !m && t.createElement("div", { className: "swiper-lazy-preloader" }))) })); function im() { const { id: e } = Q(), { data: t } = je("".concat("", "/book_data/").concat(e)); return Nf.use([Mf, jf, Uf]), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(kn, {}), t && (0, Ct.jsx)("div", { className: "book", children: (0, Ct.jsx)(em, { spaceBetween: 25, slidesPerView: 1, navigation: !0, pagination: { type: "fraction" }, keyboard: !0, className: "book-container", children: Array.from({ length: t.nb_pages }, ((t, n) => (0, Ct.jsx)(nm, { children: (0, Ct.jsx)("img", { src: "".concat("", "/book_url/").concat(e, "/").concat(n), alt: "Page ".concat(n), className: "book-img" }) }, n))) }) })] }) } function rm() { const { lib: e, id: n } = Q(), i = Y(), [r, s] = (0, t.useState)(null), a = (0, t.useRef)(null), { data: o } = je("".concat("", "/get_tv/").concat(e, "/").concat(n)); console.log(o), (0, t.useEffect)((() => { o && s(o) }), [o]); const l = { autoplay: !0, controls: !0, preload: "none", techOrder: ["chromecast", "html5", "hls"], sources: [{ src: r && r.channel_url ? r.channel_url : "", type: "application/x-mpegURL" }], html5: { nativeTextTracks: !1 } }; console.log(l); return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(Ot, {}), (0, Ct.jsx)(kn, { path: "/tv/".concat(e) }), (0, Ct.jsx)("h1", { className: "videoTitle", children: null === r || void 0 === r ? void 0 : r.channel_name }), (0, Ct.jsx)(Lp, { options: l, onReady: (e, t) => { a.current = e, e.on("waiting", (() => { au.log("player is waiting") })), e.on("dispose", (() => { au.log("player will dispose") })), e.on("timeupdate", (() => { })) } }), (0, Ct.jsxs)("div", { className: "episodeButtons", children: [null !== (null === r || void 0 === r ? void 0 : r.previous_id) && (0, Ct.jsx)(qt, { text: "previous", onClick: () => i("/channel/".concat(e, "/").concat(r.previous_id)) }), null !== (null === r || void 0 === r ? void 0 : r.next_id) && (0, Ct.jsx)(qt, { text: "next", onClick: () => i("/channel/".concat(e, "/").concat(r.next_id)) })] })] }) } nm.displayName = "SwiperSlide"; const sm = (e, t, n) => { if (window.EJS_emulator || window.EmulatorJS) return; window.EJS_player = "#game", window.EJS_core = e, window.EJS_gameUrl = t, n && (window.EJS_biosUrl = "path_to_bios"); const i = document.createElement("script"); i.src = "https://www.emulatorjs.com/loader.js", document.body.appendChild(i) }; function am() { const { console: e, id: n } = Q(), [i, r] = (0, t.useState)(null), [s, a] = (0, t.useState)(null), [o, l] = (0, t.useState)(null); return (0, t.useEffect)((() => { const t = { GB: null, GBA: null, GBC: null, N64: null, NES: null, NDS: "".concat("", "/bios/NDS"), SNES: null, "Sega Mega Drive": null, "Sega Master System": null, "Sega Saturn": null, PS1: "".concat("", "/bios/PS1") }; r({ GB: "gambatte", GBA: "mgba", GBC: "mgba", N64: "mupen64plus_next", NES: "nes", NDS: "melonds", SNES: "snes9x", "Sega Mega Drive": "genesis_plus_gx", "Sega Master System": "genesis_plus_gx", "Sega Saturn": "yabause", PS1: "pcsx_rearmed" }[e]), a("".concat("", "/game_file/").concat(n)), l(t[e] ? t[e] : null) }), [e, n]), (0, Ct.jsxs)(Ct.Fragment, { children: [i && s && sm(i, s, o), (0, Ct.jsx)("div", { className: "game", id: "game" })] }) } const om = () => { var e, n, i, r, s, a, o; let { visible: l, sources: c, isPlaying: u, setIsPlaying: d, sourceIndex: h, setSourceIndex: p, setSources: f, setVisible: m } = Cm(); const g = (0, t.useRef)(null), [y, v] = (0, t.useState)(0), [b, _] = (0, t.useState)(1), [T, S] = (0, t.useState)(!1), [w, x] = (0, t.useState)(null), [k, E] = (0, t.useState)(!1), [C, P] = (0, t.useState)((0, Ct.jsx)(kt, { className: "audio-player-volume-icon" })), [I, L] = (0, t.useState)((0, Ct.jsx)(ft, { className: "audio-player-repeat-icon no-repeat" })), { handleSubmit: O } = De(); (0, t.useEffect)((() => { c.length > 0 && !w && x(c) }), [c, w]), (0, t.useEffect)((() => { const e = { "no-repeat": (0, Ct.jsx)(ft, { className: "audio-player-repeat-icon no-repeat" }), repeat: (0, Ct.jsx)(ft, { className: "audio-player-repeat-icon repeat-active" }), "repeat-one": (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(ft, { className: "audio-player-repeat-icon repeat-one" }), (0, Ct.jsx)("span", { children: "1" })] }) }; L(e[["no-repeat", "repeat", "repeat-one"][b]]) }), [b]), (0, t.useEffect)((() => { var e; if (null === (e = c[h]) || void 0 === e || !e.id) return; let t = "".concat("", "/play_track/").concat(c[h].id, "/").concat(localStorage.getItem("id")); O({ url: t }) }), [c, h]); const A = (0, t.useCallback)((() => { d(!0) }), [d]), N = (0, t.useCallback)((() => { d(!1) }), [d]), j = (0, t.useCallback)((() => { h < c.length - 1 ? (p(h + 1), d(!0)) : d(!1) }), [h, c, d, p]), D = (0, t.useCallback)((() => { h > 0 ? (p(h - 1), d(!0)) : d(!1) }), [h, d, p]), M = () => { E(!0) }, R = () => { E(!1) }; function U(e) { let t = Math.floor(e / 60), n = Math.round(e - 60 * t); return n < 10 && (n = "0" + n), "".concat(t, ":").concat(n) } return (0, t.useEffect)((() => { var e, t, n, i, r; const s = { play: A, pause: N, nexttrack: h < c.length - 1 ? j : null, previoustrack: h > 0 ? D : null }; if (g.current) { g.current.src = "".concat("", "/get_track/").concat(null === (e = c[h]) || void 0 === e ? void 0 : e.id), g.current.load(), g.current.play(), navigator.mediaSession.metadata = new MediaMetadata({ title: null === (t = c[h]) || void 0 === t ? void 0 : t.name, artist: null === (n = c[h]) || void 0 === n ? void 0 : n.artist_name, album: null === (i = c[h]) || void 0 === i ? void 0 : i.album_name, artwork: [{ src: "".concat("", "/").concat(null === (r = c[h]) || void 0 === r ? void 0 : r.cover), sizes: "512x512", type: "image/png" }] }); for (const [e, t] of Object.entries(s)) try { navigator.mediaSession.setActionHandler(e, t) } catch (a) { console.log('The media session action "'.concat(e, '" is not supported yet.')) } } }), [c, h, A, N, j, D]), (0, t.useEffect)((() => { g.current && (u ? g.current.play() : u || g.current.pause()) }), [u]), (0, t.useEffect)((() => { const e = g.current; if (e) return e.removeEventListener("pause", N), e.removeEventListener("play", A), e.addEventListener("pause", N), e.addEventListener("play", A), () => { e.removeEventListener("pause", N), e.removeEventListener("play", A) } }), [g, d, N, A]), (0, Ct.jsx)(Ct.Fragment, { children: l && (0, Ct.jsxs)("div", { className: "audio-player", children: [(0, Ct.jsxs)("div", { className: "audio-player-buttons", children: [h > 0 ? (0, Ct.jsx)("button", { onClick: D, className: "audio-player-button", children: (0, Ct.jsx)(dt, {}) }) : (0, Ct.jsx)("div", { className: "audio-player-button" }), !u && (0, Ct.jsx)("button", { onClick: A, className: "audio-player-button", children: (0, Ct.jsx)(ut, {}) }), u && (0, Ct.jsx)("button", { onClick: N, className: "audio-player-button", children: (0, Ct.jsx)(ot, {}) }), h < c.length - 1 ? (0, Ct.jsx)("button", { onClick: j, className: "audio-player-button", children: (0, Ct.jsx)(ht, {}) }) : (0, Ct.jsx)("div", { className: "audio-player-button" })] }), (0, Ct.jsxs)("div", { className: "audio-player-seek", children: [(0, Ct.jsxs)("h2", { children: [null === (e = c[h]) || void 0 === e ? void 0 : e.name, " \u2022 ", null === (n = c[h]) || void 0 === n ? void 0 : n.artist_name] }), (0, Ct.jsxs)("div", { className: "audio-seekbar", children: [(0, Ct.jsx)("h3", { children: U(y) }), (0, Ct.jsx)("input", { type: "range", className: "audio-player-seekbar audio-slider", min: 0, max: null === (i = g.current) || void 0 === i ? void 0 : i.duration, value: y || 0, onChange: e => { g.current.currentTime = e.target.value } }), (0, Ct.jsx)("h3", { children: U((null === (r = g.current) || void 0 === r ? void 0 : r.duration) || (null === (s = c[h]) || void 0 === s ? void 0 : s.duration)) })] })] }), (0, Ct.jsxs)("div", { className: "audio-player-icon-right", children: [(0, Ct.jsx)("div", { onMouseEnter: M, onMouseLeave: R, className: "audio-player-volume-icon-container", style: { order: 1 }, children: C }), (0, Ct.jsx)("div", { className: "audio-player-volumebar-container icons-container", style: { opacity: k ? 1 : "", order: 5 }, onMouseEnter: M, onMouseLeave: R, children: (0, Ct.jsx)("input", { type: "range", className: "audio-player-volumebar audio-slider", min: 0, max: 1, step: .01, value: null === (a = g.current) || void 0 === a ? void 0 : a.volume, onChange: e => { g.current.volume = e.target.value, 0 === e.target.value ? P((0, Ct.jsx)(Et, { className: "audio-player-volume-icon" })) : e.target.value > 0 && e.target.value <= .33 ? P((0, Ct.jsx)(xt, { className: "audio-player-volume-icon" })) : e.target.value > .33 && e.target.value <= .66 ? P((0, Ct.jsx)(kt, { className: "audio-player-volume-icon" })) : e.target.value > .66 && P((0, Ct.jsx)(wt, { className: "audio-player-volume-icon" })) } }) }), (0, Ct.jsx)("div", { className: "audio-player-repeat-icon-container icons-container", onClick: () => { _((b + 1) % 3) }, style: { order: 2 }, children: I }), (0, Ct.jsx)("div", { className: "audio-player-shuffle-icon-container icons-container".concat(T ? "" : " icon-light"), onClick: () => { var e; T ? (S(!1), f(w)) : (S(!0), f((e = c, [...e].sort((() => Math.random() - .5)))), p(0)) }, style: { order: 3 }, children: (0, Ct.jsx)(gt, { className: "audio-player-shuffle-icon" }) }), (0, Ct.jsxs)("div", { className: "icons-container", style: { order: 4 }, children: [(0, Ct.jsx)(Je, { className: "audio-player-close-icon", onClick: () => { m(!1) } }), "  "] })] }), (0, Ct.jsx)("audio", { id: "audio", src: "".concat("", "/get_track/").concat(null === (o = c[h]) || void 0 === o ? void 0 : o.id), ref: g, onTimeUpdate: () => { v(g.current.currentTime), g.current.currentTime === g.current.duration && (console.log("end"), console.log("Repeat: ".concat(b)), console.log("SourceIndex: ".concat(h)), console.log("SourcesLength: ".concat(c.length)), 0 === b && h === c.length - 1 ? d(!1) : 0 === b ? p(h + 1) : 1 === b && h === c.length - 1 ? (g.current.currentTime = 0, g.current.play()) : 1 === b ? p((h + 1) % c.length) : 2 === b && (g.current.currentTime = 0, g.current.play())) } })] }) }) }, lm = n.p + "static/media/logo.77e0b508eb00e348ec32.png"; function cm() { const { data: e } = je("".concat("", "/get_all_libraries")); return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)("div", { className: "right_effect" }), (0, Ct.jsxs)("header", { children: [(0, Ct.jsx)("div", { id: "goHome", className: "logo_svg", children: (0, Ct.jsx)(Se, { to: "/", children: (0, Ct.jsx)("img", { className: "logo", id: "logo", src: lm, alt: "ChocolateLogo" }) }) }), (0, Ct.jsxs)("div", { className: "header_icons", children: [(0, Ct.jsx)(Se, { to: "/", className: "header_icon", children: (0, Ct.jsx)(st, { className: "icon" }) }), Array.isArray(e) ? e.map((e => (0, Ct.jsx)(Se, { to: "/".concat(e.lib_type, "/").concat(e.lib_name), className: "header_icon", title: e.lib_name, children: Pt[e.lib_type] }, "".concat(e.lib_type, "_").concat(e.lib_name)))) : null] }), (0, Ct.jsxs)("div", { className: "header_bottom_icons", children: [(0, Ct.jsx)(Se, { to: "/add_media", className: "header_icon", children: (0, Ct.jsx)(We, { className: "add_icon" }) }), (0, Ct.jsx)(Se, { to: "/logout", className: "header_icon", children: (0, Ct.jsx)(at, { className: "logout_icon" }) }), (0, Ct.jsx)(Se, { to: "/profil", className: "header_icon", children: (0, Ct.jsx)(ct, { className: "person_icon" }) })] })] })] }) } function um() { const { id: e } = Q(), [n, i] = (0, t.useState)("".concat("", "/get_actor_data/").concat(e)), [r, s] = (0, t.useState)(!1), [a, o] = (0, t.useState)(null), [l, c] = (0, t.useState)(!1), [u, d] = (0, t.useState)(null); (0, t.useEffect)((() => { i("".concat("", "/get_actor_data/").concat(e)) }), [e]); const { data: h } = je(n); return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(kn, {}), h && (0, Ct.jsx)("div", { className: "actor", children: (0, Ct.jsxs)("div", { className: "actor_header", children: [(0, Ct.jsx)("img", { className: "actor_image", src: "".concat("", "/actor_image/").concat(e), alt: e, onError: e => { let { currentTarget: t } = e; t.onerror = null, t.src = "".concat("", "/static/img/broken.webp") } }), (0, Ct.jsxs)("div", { className: "actor_infos", children: [(0, Ct.jsx)("h1", { children: h.actor_name }), (0, Ct.jsx)("p", { children: h.actor_description })] })] }) }), h && h.actor_movies && h.actor_movies.length > 0 && (0, Ct.jsxs)("div", { className: "actor_movies", children: [(0, Ct.jsx)("h2", { children: "Movies" }), (0, Ct.jsx)("div", { className: "movies movies_actor", children: h.actor_movies.map(((e, t) => (0, Ct.jsx)("div", { className: "movie", children: (0, Ct.jsx)(Wt, { name: e.real_title, id: e.id, library: e.library, note: e.note, vues: e.vues, duration: e.duration, onClick: () => function (e) { c(!0), s(!1), d(e) }(e.id) }) }, t))) })] }), h && h.actor_series && h.actor_series.length > 0 && (0, Ct.jsxs)("div", { className: "actor_series", children: [(0, Ct.jsx)("h2", { children: "Series" }), (0, Ct.jsx)("div", { className: "series series_actor", children: h.actor_series.map(((e, t) => (0, Ct.jsx)("div", { className: "movie", children: (0, Ct.jsx)(rn, { name: e.real_title, id: e.id, library: e.library, note: e.note, vues: e.vues, duration: e.duration, onClick: () => function (e) { s(!0), c(!1), o(e) }(e.id) }) }, t))) })] }), r && (0, Ct.jsx)(Jt, { onClose: () => s(!1), id: a }), l && (0, Ct.jsx)(Qt, { onClose: () => c(!1), id: u })] }) } function dm() { return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(kn, {}), (0, Ct.jsx)("div", { className: "add_media" })] }) } function hm(e) { let { username: n, onClose: i, onDone: r } = e; const s = (0, t.useRef)(null), { handleSubmit: a, resMsg: o } = De(), { getLang: l } = Yt(); if (o) { const e = o.token; localStorage.setItem("token", e), r() } return (0, Ct.jsxs)("div", { className: "loginPopup", children: [(0, Ct.jsx)(Je, { className: "crossPopup", id: "crossPopup", onClick: i }), (0, Ct.jsx)("input", { type: "password", placeholder: l("password"), ref: s, className: "input", autoFocus: !0 }), (0, Ct.jsx)("button", { className: "button", onClick: function () { "" !== s.current.value ? a({ url: "".concat("", "/login"), body: { name: n, password: s.current.value } }) : i() }, children: l("login") })] }) } function pm(e) { let { elements: n = [], className: i = "", setValue: r, defaultValue: s = "", defaultText: a = "", title: o = "", dropdownText: l = null } = e; const [c, u] = (0, t.useState)(!1), [d, h] = (0, t.useState)(s), { getLang: p } = Yt(); (0, t.useEffect)((() => { r(s) }), [s, r]); const f = e => null === e || void 0 === e ? void 0 : e.toLowerCase().replace(/(?:^|\s|["'([{])+\S/g, (e => e.toUpperCase())); return (0, Ct.jsxs)("div", { className: "dropdown ".concat(i), children: [(0, Ct.jsxs)("button", { className: "dropdown-button input", onClick: () => u(!c), children: [(0, Ct.jsx)("div", { className: "unused" }), d ? (m = d, m = f(m), o && (m = "".concat(o, ": ").concat(m)), m) : l || p("select"), c ? (0, Ct.jsx)(Ke, {}) : (0, Ct.jsx)(Xe, {})] }), (0, Ct.jsx)("div", { className: "dropdown-content", style: { display: c ? "flex" : "none" }, children: Array.isArray(n) && n.map((e => (0, Ct.jsxs)("button", { onClick: () => { r(e.value), h(e.text), u(!1) }, children: [d === e.text ? (0, Ct.jsx)($e, {}) : (0, Ct.jsx)("div", { className: "unused" }), f(e.text)] }, e.value))) })] }); var m } function fm(e) { let { elements: n = [], className: i = "", setValue: r, defaultValue: s = [], dropdownText: a = null } = e; const [o, l] = (0, t.useState)(!1), [c, u] = (0, t.useState)(s), { getLang: d } = Yt(); return (0, Ct.jsxs)("div", { className: "dropdown ".concat(i), children: [(0, Ct.jsxs)("button", { className: "dropdown-button input", onClick: () => l(!o), children: [(0, Ct.jsx)("div", { className: "unused" }), a || d("select"), o ? (0, Ct.jsx)(Ke, {}) : (0, Ct.jsx)(Xe, {})] }), (0, Ct.jsx)("div", { className: "dropdown-content", style: { display: o ? "flex" : "none" }, children: Array.isArray(n) && n.map((e => (0, Ct.jsxs)("button", { onClick: () => { c.includes(e.id.toString()) ? (r(c.filter((t => t !== e.id.toString()))), u(c.filter((t => t !== e.id.toString())))) : (r([...c, e.id.toString()]), u([...c, e.id.toString()])) }, children: [c.includes(e.id.toString()) ? (0, Ct.jsx)($e, {}) : (0, Ct.jsx)("div", { className: "unused" }), e.name] }, e.id))) })] }) } function mm(e) { let { default_type: n = null } = e; const [i, r] = (0, t.useState)(""), [s, a] = (0, t.useState)(""), [o, l] = (0, t.useState)(""), [c, u] = (0, t.useState)(""), [d, h] = (0, t.useState)(!1), { handleSubmit: p } = De(), { getLang: f } = Yt(), m = Y(); return (0, Ct.jsxs)("div", { className: "create-account-card", children: [(0, Ct.jsx)("h1", { children: f("create_account") }), (0, Ct.jsxs)("div", { className: "formUsername", children: [(0, Ct.jsxs)("label", { htmlFor: "username", children: [f("username"), ": "] }), (0, Ct.jsx)("input", { type: "text", name: "username", placeholder: f("username"), className: "input", value: i, onChange: e => r(e.target.value) })] }), "kid" !== o ? (0, Ct.jsxs)("div", { className: "formPassword", children: [(0, Ct.jsxs)("label", { htmlFor: "password", children: [f("password"), ": "] }), (0, Ct.jsx)("input", { type: "password", name: "password", placeholder: f("password"), className: "input", value: s, onChange: e => a(e.target.value) })] }) : null, n ? null : (0, Ct.jsxs)("div", { className: "formType", children: [(0, Ct.jsxs)("label", { htmlFor: "type", children: [f("account_type"), ": "] }), (0, Ct.jsx)(pm, { name: "type", elements: [{ value: "admin", text: "Admin" }, { value: "adult", text: "Adult" }, { value: "teen", text: "Teen" }, { value: "kid", text: "Kid" }], setValue: l })] }), (0, Ct.jsxs)("div", { className: "formProfilePicture", children: [(0, Ct.jsxs)("label", { htmlFor: "profilePicture", children: [f("profile_pic"), ": "] }), (0, Ct.jsx)("input", { type: "file", name: "profilePicture", accept: "image/*", onChange: e => u(e.target.files[0]) })] }), (0, Ct.jsx)("input", { type: "submit", value: f("create_account"), className: "button", disabled: d, onClick: async e => { e.preventDefault(), h(!0), n && l(n); try { const e = await (t = c, t instanceof Blob ? new Promise(((e, n) => { const i = new FileReader; i.readAsDataURL(t), i.onload = () => e(i.result), i.onerror = e => n(e) })) : null); if ("" === i) return void Kt({ message: "You must enter a username" }); if ("" === o && null !== n) l(n); else if ("" === o) return void Kt({ message: "You must select a type" }); if ("admin" === o && "" === s) return; const u = { username: i, password: s, type: o, profilePicture: e || null }; await p({ url: "".concat("", "/create_account"), body: u, headers: { "Content-Type": "application/json" } }), r(""), a(""), l(""), $t({ message: "Account created successfully" }), null !== n && m("/") } catch (u) { console.error(u) } finally { h(!1) } var t } })] }) } function gm(e) { let { admin_only: n = !1, shared: i = !0 } = e; const { key: r } = Q(), [s, a] = (0, t.useState)("".concat("", "/invite_exist/").concat(r)), { data: o } = je(s), l = Y(); return (0, t.useEffect)((() => { i && void 0 !== r ? a("".concat("", "/invite_exist/").concat(r)) : r || l("/login") }), [i, r]), (0, t.useEffect)((() => { !1 === o && l("/login") }), [o, l]), console.log(n, o, i, r), (0, Ct.jsx)(Ct.Fragment, { children: (0, Ct.jsx)("div", { className: "create-account", children: (0, Ct.jsx)(mm, { default_type: n ? "admin" : "adult" }) }) }) } function ym() { const [e, n] = (0, t.useState)(!1), [i, r] = (0, t.useState)(null), { data: s } = je("".concat("", "/get_all_users")), { handleSubmit: a, resMsg: o } = De(); if (o) { const e = o.token; localStorage.setItem("token", e), window.location.reload() } return (0, Ct.jsxs)(Ct.Fragment, { children: [e ? (0, Ct.jsx)(hm, { username: i, onDone: () => window.location.reload(), onClose: () => n(!1) }) : null, (0, Ct.jsx)("div", { className: "accounts", children: Array.isArray(s) ? s.length > 0 ? s.map((e => (0, Ct.jsxs)("div", { className: "account", onClick: () => function (e, t, i) { console.log(e, t, i), t || "Kid" === i ? a({ url: "".concat("", "/login"), body: { name: e, password: "" } }) : (n(!0), r(e)) }(e.name, e.password_empty, e.account_type), children: [(0, Ct.jsx)("img", { src: "".concat("", "/user_image/").concat(e.id), alt: "avatar" }), (0, Ct.jsx)("p", { children: e.name })] }))) : (0, Ct.jsx)(Ct.Fragment, { children: (0, Ct.jsx)(gm, { admin_only: !0, shared: !1 }) }) : null })] }) } function vm() { const e = Y(); return (0, t.useEffect)((() => { localStorage.removeItem("token"), localStorage.removeItem("username"), localStorage.removeItem("account_type"), e("/") }), []), null } function bm(e) { let { account: n, refreshAllAccounts: i } = e; const [r, s] = (0, t.useState)(""), [a, o] = (0, t.useState)(""), [l, c] = (0, t.useState)(""), { handleSubmit: u } = De(), { getLang: d } = Yt(); (0, t.useEffect)((() => { s(n.name), c(n.account_type) }), [n]); return (0, Ct.jsxs)("div", { className: "account-setting", children: [(0, Ct.jsx)("h3", { children: n.name }), (0, Ct.jsx)("input", { type: "text", value: r, className: "input", onChange: e => s(e.target.value) }), (0, Ct.jsx)("input", { type: "text", placeholder: d("password"), className: "input", onChange: e => o(e.target.value) }), (0, Ct.jsx)(pm, { name: "type", placeholder: "Type", elements: [{ value: "admin", text: "Admin" }, { value: "adult", text: "Adult" }, { value: "teen", text: "Teen" }, { value: "kid", text: "Kid" }], setValue: c, defaultValue: { Admin: "admin", Adult: "adult", Teen: "teen", Kid: "kid" }[l], defaultText: l }), (0, Ct.jsxs)("div", { className: "buttons", children: [(0, Ct.jsx)(qt, { text: "Save", type: "button-small", onClick: () => (async e => { const t = { id: e, username: r, password: a, type: l }; await u({ url: "".concat("", "/edit_profil"), body: t }), i() })(n.id) }), (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(_t, {}), text: d("delete"), type: "button-delete button-small", onClick: () => (async e => { await u({ url: "".concat("", "/delete_account"), body: { id: e } }), i() })(n.id) })] })] }, n.id) } function _m(e) { let { fetchData: t } = e; const { data: n, fetchData: i } = je("".concat("", "/get_all_users")), { getLang: r } = Yt(); return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)("h1", { children: r("users") }), (0, Ct.jsxs)("div", { className: "all-accounts", children: [n && n.map((e => (0, Ct.jsx)(bm, { account: e, refreshAllAccounts: i }, e.id))), (0, Ct.jsxs)("div", { className: "account-setting invite-account", style: { rowGap: "8vh" }, children: [(0, Ct.jsx)("h3", { children: r("invite") }), (0, Ct.jsx)(qt, { text: "Invite", icon: (0, Ct.jsx)(We, {}), type: "button-small" })] })] })] }) } function Tm(e) { var n; let { library: i, refreshAllLibraries: r, users: s } = e; const [a, o] = (0, t.useState)(""), [l, c] = (0, t.useState)(""), [u, d] = (0, t.useState)(""), [h, p] = (0, t.useState)(""), [f, m] = (0, t.useState)((null === i || void 0 === i || null === (n = i.available_for) || void 0 === n ? void 0 : n.toString().split(",")) || []), { handleSubmit: g } = De(), { getLang: y } = Yt(); (0, t.useEffect)((() => { o(i.lib_name), c(i.lib_folder), d(i.lib_type), p(i.merge_parent), console.log(i) }), [i]); return (0, Ct.jsxs)("div", { className: "library-setting", children: [(0, Ct.jsx)("h3", { children: i.lib_name }), (0, Ct.jsx)("input", { type: "text", value: a, className: "input", onChange: e => o(e.target.value) }), (0, Ct.jsx)("input", { type: "text", value: l, className: "input", onChange: e => c(e.target.value) }), (0, Ct.jsx)(pm, { name: "type", placeholder: "Type", elements: [{ value: "movies", text: "movies" }, { value: "series", text: "series" }, { value: "books", text: "books" }, { value: "others", text: "others" }, { value: "tv", text: "tv" }, { value: "consoles", text: "consoles" }], setValue: d, defaultValue: i.lib_type, title: "Type" }), i.possible_merge_parent && (0, Ct.jsx)(pm, { name: "merge", placeholder: "Merge", elements: [{ value: null, text: "No merge" }, ...i.possible_merge_parent], setValue: p, defaultValue: i.merge_parent, dropdownText: "Select lib to merge with", title: "Merge width" }), s && (0, Ct.jsx)(fm, { name: "users", placeholder: "Users", elements: s, setValue: e => { m(e) }, dropdownText: "Select allowed users", defaultValue: null !== i.available_for ? i.available_for.toString().split(",") : [] }), (0, Ct.jsxs)("div", { className: "buttons", children: [(0, Ct.jsx)(qt, { text: y("save"), type: "button-small", onClick: () => (async e => { console.log(f); let t = f; for (let i = 0; i < t.length; i++)t[i] = parseInt(t[i]); t = f.length > 0 ? f.join(",") : null; const n = { default_path: e, name: a, path: l, type: u, merge_parent: h || null, users: t }; await g({ url: "".concat("", "/edit_library"), body: n, headers: { "Content-Type": "application/json" } }), r() })(i.lib_folder) }), (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(_t, {}), text: y("delete"), type: "button-delete button-small", onClick: () => { return e = i.lib_name, g({ url: "".concat("", "/delete_library"), body: { name: e }, headers: { "Content-Type": "application/json" } }), void r(); var e } })] })] }, i.id) } function Sm() { const [e, n] = (0, t.useState)(!1), { data: i, fetchData: r } = je("".concat("", "/get_all_libraries_created")), { data: s } = je("".concat("", "/get_all_users")), { getLang: a } = Yt(); return (0, t.useEffect)((() => { console.log(i) }), [i]), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)("h1", { children: a("libraries") }), (0, Ct.jsxs)("div", { className: "all-libraries", children: [i && i.map((e => (0, Ct.jsx)(Tm, { library: e, refreshAllLibraries: r, users: s }, e.id))), (0, Ct.jsxs)("div", { className: "library-setting", style: { rowGap: "8vh" }, children: [(0, Ct.jsx)("h3", { children: a("create_new_lib") }), (0, Ct.jsx)(qt, { icon: (0, Ct.jsx)(Ve, {}), text: a("add"), type: "button-add button-small", onClick: () => n(!0) })] })] }), e && (0, Ct.jsx)(Zt, { onClose: () => n(!1), refreshAllLibraries: r, users: s })] }) } function wm() { const [e, n] = (0, t.useState)(void 0), [i, r] = (0, t.useState)(void 0), [s, a] = (0, t.useState)(void 0), [o, l] = (0, t.useState)(void 0), [c, u] = (0, t.useState)(void 0), [d, h] = (0, t.useState)(void 0), [p, f] = (0, t.useState)(void 0), [m, g] = (0, t.useState)(void 0), [y, v] = (0, t.useState)(void 0), [b, _] = (0, t.useState)(void 0), [T, S] = (0, t.useState)(void 0), [w, x] = (0, t.useState)(void 0), [k, E] = (0, t.useState)(void 0), [C, P] = (0, t.useState)(void 0), [I, L] = (0, t.useState)(void 0), [O, A] = (0, t.useState)(void 0), { data: N } = je("".concat("", "/get_language")), { data: j } = je("".concat("", "/get_settings")), { handleSubmit: D } = De(), { getLang: M } = Yt(); (0, t.useEffect)((() => { N && n(N.language) }), [N]), (0, t.useEffect)((() => { if (j) { const e = j.ChocolateSettings, t = j.APIKeys, i = j.ARRSettings; r(t.tmdb), a(t.igdbid), l(t.igdbsecret), f(t.radarr), _(t.sonarr), E(t.readarr), A(t.lidarr), u(i.radarrurl), h(i.radarrfolder), g(i.sonarrurl), v(i.sonarrfolder), S(i.readarrurl), x(i.readarrfolder), P(i.lidarrurl), L(i.lidarrfolder), n(e.language) } }), [j]); return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)("h1", { children: "General Settings" }), (0, Ct.jsxs)("div", { className: "general-settings", children: [(0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: "Language:" }), (0, Ct.jsx)(pm, { elements: [{ value: "AF", text: "Afrikaans" }, { value: "SQ", text: "Albanian" }, { value: "AM", text: "Amharic" }, { value: "AR", text: "Arabic" }, { value: "HY", text: "Armenian" }, { value: "AZ", text: "Azerbaijani" }, { value: "EU", text: "Basque" }, { value: "BE", text: "Belarusian" }, { value: "BN", text: "Bengali" }, { value: "BS", text: "Bosnian" }, { value: "BG", text: "Bulgarian" }, { value: "CA", text: "Catalan" }, { value: "NY", text: "Chichewa" }, { value: "CO", text: "Corsican" }, { value: "HR", text: "Croatian" }, { value: "CS", text: "Czech" }, { value: "DA", text: "Danish" }, { value: "NL", text: "Dutch" }, { value: "EN", text: "English" }, { value: "EO", text: "Esperanto" }, { value: "ET", text: "Estonian" }, { value: "FI", text: "Finnish" }, { value: "FR", text: "French" }, { value: "FY", text: "Frisian" }, { value: "GL", text: "Galician" }, { value: "KA", text: "Georgian" }, { value: "DE", text: "German" }, { value: "EL", text: "Greek" }, { value: "GU", text: "Gujarati" }, { value: "HT", text: "Haitian Creole" }, { value: "HA", text: "Hausa" }, { value: "HE", text: "Hebrew" }, { value: "HI", text: "Hindi" }, { value: "HU", text: "Hungarian" }, { value: "IS", text: "Icelandic" }, { value: "IG", text: "Igbo" }, { value: "ID", text: "Indonesian" }, { value: "GA", text: "Irish" }, { value: "IT", text: "Italian" }, { value: "JA", text: "Japanese" }, { value: "JV", text: "Javanese" }, { value: "KN", text: "Kannada" }, { value: "KK", text: "Kazakh" }, { value: "KM", text: "Khmer" }, { value: "KO", text: "Korean" }, { value: "KU", text: "Kurdish (Kurmanji)" }, { value: "LO", text: "Lao" }, { value: "LA", text: "Latin" }, { value: "LV", text: "Latvian" }, { value: "LT", text: "Lithuanian" }, { value: "LB", text: "Luxembourgish" }, { value: "MK", text: "Macedonian" }, { value: "MG", text: "Malagasy" }, { value: "MS", text: "Malay" }, { value: "ML", text: "Malayalam" }, { value: "MT", text: "Maltese" }, { value: "ZH", text: "Mandarin" }, { value: "MI", text: "Maori" }, { value: "MR", text: "Marathi" }, { value: "MN", text: "Mongolian" }, { value: "NE", text: "Nepali" }, { value: "NO", text: "Norwegian" }, { value: "PS", text: "Pashto" }, { value: "FA", text: "Persian" }, { value: "PL", text: "Polish" }, { value: "PT", text: "Portuguese" }, { value: "PA", text: "Punjabi" }, { value: "RO", text: "Romanian" }, { value: "RU", text: "Russian" }, { value: "SM", text: "Samoan" }, { value: "GD", text: "Scots Gaelic" }, { value: "SR", text: "Serbian" }, { value: "SN", text: "Shona" }, { value: "SD", text: "Sindhi" }, { value: "SK", text: "Slovak" }, { value: "SL", text: "Slovenian" }, { value: "SO", text: "Somali" }, { value: "ES", text: "Spanish" }, { value: "SU", text: "Sundanese" }, { value: "SW", text: "Swahili" }, { value: "SV", text: "Swedish" }, { value: "TG", text: "Tajik" }, { value: "TA", text: "Tamil" }, { value: "TT", text: "Tatar" }, { value: "TE", text: "Telugu" }, { value: "TH", text: "Thai" }, { value: "TR", text: "Turkish" }, { value: "TK", text: "Turkmen" }, { value: "UK", text: "Ukrainian" }, { value: "UR", text: "Urdu" }, { value: "UZ", text: "Uzbek" }, { value: "VI", text: "Vietnamese" }, { value: "CY", text: "Welsh" }, { value: "XH", text: "Xhosa" }, { value: "YI", text: "Yiddish" }, { value: "YO", text: "Yoruba" }, { value: "ZU", text: "Zulu" }], setValue: n, defaultValue: e, defaultText: { AF: "Afrikaans", SQ: "Albanian", AM: "Amharic", AR: "Arabic", HY: "Armenian", AZ: "Azerbaijani", EU: "Basque", BE: "Belarusian", BN: "Bengali", BS: "Bosnian", BG: "Bulgarian", CA: "Catalan", NY: "Chichewa", CO: "Corsican", HR: "Croatian", CS: "Czech", DA: "Danish", NL: "Dutch", EN: "English", EO: "Esperanto", ET: "Estonian", FI: "Finnish", FR: "French", FY: "Frisian", GL: "Galician", KA: "Georgian", DE: "German", EL: "Greek", GU: "Gujarati", HT: "Haitian Creole", HA: "Hausa", HE: "Hebrew", HI: "Hindi", HU: "Hungarian", IS: "Icelandic", IG: "Igbo", ID: "Indonesian", GA: "Irish", IT: "Italian", JA: "Japanese", JV: "Javanese", KN: "Kannada", KK: "Kazakh", KM: "Khmer", KO: "Korean", KU: "Kurdish (Kurmanji)", LO: "Lao", LA: "Latin", LV: "Latvian", LT: "Lithuanian", LB: "Luxembourgish", MK: "Macedonian", MG: "Malagasy", MS: "Malay", ML: "Malayalam", MT: "Maltese", ZH: "Mandarin", MI: "Maori", MR: "Marathi", MN: "Mongolian", NE: "Nepali", NO: "Norwegian", PS: "Pashto", FA: "Persian", PL: "Polish", PT: "Portuguese", PA: "Punjabi", RO: "Romanian", RU: "Russian", SM: "Samoan", GD: "Scots Gaelic", SR: "Serbian", SN: "Shona", SD: "Sindhi", SK: "Slovak", SL: "Slovenian", SO: "Somali", ES: "Spanish", SU: "Sundanese", SW: "Swahili", SV: "Swedish", TG: "Tajik", TA: "Tamil", TT: "Tatar", TE: "Telugu", TH: "Thai", TR: "Turkish", TK: "Turkmen", UK: "Ukrainian", UR: "Urdu", UZ: "Uzbek", VI: "Vietnamese", CY: "Welsh", XH: "Xhosa", YI: "Yiddish", YO: "Yoruba", ZU: "Zulu" }[e], onChange: function (e) { n(e.target.value) } })] }), (0, Ct.jsx)("div", { className: "sub-settings", children: (0, Ct.jsxs)("div", { className: "api-settings", children: [(0, Ct.jsx)("h2", { children: M("api_keys") }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("tmdb_api_key") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("tmdb_api_key"), value: i, onChange: e => r(e.target.value) })] }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("igdb_id_key") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("igdb_id_key"), value: s, onChange: e => a(e.target.value) })] }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("igdb_secret_key") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("igdb_secret_key"), value: o, onChange: e => l(e.target.value) })] })] }) }), (0, Ct.jsxs)("div", { className: "sub-settings", children: [(0, Ct.jsx)("h2", { children: M("arr_settings") }), (0, Ct.jsxs)("div", { className: "arr-settings", children: [(0, Ct.jsx)("h3", { children: "Radarr" }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("radarr_adress") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("radarr_adress"), value: c, onChange: e => u(e.target.value) })] }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("radarr_folder") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("radarr_folder"), value: d, onChange: e => h(e.target.value) })] }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("radarr_api_key") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("radarr_api_key"), value: p, onChange: e => f(e.target.value) })] })] }), (0, Ct.jsxs)("div", { className: "arr-settings", children: [(0, Ct.jsx)("h3", { children: "Sonarr" }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("sonarr_adress") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("sonarr_adress"), value: m, onChange: e => g(e.target.value) })] }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("sonarr_folder") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("sonarr_folder"), value: y, onChange: e => v(e.target.value) })] }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("sonarr_api_key") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("sonarr_api_key"), value: b, onChange: e => _(e.target.value) })] })] }), (0, Ct.jsxs)("div", { className: "arr-settings", children: [(0, Ct.jsx)("h3", { children: "Readarr" }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("readarr_adress") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("readarr_adress"), value: T, onChange: e => S(e.target.value) })] }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("readarr_folder") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("readarr_folder"), value: w, onChange: e => x(e.target.value) })] }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("readarr_api_key") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("readarr_api_key"), value: k, onChange: e => E(e.target.value) })] })] }), (0, Ct.jsxs)("div", { className: "arr-settings", children: [(0, Ct.jsx)("h3", { children: "Lidarr" }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("lidarr_adress") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("lidarr_adress"), value: C, onChange: e => P(e.target.value) })] }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("lidarr_folder") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("lidarr_folder"), value: I, onChange: e => L(e.target.value) })] }), (0, Ct.jsxs)("div", { className: "inline-flex", children: [(0, Ct.jsx)("p", { children: M("lidarr_api_key") }), (0, Ct.jsx)("input", { className: "input", placeholder: M("lidarr_api_key"), value: O, onChange: e => A(e.target.value) })] })] })] }), (0, Ct.jsx)(qt, { text: M("save_settings"), onClick: function () { const t = { language: e, tmdbKey: i, igdbID: s, igdbSecret: o, radarrAPI: p, radarrFolder: d, radarrAdress: c, sonarrAPI: b, sonarrFolder: y, sonarrAdress: m, readarrAPI: k, readarrFolder: w, readarrAdress: T, lidarrAPI: O, lidarrFolder: I, lidarrAdress: C }; console.log(t), D({ url: "".concat("", "/save_settings"), body: t }) } })] })] }) } function xm() { const { handleSubmit: e } = De(), { getLang: t } = Yt(); return (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)("h1", { children: t("rescan") }), (0, Ct.jsx)(qt, { text: t("rescan_all_lib"), icon: (0, Ct.jsx)(pt, {}), onClick: function () { e({ url: "".concat("", "/rescan_all"), body: {}, headers: { "Content-Type": "application/json" } }) } })] }) } function km() { return _n(), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(Ot, {}), (0, Ct.jsx)(kn, {}), (0, Ct.jsxs)("div", { className: "settings", children: [(0, Ct.jsx)(mm, {}), (0, Ct.jsx)(_m, {}), (0, Ct.jsx)(Sm, {}), (0, Ct.jsx)(xm, {}), (0, Ct.jsx)(wm, {})] })] }) } function Em() { const [e, n] = (0, t.useState)(""), [i, r] = (0, t.useState)(""), [s, a] = (0, t.useState)(""), [o, l] = (0, t.useState)(""), [c, u] = (0, t.useState)(!1), { handleSubmit: d } = De(), { data: h } = je("".concat("", "/get_profil/").concat(s)), { getLang: p } = Yt(); (0, t.useEffect)((() => { n(localStorage.getItem("username")), a(localStorage.getItem("id")), l("".concat("", "/user_image/").concat(s)) }), [s]); return (0, Ct.jsx)(Ct.Fragment, { children: h && (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(Ot, {}), (0, Ct.jsxs)("div", { className: "profilDiv", children: [(0, Ct.jsxs)("div", { className: "imageDiv", children: [c && (0, Ct.jsx)("div", { className: "profilPictureHover", children: (0, Ct.jsx)(lt, { className: "editProfilPicture" }) }), (0, Ct.jsx)("label", { htmlFor: "uploadImage", children: (0, Ct.jsx)("img", { src: o, alt: "profil", className: "profilPicture", onMouseEnter: () => u(!0), onMouseLeave: () => u(!1) }) }), (0, Ct.jsx)("input", { id: "uploadImage", type: "file", accept: "image/*", style: { display: "none" }, onChange: e => { const t = e.target.files[0], n = new FileReader; n.onloadend = () => { l(n.result) }, t && n.readAsDataURL(t) } })] }), (0, Ct.jsxs)("div", { className: "profilInfos", children: [(0, Ct.jsx)("input", { type: "text", placeholder: p("username"), className: "input", value: e, onChange: e => n(e.target.value) }), (null === h || void 0 === h ? void 0 : h.account_type) && "Kid" !== (null === h || void 0 === h ? void 0 : h.account_type) && (0, Ct.jsx)("input", { type: "password", placeholder: p("password"), className: "input", value: i, onChange: e => r(e.target.value), autoComplete: "one-time-code" }), (0, Ct.jsx)(qt, { text: p("save"), onClick: () => { d({ url: "".concat("", "/edit_profil"), body: { id: s, name: e, password: i, image: o } }), $t("Profil updated !") } })] })] })] }) }) } const Cm = Ne((e => ({ visible: !1, setVisible: t => e({ visible: t }), isOpened: !1, setIsOpened: t => e({ isOpened: t }), isPlaying: !1, setIsPlaying: t => e({ isPlaying: t }), isMuted: !1, setIsMuted: t => e({ isMuted: t }), mute: () => e((e => ({ isMuted: !e.isMuted }))), volume: .5, setVolume: t => e({ volume: t }), sources: [], setSources: t => e({ sources: t }), sourceIndex: 0, setSourceIndex: t => e({ sourceIndex: t }) }))); function Pm() { const { data: e } = je("".concat("", "/language_file")); return localStorage.setItem("language", JSON.stringify(e)), null } function Im() { const { handleSubmit: e, resMsg: n } = De(), i = K().pathname.split("/")[1]; return (0, t.useEffect)((() => { e({ url: "".concat("", "/check_login"), body: { token: localStorage.getItem("token") } }) }), []), (0, t.useEffect)((() => { if (null !== n) if ("ok" === n.status) { let e = n.username, t = n.account_type, i = n.account_id; localStorage.setItem("username", e), localStorage.setItem("account_type", t), localStorage.setItem("id", i) } else localStorage.removeItem("token"), window.location.reload() }), [n, i]), null } const Lm = e => { let { children: t } = e; const n = null !== localStorage.getItem("token"), i = "/" + K().pathname.split("/")[1]; let r = !1; for (let s = 0; s < t.props.children.length; s++) { if ("/" + t.props.children[s].props.path.split("/")[1] === i) { r = t.props.children[s].props.no_login || !1; break } } return console.log(i, r), (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(Pm, {}), (0, Ct.jsx)(ke.ReactNotifications, {}), n && !r ? (0, Ct.jsxs)(Ct.Fragment, { children: [(0, Ct.jsx)(om, { store: Cm }), (0, Ct.jsx)(cm, {}), (0, Ct.jsx)(Im, {}), t] }) : r ? (0, Ct.jsx)(Ct.Fragment, { children: t }) : (0, Ct.jsx)(Ct.Fragment, { children: (0, Ct.jsx)(ym, {}) })] }) }, Om = () => ((0, t.useEffect)((() => { Ce().init() }), []), (0, Ct.jsx)(be, { children: (0, Ct.jsx)(Lm, { children: (0, Ct.jsxs)(he, { children: [(0, Ct.jsx)(ue, { path: "/", element: (0, Ct.jsx)(jt, {}) }), (0, Ct.jsx)(ue, { path: "/movies/:lib", element: (0, Ct.jsx)(nn, {}) }), (0, Ct.jsx)(ue, { path: "/series/:lib", element: (0, Ct.jsx)(an, {}) }), (0, Ct.jsx)(ue, { path: "/season/:id", element: (0, Ct.jsx)(En, {}) }), (0, Ct.jsx)(ue, { path: "/books/:lib", element: (0, Ct.jsx)(ln, {}) }), (0, Ct.jsx)(ue, { path: "/others/:lib", element: (0, Ct.jsx)(un, {}) }), (0, Ct.jsx)(ue, { path: "/tv/:lib", element: (0, Ct.jsx)(dn, {}) }), (0, Ct.jsx)(ue, { path: "/consoles/:lib", element: (0, Ct.jsx)(pn, {}) }), (0, Ct.jsx)(ue, { path: "/musics/:lib", element: (0, Ct.jsx)(bn, {}) }), (0, Ct.jsx)(ue, { path: "/edit_movie/:id/:lib", element: (0, Ct.jsx)(Tn, {}) }), (0, Ct.jsx)(ue, { path: "/edit_serie/:id/:lib", element: (0, Ct.jsx)(Sn, {}) }), (0, Ct.jsx)(ue, { path: "/console/:lib/:console", element: (0, Ct.jsx)(Pn, {}) }), (0, Ct.jsx)(ue, { path: "/album/:lib/:id", element: (0, Ct.jsx)(jn, {}) }), (0, Ct.jsx)(ue, { path: "/playlist/:lib/:id", element: (0, Ct.jsx)(Dn, {}) }), (0, Ct.jsx)(ue, { path: "/artist/:lib/:id", element: (0, Ct.jsx)(Mn, {}) }), (0, Ct.jsx)(ue, { path: "/movie/:id", element: (0, Ct.jsx)(Op, {}) }), (0, Ct.jsx)(ue, { path: "/episode/:id", element: (0, Ct.jsx)(Ap, {}) }), (0, Ct.jsx)(ue, { path: "/other/:id", element: (0, Ct.jsx)(Np, {}) }), (0, Ct.jsx)(ue, { path: "/book/:id", element: (0, Ct.jsx)(im, {}) }), (0, Ct.jsx)(ue, { path: "/channel/:lib/:id", element: (0, Ct.jsx)(rm, {}) }), (0, Ct.jsx)(ue, { path: "/game/:lib/:console/:id", element: (0, Ct.jsx)(am, {}) }), (0, Ct.jsx)(ue, { path: "/actor/:id", element: (0, Ct.jsx)(um, {}) }), (0, Ct.jsx)(ue, { path: "/logout", element: (0, Ct.jsx)(vm, {}) }), (0, Ct.jsx)(ue, { path: "/settings", element: (0, Ct.jsx)(km, {}) }), (0, Ct.jsx)(ue, { path: "/profil", element: (0, Ct.jsx)(Em, {}) }), (0, Ct.jsx)(ue, { path: "/logout", element: (0, Ct.jsx)(vm, {}) }), (0, Ct.jsx)(ue, { path: "/add_media", element: (0, Ct.jsx)(dm, {}) }), (0, Ct.jsx)(ue, { path: "/login", element: (0, Ct.jsx)(ym, {}), no_login: !0 }), (0, Ct.jsx)(ue, { path: "/invite/:key", element: (0, Ct.jsx)(gm, {}), no_login: !0 })] }) }) })), Am = e => { e && e instanceof Function && n.e(787).then(n.bind(n, 787)).then((t => { let { getCLS: n, getFID: i, getFCP: r, getLCP: s, getTTFB: a } = t; n(e), i(e), r(e), s(e), a(e) })) }; i.createRoot(document.getElementById("root")).render((0, Ct.jsx)(t.StrictMode, { children: (0, Ct.jsx)(Om, {}) })), Am() })() })();
//# sourceMappingURL=main.0ec79dbd.js.map